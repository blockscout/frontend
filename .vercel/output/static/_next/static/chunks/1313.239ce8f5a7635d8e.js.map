{"version":3,"file":"static/chunks/1313.239ce8f5a7635d8e.js","mappings":"4YAEA,MAAc,QAAK,EACnB,sBACA,CAAC,EACM,GACP,QACA,oBACe,QAAM,QAErB,aACe,QAAG,aAElB,aACA,cACA,6CAEA,iBACK,CACL,kBACA,wBACA,sBAEA,OADA,iBACA,CACA,CAAK,CACL,mBACA,IACA,wBACA,uBAKA,OAJA,IACA,mBACA,2BAEA,SACA,CACA,MACA,MACA,CACA,CAAK,CACL,iBAEA,MADA,kBACA,iBAEA,OADA,mBACA,CACA,CAAK,CACL,uBACA,wBAEA,OADA,wBAEA,CAAK,CACL,eACA,wBAEA,OADA,gBAEA,CAAK,CACL,gBACA,uBACA,mBACA,wBACA,wBACA,eACA,CAAK,CACL,YACA,uBACA,gBACA,CAAK,CACL,YACA,uBACA,gBACA,CAAK,CACL,uBACA,UAAwB,QAAG,IAC3B,kCACA,oCACA,CAAK,CACL,YACA,SACA,CAAK,CACL,aACA,UACA,CAAK,CACL,cACA,WACA,CAAK,CACL,cACA,YACA,4BACA,CACA,iBCxFO,OACP,sBACA,CCCO,SACP,eACA,YAAgB,8BAAyC,EAAa,8CAAgD,EAAa,0GAAsI,CACzQ,eACA,UACA,yBACA,2BACA,sBACA,yBACA,wBACA,EACA,cACA,CACA,kBACA,qCACA,MACA,kEAEA,QACA,CACA,yBACA,kDAA+D,CAE/D,iBACA,oCACA,MACA,yEAEA,QACA,CACA,uBAEA,OADA,mCAEA,CACA,mBACA,sCACA,MACA,sEAEA,QACA,CACA,eACA,MAAc,IAAQ,sBACtB,sCACA,MACA,8CAEA,QACA,CACA,gBACA,MAAqB,IAAQ,iBAC7B,MAGA,wBACA,GACA,CACA,eC3DA,qBAA2C,GAAG,GAC9C,6BACO,cACP,0BACA,CACO,cACP,gBAAqB,mBAAsD,EAEpE,0BAAiC,8CAAiD,EACzF,MAAkB,SAAsB,QAIxC,OAHA,GACA,SAAwB,SAAuB,aAE/C,CACA,2BCdA,MAAe,QAAG;;;;;;;;;;AAUlB,CAAC,CCDD,CDCE,CCDF,cAAwD,IAAU,CAClE,cACA,oBACA,kBAA4B,IAAiB,uBAC7C,oBAA8B,IAAiB,gCAC/C,CACA,eACA,gEACA,QACA,6CAEA,QACA,6CAEA,CACA,SACA,MAAe,QAAI;;0BAEnB,GAA4B;kBAC5B,EAAoB;;sCAEpB,EAAwC,oBAAoB;IAC5D,EAEA,qBACA,YAA2B,4BAA8B,EAAI,YAAwB,GACrF,cACA,wCACA,sBACA,cACA,CAAS,CACT,CACA,EACA,SAA2B,EAC3B,EA5C8B,EA2CG,OA3CH,SAC9B,mFACA,kGACA,qBAA6C,KAAQ,oDACrD,6CACA,EAuCA,CACI,mBAAa,wBACjB,8BC9CI,EAA0B,kBAC9B,aADc,IAAI,CAClB,QADsB,CACtB,GAD0B,CAC1B,QAD8B,CAC9B,2CACA,kGACA,qBAA6C,KAAQ,oDACrD,6CACA,EAOA,oBAAgE,IAAU,CAC1E,cACA,oBACA,cAAwB,IAAiB,sBACzC,kBACA,oBACA,CACA,SACA,MAAe,QAAI;iDACnB,EAAmD,sBAAyB;;;;iBAI5E,EAAmB;;;;;WAKnB,EAAa,uBAAyB;;;;iBAItC,EAAmB;;;;;;;;;yBASnB,EAA2B,sBAAyB;;;;;;mBAMpD,EAAqB;iBACrB,EAAmB;;;;;;;;;;iBAUnB,EAAmB;mBACnB,EAAqB;;;UAGrB,EAAY;;;IAGZ,CACA,CACA,eACA,kBACQ,IAAgB,YACxB,gCACA,aACA,YACA,QAAyB,IAAe,4CACxC,eAAgC,IAAiB,8BAC7B,IAAoB,4BACxC,CACA,CAAS,EACT,IACY,EAAc,qBAC1B,YAAkC,EAAc,SAWhD,GAXgD,IACpC,EAAc,qBACd,IAAgB,YAC5B,0BACA,aACA,YACA,QAA6B,IAAe,4CAC5C,eAAoC,IAAiB,8BAC7B,IAAoB,6BAE5C,CAAa,EACb,CACA,CACA,SAEA,MADyC,IAAiB,8BACE,IAAoB,6BAQhF,OAPA,EACgB,IAAe,gEAGf,IAAe,iCAEnB,EAAc,mBACP,IAAgB,YACnC,wBACA,aACA,YACA,QAA6B,IAAe,4CAC5C,gBACA,CACA,CAAa,CACb,QACA,CACA,iBACA,CACA,CACA,iBACA,qBAC4B,IAAe,0BAE3C,MAAkB,IAAoB,cAC1B,IAAe,UAGf,IAAgB,iBAE5B,qBACQ,IAAgB,YACxB,0BACA,aACA,YACA,QAAyB,IAAe,4CACxC,eAAgC,IAAiB,8BAC7B,IAAoB,6BAExC,CAAS,CACT,CACA,EACA,EAAU,CACN,QAAK,GACT,mBAFU,MAEV,QACA,EAAU,CACN,QAAK,GACT,mBAFU,SAEV,QACA,EAAwB,EAAU,CAC9B,mBAAa,WADiB,kBAElC,mBClJA,SACO,cACP,mBACA,IACA,mCACA,MACA,OAEA,eACA,+CAEA,eACA,+CAEA,QACA,CACA,SACA,kDACA,MACA,CACA,CACA,mBACA,0BACA,uBACA,CA8BA,OA7BA,kBACA,OAAuB,IAAe,4CACtC,qCACA,OAEA,gBACA,GACA,YAAgC,IAAW,0CAE3C,SAEA,CAAK,EAAG,IAAe,4CACvB,sCACA,WAEA,UAEA,MACA,CACA,qCACA,gBACA,4BACA,EAAyC,IAAc,oCACvD,UAEA,SAEA,CACA,CAAK,GACL,CACA,uBACA,2CACA,MACA,6CAEA,yCACA,kCAEA,OACA,QACA,QAHA,IAIA,sBACA,gCACA,kBACA,gBACA,UACA,gBACA,sBACA,sBACA,qBACA,WACA,8BACA,KACA,QAA6B,IAAW,qCACxC,mBAAwC,UAAc,GAAG,iBAAqB,EAC9E,QACA,QAnBA,IAoBA,KACA,CAAiB,CACjB,CACA,CAAS,CACT,oBAEA,IAD4B,IAAW,iCAEvC,yBAEA,oCAKA,OAJA,sBACA,8BACA,QAA6B,IAAW,gCACxC,CAAiB,EACjB,iBAEA,wCACA,CAAS,CACT,yBACA,IACA,SACA,CACA,SACA,2DACA,CACA,CAAS,CACT,qBACA,gBACA,IACA,SACA,CACA,SACA,yDACA,KAEA,CACA,iCAAuE,IAAe,oDACtF,kBACA,CACA,CAAS,CACT,uBACA,IACA,4BACA,OACA,CACA,MACA,iBACA,SACA,CAA6B,CAC7B,WACA,YACA,EACA,CAEA,gBACA,YAAoD,WAAqB,EACzE,4BACA,mBACA,OACA,OACA,MACA,SAUA,OARA,CACA,MACA,yBACA,SACA,CAAqB,CACrB,WACA,YACA,EACA,CAEA,SAEA,OADA,mDACA,GAEA,CACA,CACA,CC9JO,cACP,WAAe,EAAgB,EAC/B","sources":["webpack://_N_E/./node_modules/@reown/appkit-siwe/dist/esm/core/controller/SIWEController.js","webpack://_N_E/./node_modules/@reown/appkit-siwe/dist/esm/core/utils/ConstantsUtil.js","webpack://_N_E/./node_modules/@reown/appkit-siwe/dist/esm/src/client.js","webpack://_N_E/./node_modules/@reown/appkit-siwe/dist/esm/core/helpers/index.js","webpack://_N_E/./node_modules/@reown/appkit-siwe/dist/esm/scaffold/partials/w3m-connecting-siwe/styles.js","webpack://_N_E/./node_modules/@reown/appkit-siwe/dist/esm/scaffold/partials/w3m-connecting-siwe/index.js","webpack://_N_E/./node_modules/@reown/appkit-siwe/dist/esm/scaffold/views/w3m-connecting-siwe-view/index.js","webpack://_N_E/./node_modules/@reown/appkit-siwe/dist/esm/src/mapToSIWX.js","webpack://_N_E/./node_modules/@reown/appkit-siwe/dist/esm/exports/index.js"],"sourcesContent":["import { subscribeKey as subKey } from 'valtio/vanilla/utils';\nimport { proxy, ref, subscribe as sub } from 'valtio/vanilla';\nconst state = proxy({\n    status: 'uninitialized'\n});\nexport const SIWEController = {\n    state,\n    subscribeKey(key, callback) {\n        return subKey(state, key, callback);\n    },\n    subscribe(callback) {\n        return sub(state, () => callback(state));\n    },\n    _getClient() {\n        if (!state._client) {\n            throw new Error('SIWEController client not set');\n        }\n        return state._client;\n    },\n    async getNonce(address) {\n        const client = this._getClient();\n        const nonce = await client.getNonce(address);\n        this.setNonce(nonce);\n        return nonce;\n    },\n    async getSession() {\n        try {\n            const client = this._getClient();\n            const session = await client.getSession();\n            if (session) {\n                this.setSession(session);\n                this.setStatus('success');\n            }\n            return session || undefined;\n        }\n        catch {\n            return undefined;\n        }\n    },\n    createMessage(args) {\n        const client = this._getClient();\n        const message = client.createMessage(args);\n        this.setMessage(message);\n        return message;\n    },\n    async verifyMessage(args) {\n        const client = this._getClient();\n        const isValid = await client.verifyMessage(args);\n        return isValid;\n    },\n    async signIn() {\n        const client = this._getClient();\n        const session = await client.signIn();\n        return session;\n    },\n    async signOut() {\n        const client = this._getClient();\n        await client.signOut();\n        this.setStatus('ready');\n        this.setSession(undefined);\n        client.onSignOut?.();\n    },\n    onSignIn(args) {\n        const client = this._getClient();\n        client.onSignIn?.(args);\n    },\n    onSignOut() {\n        const client = this._getClient();\n        client.onSignOut?.();\n    },\n    async setSIWEClient(client) {\n        state._client = ref(client);\n        state.session = await this.getSession();\n        state.status = state.session ? 'success' : 'ready';\n    },\n    setNonce(nonce) {\n        state.nonce = nonce;\n    },\n    setStatus(status) {\n        state.status = status;\n    },\n    setMessage(message) {\n        state.message = message;\n    },\n    setSession(session) {\n        state.session = session;\n        state.status = session ? 'success' : 'ready';\n    }\n};\n//# sourceMappingURL=SIWEController.js.map","export const ConstantsUtil = {\n    FIVE_MINUTES_IN_MS: 300000\n};\n//# sourceMappingURL=ConstantsUtil.js.map","import {} from '../core/controller/SIWEController.js';\nimport { SIWXUtil } from '@reown/appkit-core';\nimport { ConstantsUtil } from '../core/utils/ConstantsUtil.js';\nexport class AppKitSIWEClient {\n    constructor(siweConfig) {\n        const { enabled = true, nonceRefetchIntervalMs = ConstantsUtil.FIVE_MINUTES_IN_MS, sessionRefetchIntervalMs = ConstantsUtil.FIVE_MINUTES_IN_MS, signOutOnAccountChange = true, signOutOnDisconnect = true, signOutOnNetworkChange = true, ...siweConfigMethods } = siweConfig;\n        this.options = {\n            enabled,\n            nonceRefetchIntervalMs,\n            sessionRefetchIntervalMs,\n            signOutOnDisconnect,\n            signOutOnAccountChange,\n            signOutOnNetworkChange\n        };\n        this.methods = siweConfigMethods;\n    }\n    async getNonce(address) {\n        const nonce = await this.methods.getNonce(address);\n        if (!nonce) {\n            throw new Error('siweControllerClient:getNonce - nonce is undefined');\n        }\n        return nonce;\n    }\n    async getMessageParams() {\n        return ((await this.methods.getMessageParams?.()) || {});\n    }\n    createMessage(args) {\n        const message = this.methods.createMessage(args);\n        if (!message) {\n            throw new Error('siweControllerClient:createMessage - message is undefined');\n        }\n        return message;\n    }\n    async verifyMessage(args) {\n        const isValid = await this.methods.verifyMessage(args);\n        return isValid;\n    }\n    async getSession() {\n        const session = await this.methods.getSession();\n        if (!session) {\n            throw new Error('siweControllerClient:getSession - session is undefined');\n        }\n        return session;\n    }\n    async signIn() {\n        await SIWXUtil.requestSignMessage();\n        const session = await this.methods.getSession();\n        if (!session) {\n            throw new Error('Error verifying SIWE signature');\n        }\n        return session;\n    }\n    async signOut() {\n        const siwx = SIWXUtil.getSIWX();\n        if (!siwx) {\n            return false;\n        }\n        await siwx.setSessions([]);\n        return true;\n    }\n}\n//# sourceMappingURL=client.js.map","import { isValidEip191Signature, isValidEip1271Signature } from '@walletconnect/utils';\nconst ETH_ADDRESS_PATTERN = /0x[a-fA-F0-9]{40}/u;\nconst ETH_CHAIN_ID_IN_SIWE_PATTERN = /Chain ID: (?<temp1>\\d+)/u;\nexport function getAddressFromMessage(message) {\n    return message.match(ETH_ADDRESS_PATTERN)?.[0] || '';\n}\nexport function getChainIdFromMessage(message) {\n    return `eip155:${message.match(ETH_CHAIN_ID_IN_SIWE_PATTERN)?.[1] || 1}`;\n}\nexport async function verifySignature({ address, message, signature, chainId, projectId }) {\n    let isValid = isValidEip191Signature(address, message, signature);\n    if (!isValid) {\n        isValid = await isValidEip1271Signature(address, message, signature, chainId, projectId);\n    }\n    return isValid;\n}\n//# sourceMappingURL=index.js.map","import { css } from 'lit';\nexport default css `\n  :host {\n    display: flex;\n    justify-content: center;\n    gap: var(--wui-spacing-2xl);\n  }\n\n  wui-visual-thumbnail:nth-child(1) {\n    z-index: 1;\n  }\n`;\n//# sourceMappingURL=styles.js.map","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { customElement } from '@reown/appkit-ui';\nimport { LitElement, html } from 'lit';\nimport styles from './styles.js';\nimport { AccountController, OptionsController } from '@reown/appkit-core';\nlet W3mConnectingSiwe = class W3mConnectingSiwe extends LitElement {\n    constructor() {\n        super(...arguments);\n        this.dappImageUrl = OptionsController.state.metadata?.icons;\n        this.walletImageUrl = AccountController.state.connectedWalletInfo?.icon;\n    }\n    firstUpdated() {\n        const visuals = this.shadowRoot?.querySelectorAll('wui-visual-thumbnail');\n        if (visuals?.[0]) {\n            this.createAnimation(visuals[0], 'translate(18px)');\n        }\n        if (visuals?.[1]) {\n            this.createAnimation(visuals[1], 'translate(-18px)');\n        }\n    }\n    render() {\n        return html `\n      <wui-visual-thumbnail\n        ?borderRadiusFull=${true}\n        .imageSrc=${this.dappImageUrl?.[0]}\n      ></wui-visual-thumbnail>\n      <wui-visual-thumbnail .imageSrc=${this.walletImageUrl}></wui-visual-thumbnail>\n    `;\n    }\n    createAnimation(element, translation) {\n        element.animate([{ transform: 'translateX(0px)' }, { transform: translation }], {\n            duration: 1600,\n            easing: 'cubic-bezier(0.56, 0, 0.48, 1)',\n            direction: 'alternate',\n            iterations: Infinity\n        });\n    }\n};\nW3mConnectingSiwe.styles = styles;\nW3mConnectingSiwe = __decorate([\n    customElement('w3m-connecting-siwe')\n], W3mConnectingSiwe);\nexport { W3mConnectingSiwe };\n//# sourceMappingURL=index.js.map","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { AccountController, ChainController, ConnectionController, EventsController, ModalController, OptionsController, RouterController, SnackController } from '@reown/appkit-core';\nimport { customElement } from '@reown/appkit-ui';\nimport { LitElement, html } from 'lit';\nimport { state } from 'lit/decorators.js';\nimport { SIWEController } from '../../../core/controller/SIWEController.js';\nimport { W3mFrameRpcConstants } from '@reown/appkit-wallet';\nlet W3mConnectingSiweView = class W3mConnectingSiweView extends LitElement {\n    constructor() {\n        super(...arguments);\n        this.dappName = OptionsController.state.metadata?.name;\n        this.isSigning = false;\n        this.isCancelling = false;\n    }\n    render() {\n        return html `\n      <wui-flex justifyContent=\"center\" .padding=${['2xl', '0', 'xxl', '0']}>\n        <w3m-connecting-siwe></w3m-connecting-siwe>\n      </wui-flex>\n      <wui-flex\n        .padding=${['0', '4xl', 'l', '4xl']}\n        gap=\"s\"\n        justifyContent=\"space-between\"\n      >\n        <wui-text variant=\"paragraph-500\" align=\"center\" color=\"fg-100\"\n          >${this.dappName ?? 'Dapp'} needs to connect to your wallet</wui-text\n        >\n      </wui-flex>\n      <wui-flex\n        .padding=${['0', '3xl', 'l', '3xl']}\n        gap=\"s\"\n        justifyContent=\"space-between\"\n      >\n        <wui-text variant=\"small-400\" align=\"center\" color=\"fg-200\"\n          >Sign this message to prove you own this wallet and proceed. Canceling will disconnect\n          you.</wui-text\n        >\n      </wui-flex>\n      <wui-flex .padding=${['l', 'xl', 'xl', 'xl']} gap=\"s\" justifyContent=\"space-between\">\n        <wui-button\n          size=\"lg\"\n          borderRadius=\"xs\"\n          fullWidth\n          variant=\"neutral\"\n          ?loading=${this.isCancelling}\n          @click=${this.onCancel.bind(this)}\n          data-testid=\"w3m-connecting-siwe-cancel\"\n        >\n          Cancel\n        </wui-button>\n        <wui-button\n          size=\"lg\"\n          borderRadius=\"xs\"\n          fullWidth\n          variant=\"main\"\n          @click=${this.onSign.bind(this)}\n          ?loading=${this.isSigning}\n          data-testid=\"w3m-connecting-siwe-sign\"\n        >\n          ${this.isSigning ? 'Signing...' : 'Sign'}\n        </wui-button>\n      </wui-flex>\n    `;\n    }\n    async onSign() {\n        this.isSigning = true;\n        EventsController.sendEvent({\n            event: 'CLICK_SIGN_SIWX_MESSAGE',\n            type: 'track',\n            properties: {\n                network: ChainController.state.activeCaipNetwork?.caipNetworkId || '',\n                isSmartAccount: AccountController.state.preferredAccountType ===\n                    W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT\n            }\n        });\n        try {\n            SIWEController.setStatus('loading');\n            const session = await SIWEController.signIn();\n            SIWEController.setStatus('success');\n            EventsController.sendEvent({\n                event: 'SIWX_AUTH_SUCCESS',\n                type: 'track',\n                properties: {\n                    network: ChainController.state.activeCaipNetwork?.caipNetworkId || '',\n                    isSmartAccount: AccountController.state.preferredAccountType ===\n                        W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT\n                }\n            });\n            return session;\n        }\n        catch (error) {\n            const preferredAccountType = AccountController.state.preferredAccountType;\n            const isSmartAccount = preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT;\n            if (isSmartAccount) {\n                SnackController.showError('This application might not support Smart Accounts');\n            }\n            else {\n                SnackController.showError('Signature declined');\n            }\n            SIWEController.setStatus('error');\n            return EventsController.sendEvent({\n                event: 'SIWX_AUTH_ERROR',\n                type: 'track',\n                properties: {\n                    network: ChainController.state.activeCaipNetwork?.caipNetworkId || '',\n                    isSmartAccount\n                }\n            });\n        }\n        finally {\n            this.isSigning = false;\n        }\n    }\n    async onCancel() {\n        this.isCancelling = true;\n        const caipAddress = ChainController.state.activeCaipAddress;\n        if (caipAddress) {\n            await ConnectionController.disconnect();\n            ModalController.close();\n        }\n        else {\n            RouterController.push('Connect');\n        }\n        this.isCancelling = false;\n        EventsController.sendEvent({\n            event: 'CLICK_CANCEL_SIWX',\n            type: 'track',\n            properties: {\n                network: ChainController.state.activeCaipNetwork?.caipNetworkId || '',\n                isSmartAccount: AccountController.state.preferredAccountType ===\n                    W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT\n            }\n        });\n    }\n};\n__decorate([\n    state()\n], W3mConnectingSiweView.prototype, \"isSigning\", void 0);\n__decorate([\n    state()\n], W3mConnectingSiweView.prototype, \"isCancelling\", void 0);\nW3mConnectingSiweView = __decorate([\n    customElement('w3m-connecting-siwe-view')\n], W3mConnectingSiweView);\nexport { W3mConnectingSiweView };\n//# sourceMappingURL=index.js.map","import { ChainController, CoreHelperUtil } from '@reown/appkit-core';\nimport { NetworkUtil } from '@reown/appkit-common';\nconst subscriptions = [];\nexport function mapToSIWX(siwe) {\n    async function getSession() {\n        try {\n            const response = await siwe.methods.getSession();\n            if (!response) {\n                return undefined;\n            }\n            if (!response?.address) {\n                throw new Error('SIWE session is missing address');\n            }\n            if (!response?.chainId) {\n                throw new Error('SIWE session is missing chainId');\n            }\n            return response;\n        }\n        catch (error) {\n            console.warn('AppKit:SIWE:getSession - error:', error);\n            return undefined;\n        }\n    }\n    async function signOut() {\n        await siwe.methods.signOut();\n        siwe.methods.onSignOut?.();\n    }\n    subscriptions.forEach(unsubscribe => unsubscribe());\n    subscriptions.push(ChainController.subscribeKey('activeCaipNetwork', async (activeCaipNetwork) => {\n        if (!siwe.options.signOutOnNetworkChange) {\n            return;\n        }\n        const session = await getSession();\n        const isDifferentNetwork = session &&\n            session.chainId !== NetworkUtil.caipNetworkIdToNumber(activeCaipNetwork?.caipNetworkId);\n        if (isDifferentNetwork) {\n            await signOut();\n        }\n    }), ChainController.subscribeKey('activeCaipAddress', async (activeCaipAddress) => {\n        if (siwe.options.signOutOnDisconnect && !activeCaipAddress) {\n            const session = await getSession();\n            if (session) {\n                await signOut();\n            }\n            return;\n        }\n        if (siwe.options.signOutOnAccountChange) {\n            const session = await getSession();\n            const lowercaseSessionAddress = session?.address?.toLowerCase();\n            const lowercaseCaipAddress = CoreHelperUtil?.getPlainAddress(activeCaipAddress)?.toLowerCase();\n            const isDifferentAddress = session && lowercaseSessionAddress !== lowercaseCaipAddress;\n            if (isDifferentAddress) {\n                await signOut();\n            }\n        }\n    }));\n    return {\n        async createMessage(input) {\n            const params = await siwe.methods.getMessageParams?.();\n            if (!params) {\n                throw new Error('Failed to get message params!');\n            }\n            const nonce = await siwe.getNonce(input.accountAddress);\n            const issuedAt = params.iat || new Date().toISOString();\n            const version = '1';\n            return {\n                nonce,\n                version,\n                requestId: params.requestId,\n                accountAddress: input.accountAddress,\n                chainId: input.chainId,\n                domain: params.domain,\n                uri: params.uri,\n                notBefore: params.nbf,\n                resources: params.resources,\n                statement: params.statement,\n                expirationTime: params.exp,\n                issuedAt,\n                toString: () => siwe.createMessage({\n                    ...params,\n                    chainId: NetworkUtil.caipNetworkIdToNumber(input.chainId) || 1,\n                    address: `did:pkh:${input.chainId}:${input.accountAddress}`,\n                    nonce,\n                    version,\n                    iat: issuedAt\n                })\n            };\n        },\n        async addSession(session) {\n            const chainId = NetworkUtil.parseEvmChainId(session.data.chainId);\n            if (!chainId) {\n                return Promise.resolve();\n            }\n            if (await siwe.methods.verifyMessage(session)) {\n                siwe.methods.onSignIn?.({\n                    address: session.data.accountAddress,\n                    chainId: NetworkUtil.parseEvmChainId(session.data.chainId)\n                });\n                return Promise.resolve();\n            }\n            throw new Error('Failed to verify message');\n        },\n        async revokeSession(_chainId, _address) {\n            try {\n                await signOut();\n            }\n            catch (error) {\n                console.warn('AppKit:SIWE:revokeSession - signOut error', error);\n            }\n        },\n        async setSessions(sessions) {\n            if (sessions.length === 0) {\n                try {\n                    await signOut();\n                }\n                catch (error) {\n                    console.warn('AppKit:SIWE:setSessions - signOut error', error);\n                }\n            }\n            else {\n                const session = (sessions.find(s => s.data.chainId === ChainController.getActiveCaipNetwork()?.caipNetworkId) || sessions[0]);\n                await this.addSession(session);\n            }\n        },\n        async getSessions(chainId, address) {\n            try {\n                if (!chainId.startsWith('eip155:')) {\n                    return [\n                        {\n                            data: {\n                                accountAddress: address,\n                                chainId\n                            },\n                            message: '',\n                            signature: ''\n                        }\n                    ];\n                }\n                const siweSession = await getSession();\n                const siweCaipNetworkId = `eip155:${siweSession?.chainId}`;\n                const lowercaseSessionAddress = siweSession?.address?.toLowerCase();\n                const lowercaseCaipAddress = address?.toLowerCase();\n                if (!siweSession ||\n                    lowercaseSessionAddress !== lowercaseCaipAddress ||\n                    siweCaipNetworkId !== chainId) {\n                    return [];\n                }\n                const session = {\n                    data: {\n                        accountAddress: siweSession.address,\n                        chainId: siweCaipNetworkId\n                    },\n                    message: '',\n                    signature: ''\n                };\n                return [session];\n            }\n            catch (error) {\n                console.warn('AppKit:SIWE:getSessions - error:', error);\n                return [];\n            }\n        }\n    };\n}\n//# sourceMappingURL=mapToSIWX.js.map","import { AppKitSIWEClient } from '../src/client.js';\nexport { getAddressFromMessage, getChainIdFromMessage, verifySignature } from '../core/helpers/index.js';\nexport { formatMessage, getDidChainId, getDidAddress } from '@walletconnect/utils';\nexport { SIWEController } from '../core/controller/SIWEController.js';\nexport * from '../core/utils/TypeUtils.js';\nexport function createSIWEConfig(siweConfig) {\n    return new AppKitSIWEClient(siweConfig);\n}\nexport * from '../scaffold/partials/w3m-connecting-siwe/index.js';\nexport * from '../scaffold/views/w3m-connecting-siwe-view/index.js';\nexport * from '../src/mapToSIWX.js';\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":"","ignoreList":[0,1,2,3,4,5,6,7,8]}