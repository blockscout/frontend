{"version":3,"file":"static/chunks/5983.72a09b093e0a0729.js","mappings":"oIAAA,wBACA,qBAA4D,wBAA2B,EAEvF,gBAcA,OAbA,sBACA,6EACA,6BACA,2CACA,mCACA,cACA,eACA,YAEA,CAAS,CACT,CACA,CAAK,CACL,CAAG,EACH,0DAAsE,eAAiB,EACvF,CACA,wBACA,OAAoB,aAGpB,SACG,GACH,cACA,qBACA,4BACA,cAEA,QADA,EACA,aAA8C,KAC9C,kCACA,UACA,QACA,MACA,IACA,WACA,QACA,CACA,gBACA,MAEA,GADA,iCACA,6BACA,OAAuB,2BACvB,KACA,CACA,CAEA,cACA,kCACA,EACA,YAAgC,KAAgB,IAEhD,IADA,KACuB,CADvB,0BACuB,CACvB,sDAMA,GALA,KACA,aACA,KACA,aACA,mBACA,SACA,MACA,gDACA,QACA,SACA,SACA,IACA,IACA,OACA,EAEA,GACA,QAEA,cACA,KACA,CACA,gBACA,aACA,CACA,CAjCA,mBAkCA,iBAEA,QADA,KACA,IAAwB,WAAkB,KAC1C,cACA,GACA,SACA,CACA,qBACA,iBACS,EACT,YAAwB,WAAkB,KAC1C,cACA,KACA,QACA,CACA,WACA,CACA,CACA,sBACA,sCAAkE,IAAK,gBACvE,4CAAwE,IAAK,0BAC7E,+CACA,cACA,mCACA,YACA,+BAGA,GAFA,qBACA,mCACA,sCACA,YACA,0CAAmE,KAAQ,KAC3E,6BAA0D,GAC1D,SACA,OAAqB,6BACrB,CACA,CACA,iBACA,sBACA,2CACA,YACA,kBAAgC,KAChC,cACA,WACA,MACA,OACA,CACA,OAAe,0CACf,CAAK,EACL,gDACA,cACA,mCACA,YACA,+BAGA,GAFA,qBACA,mCACA,gDACA,gBACA,CACA,kBACA,oBACA,yBACA,YACA,YAEA,MADA,KADkC,GAIlC,IAEA,OACA,kBACA,sBACA,CACA,CAAK,CACL,CAAG,CAnIK,GAAU,UAsIlB,SACA,eACA,QAHA,UAIC","sources":["webpack://_N_E/./node_modules/@graphiql/react/dist/brace-fold.es.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { a as codemirror } from \"./codemirror.es.js\";\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== \"string\" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== \"default\" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: \"Module\" }));\n}\n__name(_mergeNamespaces, \"_mergeNamespaces\");\nvar braceFold$2 = { exports: {} };\n(function(module, exports) {\n  (function(mod) {\n    mod(codemirror.exports);\n  })(function(CodeMirror) {\n    function bracketFolding(pairs) {\n      return function(cm, start) {\n        var line = start.line, lineText = cm.getLine(line);\n        function findOpening(pair) {\n          var tokenType;\n          for (var at = start.ch, pass = 0; ; ) {\n            var found2 = at <= 0 ? -1 : lineText.lastIndexOf(pair[0], at - 1);\n            if (found2 == -1) {\n              if (pass == 1)\n                break;\n              pass = 1;\n              at = lineText.length;\n              continue;\n            }\n            if (pass == 1 && found2 < start.ch)\n              break;\n            tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found2 + 1));\n            if (!/^(comment|string)/.test(tokenType))\n              return { ch: found2 + 1, tokenType, pair };\n            at = found2 - 1;\n          }\n        }\n        __name(findOpening, \"findOpening\");\n        function findRange(found2) {\n          var count = 1, lastLine = cm.lastLine(), end, startCh = found2.ch, endCh;\n          outer:\n            for (var i2 = line; i2 <= lastLine; ++i2) {\n              var text = cm.getLine(i2), pos = i2 == line ? startCh : 0;\n              for (; ; ) {\n                var nextOpen = text.indexOf(found2.pair[0], pos), nextClose = text.indexOf(found2.pair[1], pos);\n                if (nextOpen < 0)\n                  nextOpen = text.length;\n                if (nextClose < 0)\n                  nextClose = text.length;\n                pos = Math.min(nextOpen, nextClose);\n                if (pos == text.length)\n                  break;\n                if (cm.getTokenTypeAt(CodeMirror.Pos(i2, pos + 1)) == found2.tokenType) {\n                  if (pos == nextOpen)\n                    ++count;\n                  else if (!--count) {\n                    end = i2;\n                    endCh = pos;\n                    break outer;\n                  }\n                }\n                ++pos;\n              }\n            }\n          if (end == null || line == end)\n            return null;\n          return {\n            from: CodeMirror.Pos(line, startCh),\n            to: CodeMirror.Pos(end, endCh)\n          };\n        }\n        __name(findRange, \"findRange\");\n        var found = [];\n        for (var i = 0; i < pairs.length; i++) {\n          var open = findOpening(pairs[i]);\n          if (open)\n            found.push(open);\n        }\n        found.sort(function(a, b) {\n          return a.ch - b.ch;\n        });\n        for (var i = 0; i < found.length; i++) {\n          var range = findRange(found[i]);\n          if (range)\n            return range;\n        }\n        return null;\n      };\n    }\n    __name(bracketFolding, \"bracketFolding\");\n    CodeMirror.registerHelper(\"fold\", \"brace\", bracketFolding([[\"{\", \"}\"], [\"[\", \"]\"]]));\n    CodeMirror.registerHelper(\"fold\", \"brace-paren\", bracketFolding([[\"{\", \"}\"], [\"[\", \"]\"], [\"(\", \")\"]]));\n    CodeMirror.registerHelper(\"fold\", \"import\", function(cm, start) {\n      function hasImport(line) {\n        if (line < cm.firstLine() || line > cm.lastLine())\n          return null;\n        var start2 = cm.getTokenAt(CodeMirror.Pos(line, 1));\n        if (!/\\S/.test(start2.string))\n          start2 = cm.getTokenAt(CodeMirror.Pos(line, start2.end + 1));\n        if (start2.type != \"keyword\" || start2.string != \"import\")\n          return null;\n        for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {\n          var text = cm.getLine(i), semi = text.indexOf(\";\");\n          if (semi != -1)\n            return { startCh: start2.end, end: CodeMirror.Pos(i, semi) };\n        }\n      }\n      __name(hasImport, \"hasImport\");\n      var startLine = start.line, has = hasImport(startLine), prev;\n      if (!has || hasImport(startLine - 1) || (prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1)\n        return null;\n      for (var end = has.end; ; ) {\n        var next = hasImport(end.line + 1);\n        if (next == null)\n          break;\n        end = next.end;\n      }\n      return { from: cm.clipPos(CodeMirror.Pos(startLine, has.startCh + 1)), to: end };\n    });\n    CodeMirror.registerHelper(\"fold\", \"include\", function(cm, start) {\n      function hasInclude(line) {\n        if (line < cm.firstLine() || line > cm.lastLine())\n          return null;\n        var start2 = cm.getTokenAt(CodeMirror.Pos(line, 1));\n        if (!/\\S/.test(start2.string))\n          start2 = cm.getTokenAt(CodeMirror.Pos(line, start2.end + 1));\n        if (start2.type == \"meta\" && start2.string.slice(0, 8) == \"#include\")\n          return start2.start + 8;\n      }\n      __name(hasInclude, \"hasInclude\");\n      var startLine = start.line, has = hasInclude(startLine);\n      if (has == null || hasInclude(startLine - 1) != null)\n        return null;\n      for (var end = startLine; ; ) {\n        var next = hasInclude(end + 1);\n        if (next == null)\n          break;\n        ++end;\n      }\n      return {\n        from: CodeMirror.Pos(startLine, has + 1),\n        to: cm.clipPos(CodeMirror.Pos(end))\n      };\n    });\n  });\n})();\nvar braceFold = braceFold$2.exports;\nvar braceFold$1 = /* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  \"default\": braceFold\n}, [braceFold$2.exports]);\nexport { braceFold$1 as b };\n"],"names":[],"sourceRoot":"","ignoreList":[0]}