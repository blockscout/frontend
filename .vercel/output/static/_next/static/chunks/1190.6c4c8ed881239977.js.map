{"version":3,"file":"static/chunks/1190.6c4c8ed881239977.js","mappings":"wMAGO,iBAAkC,GAAS,CAClD,8BAAkB,6CAAyD,EAC3E,sBACA,4DACA,QACA,iBACA,mBACA,6BACA,yBACA,IACA,uBACA,gBAAgD,OAAM,IAAM,GAC5D,CACA,aAA6B,EAAO,EACpC,WAA2B,EAAK,EAChC,wBAAwC,EAAiB,EACzD,iBAAiC,EAAU,EAC3C,QACA,0BACA,CAAS,CACT,CACA,CACO,gBAAmD,GAAS,CACnE,oBAAkB,QAAa,EAC/B,oFACA,cACA,gBAAgC,OAAM,IAAM,EAC5C,aAA6B,OAAS,IAAS,EAC/C,CACA,2CACA,CAAS,CACT,CACA,CACO,gBAAgD,GAAS,CAChE,oBAAkB,OAAY,EAC9B,gFACA,cACA,qBAAqC,EAAG,EACxC,kCAAkD,EAAO,EACzD,CACA,wCACA,CAAS,CACT,CACA,uECrCO,mBACA,GACP,sBACA,aACA,QACA,CACA,cACA,cACA,CAAS,CACT,CACA,YACA,eACA,CAAS,CACT,CACA,gBACA,YACA,CAAS,CACT,CACA,wBACA,aACA,CAAS,CACT,CACA,iBACA,YACA,CAAS,CACT,EAEO,oBAAwC,qCAAkC,EACjF,SAAY,GAAO,CAAE,MAAiB,EACtC,OACA,QACK,EACL,cACA,UAAY,GAAW,EACvB,mCACA,UACA,EACA,IACA,IAAa,OAAc,MAC3B,UAAsB,EAAiC,CAAG,cAAY,EACtE,eAA4C,uBAA8B,EAC1E,CAAgB,QAAc,MAAQ,OAAI,IAC1C,cACA,WACA,KAAkB,QAAM,EACxB,EACgB,OAAmB,GAAI,aAAe,EAAI,aAAe,SACzE,EACA,IACA,CAAS,EACT,QACA,CACA,SACA,UAAkB,EAAmB,CACrC,gBADqC,CACrC,EACA,QACA,OACA,YACA,SACA,MACA,CAAS,CACT,CACA,CACO,uBAA6B,kBAAqB,EACzD,0CACA,YAAoB,WAAiB,KACrC,WACA,eAAsC,KAAK,gBAC3C,mBAA2C,YAAe,OAC1D,cAA8C,mCAAqC,GACnF,QAMA,EALA,8BAAuD,OAAO,eAAqB,KAAK,MACxF,uBACA,UACA,QACA,CAAa,EAQb,GALA,EADA,8DACA,sBAGA,eAEA,OACA,MAA4B,IAAgB,EAC5C,OACA,iBAC0B,OAAS,UACnC,aACA,kBACA,gBACA,KACA,CAAiB,EACjB,QACA,CACA,IAAiB,OAAK,KACtB,MAA4B,EAAoC,CAChE,SACA,KACA,CAAiB,EACjB,QACA,CACA,QACA,CACA,SACA,MAAwB,IAAgB,EACxC,OACA,kBACA,KACA,CAAa,CACb,CACA,CACA,OACA","sources":["webpack://_N_E/./node_modules/viem/_esm/errors/ccip.js","webpack://_N_E/./node_modules/viem/_esm/utils/ccip.js"],"sourcesContent":["import { stringify } from '../utils/stringify.js';\nimport { BaseError } from './base.js';\nimport { getUrl } from './utils.js';\nexport class OffchainLookupError extends BaseError {\n    constructor({ callbackSelector, cause, data, extraData, sender, urls, }) {\n        super(cause.shortMessage ||\n            'An error occurred while fetching for an offchain result.', {\n            cause,\n            metaMessages: [\n                ...(cause.metaMessages || []),\n                cause.metaMessages?.length ? '' : [],\n                'Offchain Gateway Call:',\n                urls && [\n                    '  Gateway URL(s):',\n                    ...urls.map((url) => `    ${getUrl(url)}`),\n                ],\n                `  Sender: ${sender}`,\n                `  Data: ${data}`,\n                `  Callback selector: ${callbackSelector}`,\n                `  Extra data: ${extraData}`,\n            ].flat(),\n            name: 'OffchainLookupError',\n        });\n    }\n}\nexport class OffchainLookupResponseMalformedError extends BaseError {\n    constructor({ result, url }) {\n        super('Offchain gateway response is malformed. Response data must be a hex value.', {\n            metaMessages: [\n                `Gateway URL: ${getUrl(url)}`,\n                `Response: ${stringify(result)}`,\n            ],\n            name: 'OffchainLookupResponseMalformedError',\n        });\n    }\n}\nexport class OffchainLookupSenderMismatchError extends BaseError {\n    constructor({ sender, to }) {\n        super('Reverted sender address does not match target contract address (`to`).', {\n            metaMessages: [\n                `Contract address: ${to}`,\n                `OffchainLookup sender address: ${sender}`,\n            ],\n            name: 'OffchainLookupSenderMismatchError',\n        });\n    }\n}\n//# sourceMappingURL=ccip.js.map","import { call } from '../actions/public/call.js';\nimport { OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError, } from '../errors/ccip.js';\nimport { HttpRequestError, } from '../errors/request.js';\nimport { decodeErrorResult } from './abi/decodeErrorResult.js';\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js';\nimport { isAddressEqual } from './address/isAddressEqual.js';\nimport { concat } from './data/concat.js';\nimport { isHex } from './data/isHex.js';\nimport { stringify } from './stringify.js';\nexport const offchainLookupSignature = '0x556f1830';\nexport const offchainLookupAbiItem = {\n    name: 'OffchainLookup',\n    type: 'error',\n    inputs: [\n        {\n            name: 'sender',\n            type: 'address',\n        },\n        {\n            name: 'urls',\n            type: 'string[]',\n        },\n        {\n            name: 'callData',\n            type: 'bytes',\n        },\n        {\n            name: 'callbackFunction',\n            type: 'bytes4',\n        },\n        {\n            name: 'extraData',\n            type: 'bytes',\n        },\n    ],\n};\nexport async function offchainLookup(client, { blockNumber, blockTag, data, to, }) {\n    const { args } = decodeErrorResult({\n        data,\n        abi: [offchainLookupAbiItem],\n    });\n    const [sender, urls, callData, callbackSelector, extraData] = args;\n    const { ccipRead } = client;\n    const ccipRequest_ = ccipRead && typeof ccipRead?.request === 'function'\n        ? ccipRead.request\n        : ccipRequest;\n    try {\n        if (!isAddressEqual(to, sender))\n            throw new OffchainLookupSenderMismatchError({ sender, to });\n        const result = await ccipRequest_({ data: callData, sender, urls });\n        const { data: data_ } = await call(client, {\n            blockNumber,\n            blockTag,\n            data: concat([\n                callbackSelector,\n                encodeAbiParameters([{ type: 'bytes' }, { type: 'bytes' }], [result, extraData]),\n            ]),\n            to,\n        });\n        return data_;\n    }\n    catch (err) {\n        throw new OffchainLookupError({\n            callbackSelector,\n            cause: err,\n            data,\n            extraData,\n            sender,\n            urls,\n        });\n    }\n}\nexport async function ccipRequest({ data, sender, urls, }) {\n    let error = new Error('An unknown error occurred.');\n    for (let i = 0; i < urls.length; i++) {\n        const url = urls[i];\n        const method = url.includes('{data}') ? 'GET' : 'POST';\n        const body = method === 'POST' ? { data, sender } : undefined;\n        const headers = method === 'POST' ? { 'Content-Type': 'application/json' } : {};\n        try {\n            const response = await fetch(url.replace('{sender}', sender).replace('{data}', data), {\n                body: JSON.stringify(body),\n                headers,\n                method,\n            });\n            let result;\n            if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n                result = (await response.json()).data;\n            }\n            else {\n                result = (await response.text());\n            }\n            if (!response.ok) {\n                error = new HttpRequestError({\n                    body,\n                    details: result?.error\n                        ? stringify(result.error)\n                        : response.statusText,\n                    headers: response.headers,\n                    status: response.status,\n                    url,\n                });\n                continue;\n            }\n            if (!isHex(result)) {\n                error = new OffchainLookupResponseMalformedError({\n                    result,\n                    url,\n                });\n                continue;\n            }\n            return result;\n        }\n        catch (err) {\n            error = new HttpRequestError({\n                body,\n                details: err.message,\n                url,\n            });\n        }\n    }\n    throw error;\n}\n//# sourceMappingURL=ccip.js.map"],"names":[],"sourceRoot":"","ignoreList":[0,1]}