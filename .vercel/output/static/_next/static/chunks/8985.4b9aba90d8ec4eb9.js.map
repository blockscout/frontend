{"version":3,"file":"static/chunks/8985.4b9aba90d8ec4eb9.js","mappings":"2FASA,cACA,iCACA,8CAA0D,EAAE,EAC5D,CACA,cACA,uBACA,qCAAiD,EAAE,EACnD,CAEA,cACA,gCACA,+DAEA,mBACA,SACA,mCACA,qCACA,6CAAyD,EAAQ,kBAAkB,SAAS,EAC5F,CACA,cACA,qDACA,+DACA,eACA,aACA,CACA,mBACA,eACA,gDACA,iBACA,oDACA,CACA,gBACA,KACA,kBACA,cACA,qEAAiF,EAAI,EAErF,CA7CA,qCAA6C,CAAE,SAAa,EAAC,EAC7D,OAAe,GACf,QAAc,GACd,MAAY,GACZ,OAAa,GACb,MAAY,GACZ,QAAc,GACd,QAAc,GAwCd,SAAe,CADf,CAAiB,8EC9CjB,qCAA6C,CAAE,SAAa,EAAC,EAC7D,KAAa,CAAG,OAAa,CAAG,OAAa,CAAG,OAAa,CAAG,OAAa,CAAG,OAAa,CAAG,QAAc,CAAG,QAAc,CAAG,QAAc,CAAG,QAAc,CAAG,SAAe,CAAG,SAAe,CAAG,QAAc,CAAG,QAAc,CAAG,QAAc,CAAG,QAAc,CAAG,OAAa,CAAG,OAAa,CAAG,OAAa,QACzT,SAAe,GACf,OAAa,GACb,KAAW,GACX,4BACA,aAEA,0BACA,EACA,CAAiB,gCACjB,CAAa,mCACb,CACA,mBACA,gCACA,4BACA,YAAoB,WAAgB,KACpC,MAAgB,OAAO,SACvB,kBACA,CACA,YAEA,4CACA,OAAa,GAEb,qBACA,OAAa,GACb,6BACA,OAAa,GAEb,6BACA,QAAc,GACd,6BACA,QAAc,GAEd,gCACA,QAAc,GACd,gCACA,QAAc,GAEd,eACA,SAAe,GACf,eACA,SAAe,GAEf,4BACA,SAAc,GACd,6BACA,QAAc,GAEd,gCACA,QAAc,GACd,gCAIA,oBACA,sBACA,OAAa,gCACb,CANA,QAAc,GAQd,uCACA,OAAa,GACb,2CACA,OAAa,GACb,iDACA,OAAa,GACb,+CACA,OAAa,GACb,2DACA,OAAa,GACb,mDACA,OAAa,GAUb,SAAe,CARf,CACA,0BACA,gBACA,oCACA,oBACA,oCACA,qDACA,8BCjFA,qCAA6C,CAAE,SAAa,EAAC,EAC7D,MAAc,QACd,QAAc,2GCFd,qCAA6C,CAAE,SAAa,EAAC,EAC7D,QAAgB,CAAG,UAAgB,CAAG,YAAkB,CAAG,YAAkB,CAAG,YAAkB,CAAG,YAAkB,CAAG,UAAgB,CAAG,UAAgB,CAAG,UAAgB,CAAG,UAAgB,CAAG,QAAc,QACpN,SAAe,GACf,MAAqB,EAAQ,KAAc,EAC3C,EAAkB,EAAQ,KAAW,CADT,CAE5B,EAAmB,EAAQ,KAAY,CADd,CAKzB,KACA,KACA,KACA,YACA,YACA,YACA,YACA,cACA,cACA,wBAA2C,KAAY,KAEvD,sBACA,kBAEA,yBAEA,QACA,YAAoB,IAAO,IAC3B,sBACA,GACA,yBAEA,SACA,CACA,2BAEA,wDACA,wDAEA,mBACA,0BAEA,eAAkC,KAAY,KAE9C,YAAwB,KAAQ,IAChC,0CACA,YAAwB,KAAQ,MAChC,eACA,WACA,OACA,SACA,gBACA,kBACA,YAA4B,KAAQ,MACpC,UACA,WAEA,CAEA,WACA,OACA,YAAwB,KAAQ,KAChC,WACA,WACA,WACA,OACA,OACA,SACA,OACA,QACA,CAEA,YAAwB,KAAQ,OAChC,YAA4B,KAAQ,IACpC,YACA,YAA4B,KAAQ,IACpC,iCAGA,WACA,WAEA,SACA,CACA,uBAEA,6BAcA,GAbA,QACA,gBACA,cACA,iBACA,iBACA,cACA,WACA,cACA,iBACA,kBAEA,gBAEA,qCACA,uDACA,gCACA,kCACA,CACA,SACA,QACA,+BACA,4BACA,QACA,+BACA,cACA,UACA,CACA,UACA,mBACA,aAAgB,WAAkB,KAElC,EADA,qBACA,OACA,YAA0B,KAAU,CACpC,+BACA,YAA4B,IAAU,IACtC,sBACA,cACA,aACA,CACA,YAEA,SACA,iBACA,MACA,kBACA,UAAgB,6BAA+B,IAE/C,SACA,qBACA,cACA,YACA,aACA,CACA,aACA,sBACA,eACA,cACA,iBACA,CAAgB,YAAW,KAC3B,uBAA4C,KAAU,KACtD,YACA,cACA,kCACA,+CACA,eACA,IACA,CACA,QACA,CACA,WAEA,mBACA,qDACA,wBACA,CACA,OAEA,MADA,gBACA,+BACA,CACA,cAEA,GADA,qBACA,cACA,2CAGA,OAFA,kBACA,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CA,cAGA,GAFA,OACA,WACA,QACA,2BAEA,OAAS,EAAM,0BACf,EA0BA,oBAzJA,YACA,6BAyJA,qBACA,eAzIA,cAcA,OAbA,KAMA,IAFA,kBAEA,KAEA,GAGA,mBA8HA,uEC3KO,SACP,iBACA,aACA,aACA,CACA,iBACA,iCACA,CACA,cACA,sBACA,6BACA,CACA,aACA,yCACA,CACA,WACA,8CACA,CACA,cACA,0CACA,CACA,QACA,yBACA,KACA,YAAwB,sBAAyB,KACjD,yBACA,sCACA,SAEA,CACA,wCACA,CACA,aACA,UAAmB,WAAW,EAAE,gBAAkB,YAAY,KAAO,GAAG,EAAI,EAE5E,kBACA,wBACA,2BACA,CACA,CCzCO,OACP,KACA,mBACA,wBACA,2BACA,2BACA,0BACA,qBACA,aACA,sBACA,sBACA,qBACA,eACA,CAAK,CACL,UACA,yBACA,kBACA,uBACA,kBACA,uBACA,qBACA,CAAK,EAEE,GACP,UACA,wBACA,+GACA,CAAK,CACL,UACA,wBACA,sDACA,CAAK,CACL,UACA,wBACA,uDACA,CAAK,CACL,UACA,wBACA,sCACA,CAAK,CACL,UACA,wBACA,kCACA,CAAK,CACL,UACA,oBACA,wBACA,CAAK,CACL,UACA,oBACA,6BACA,CAAK,CACL,UACA,oBACA,+BACA,CAAK,CACL,UACA,oBACA,+BACA,CAAK,CACL,UACA,oBACA,+BACA,CAAK,CACL,UACA,oBACA,iCACA,CAAK,CACL,MACA,oBACA,oCACA,CAAK,CACL,MACA,oBACA,kFACA,CAAK,CACL,MACA,oBACA,0EACA,CAAK,CACL,MACA,oBACA,uDACA,CAAK,CACL,MACA,oBACA,gEACA,CAAK,CACL,MACA,oBACA,gCACA,CAAK,EC1FL,+BAMO,kBACP,2BACA,mBACA,KAAmB,EAAW,GAC9B,MAD8B,CACX,CAAW,YAE9B,MA0EA,QA1EA,GA0EA,MAzEA,MAZO,2BAcP,CACA,QACA,CAuEA,qBACA,yCACA,gBAA+B,IAE/B,CACA,CACA,gBACA,gDACA,CACA,gBACA,kECjGO,IAAM,EAAc,CAC3B,KACA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O,SACP,cACA,iBAA2B,EAAkB,0BAC7C,wBACA,uBACA,wBACA,sBACA,CACA,wBAEA,OADA,8BACA,kBAGA,wBAEA,OADA,8BACA,kBAEA,0BACA,uBACA,qBACA,yBACA,6BACA,CACA,cACA,wBACA,uBACA,wBACA,uBACA,sCACA,sCACA,qCACA,CACA,wBACA,YAAiC,GACjC,YADgD,OAChD,cACA,8BACA,oCACA,kCACA,CACA,yBACA,2BACA,2CAEA,0BACA,0CAEA,uDACA,6BAEA,2BACA,2CAEA,0BACA,sDAEA,yBAAsC,EAAkB,uCAExD,CAEA,iBACA,gDACA,EAEe,EAAsB,aADrC,IAEA,CACA,EAFqC,IAErC,cACA,YAAgC,EAAoB,aACpD,oCACA,CACA,CCnFO,cACA,0BCCA,uBACP,oCAAsD,KAAc,qCAAyC,EAC7G,wBACA,cACA,uBACA,YACA,SACA,kCACA,oBAAiC,EACjC,KADwC,gBACN,EAClC,CAAS,CAD6B,EAGtC,CAAY,kBAAgB,eAC5B,KACA,QACA,QACA,CCZA,kBACA,iBACA,qBACA,uBACO,UACP,eACA,SACA,0BACA,iCACA,yBACA,oBAA8B,EAC9B,WAD2C,CAC3C,KAA2B,EAAkB,4BAC7C,sEACA,yCACA,uFACA,EACA,yCACA,qCACA,+DACA,kEACA,CACA,mBACA,QACA,uCACA,WACA,gBACA,uBAAwC,mDAAuE,CAC/G,CAAa,CACJ,EACT,2DAEA,yBACA,wBACA,YAAoC,EAAsB,kBAC1D,EAD0D,KAC1D,oCAEA,OADA,sCACA,OACA,eACA,cACA,cACA,gBACA,+BACA,sEACA,CACA,iBACA,MACA,4BACA,MAAkB,EAAc,wBAEhC,iBACA,0BAEA,OADA,6DAAqG,QAAS,EAAmB,eAAiB,EAAjB,IACjI,cACA,eACA,yBACA,eACA,4BACA,cACA,yBACA,cACA,OAAuB,EAAmB,cAC1C,GAD0C,EAC1C,yBACA,kCACA,kCACA,uCACA,qBACA,oBACA,yBACA,0BACA,0BACA,2BACA,2BACA,2BACA,wBACA,8BACA,wBACA,uBACA,6BACA,8BACA,iCACA,SACA,sBACA,MAA0B,EAAc,yCACxC,OAAuB,GAAe,oBACtC,CACA,CACA,4BACA,OAGA,0FACA,yCAEA,EADA,uCACA,OACA,eACA,cACA,eAEA,gBACA,QACA,qBACA,8BACA,iBACA,YACA,0FACA,CACA,CAKA,kCACA,MACA,eACA,uDACA,MAAkB,EAAc,oBAEhC,MAAwB,EAAe,cAEvC,GADA,oBAEA,YACA,uCAIA,OAHA,UACA,oBAEA,CACA,CACA,8BACA,8CACA,MACA,MAAkB,EAAc,0FAEhC,YAAgC,EAAc,CAC9C,SACA,EAF8C,MAE9C,cACS,IACT,6CAA0D,EAAW,EACrE,yDACA,CACA,8BACA,YAAgC,EAAoB,kDACpD,OACA,uBACA,SACA,UACA,kBACA,CACA,CACA,gCACA,QACA,gBAEA,iBACA,gBAEA,8CACA,MACA,MAAkB,EAAc,yCAEhC,YAA+B,EAAc,eAC7C,gDACA,MACA,uCACA,aACA,QACA,EAAa,EACb,+BACA,iCACA,CACA,0DAIA,OAHA,GACA,+BAEA,CACA,CACA,iBACA,MACA,4CACA,2CACA,MAEA,iBACA,aACA,+BACA,iEAAoG,EAAmB,QAEvH,GACA,CACA,KAJuH,YC7LhH,mBCAA,eACP,+BCAO,SAEP,eACA,aACA,CAQA,iBACA,kBACA,iBACA,uCACA,iDACA,sCAA+D,EAAqB,IAAY,eAAiB,2BACjH,kBAEA,sCACA,eACA,IACA,CAAS,gBAET,uBADA,IAEA,yBAFA,IAGA,oBACA,oBAEA,OAAe,EADf,aAC8B,EAD9B,kBAEA,CAMA,iBACA,kBACA,iBACA,uCACA,4BACA,iBACA,0CAAuE,EAAqB,IAAY,eAAZ,CAA6B,0BACzH,EAAkC,EAAqB,GACvD,gBACA,iBAEA,qBADA,eACA,IACA,GACA,eACA,oBACA,EACA,IACA,gDACA,kBACA,cACA,CACA,SACA,IACA,CACA,CAAa,EACb,CAAS,CACT,CACA,CClEO,SACP,mBACA,kBACA,iBACA,SAA+B,EAAU,GAAG,EAAW,EACvD,mBAA6B,QAAkB,EAG/C,gCACA,qCAAsD,gBAAgB,UAAU,UAAU,QAC1F,cACA,SACA,wBACa,CACJ,iEACT,CACA,0BACA,MACA,qBAAwC,gBAAgB,sBACxD,SACA,wBACa,CACJ,EACT,SACA,WAAoB,WAAgB,eACpC,KACA,2CAA+D,EAAM,GAErE,MAMa,OANb,iEACA,aACA,yBACA,aACA,cACA,YACA,EAAa,mBAEb,OADA,+BACA,CACA,CACA,2CAAuD,SAAgB,EACvE,CACA,ECtCA,YACA,mCACA,+BACA,4BACA,CAAC,YAA0C,CACpC,UACP,8BACA,8BACA,CACA,2BACA,2BACA,CAMA,2BACA,sBACA,oBACA,oBACA,gCACA,CAKA,gBACA,kBACA,4CAEA,+BACA,MACA,EACA,IACA,kDACA,CACA,SACA,KACA,MACA,CACA,gFACA,cACA,MACA,sBACA,2BAAoD,OAAS,IAAI,SAAW,IAC5E,iFACA,EACA,aACA,MACA,IACA,+EACA,4BAEA,IADA,kBACA,6BACA,oBAEA,EACA,gBACA,QACA,gBACA,+DACA,gBACA,CAAqB,OAGrB,IACA,wBACA,iEACA,CACA,SAEA,CAEA,CACA,CAAS,CACT,CAIA,aACA,MACA,cAAgB,GAAY,KAC5B,MAGA,sBACA,kFACA,oCACA,iCACA,IACA,SACA,CACA,SAEA,EACA,CAKA,YACA,cAAgB,GAAY,KAC5B,OACA,yBACA,eACA,MACA,CACA,SACA,CACA,iBACA,cAAgB,GAAY,KAC5B,IAGA,oBACA,eACA,eACA,iBACA,cACA,CACA,CChHO,SAQP,aAAkB,kCAA+B,EACjD,kBACA,6BACA,eAAyB,EAAS,GAKlC,SALkC,MAKlC,IAKA,gBACA,yCACA,gCACA,sCACA,GAGA,SACA,qCACA,8CACA,oDACA,4CACA,CACA,UACA,yDACA,CACA,EAEA,gBACA,gBACA,OAEA,IACA,CAAa,CACb,EACA,yBACA,KACA,UAEA,0DACA,EACA,oCACA,MACA,kCACA,0DACA,EACA,wCACA,MACA,kCACA,6DACA,EACA,2CACA,2BAAuC,iBAAoB,EAC3D,CAD2D,CAE3D,uCACA,2BAAuC,aAAe,IAEtD,qCACA,MACA,mCACA,8BACA,0DACA,EACA,eACA,gBAA0B,GAAgB,UAC1C,GAD0C,CAC1C,YACA,UAAuB,GAAmB,GAAI,EAAW,WAAf,MAC1C,uCAEA,SACA,UACA,KAAqB,GAAe,aAEpC,oBACA,gBAEA,wCAEA,gBAEA,uBACA,GACA,CAAiC,CAEjC,EACA,GACA,CACA,KACA,MAAqB,GAAe,UAGpC,+BAKA,2BACA,iBACA,gBACA,CAAqB,CAnHrB,KAqHA,uCACA,2BAGA,MAAqB,GAAe,WAEpC,CAEA,oBACA,kBAEA,CAAS,EACT,8BACA,MACA,eAEA,gBACA,2BACA,MAEA,kBACA,cACA,2CACA,iCACA,KACA,CAEA,yBACA,2BACA,8CACA,KAEA,aACA,2BAGA,CAEA,eACA,gEAEA,CAAS,EACT,UACA,cAAwB,GAAc,aACtC,CAIA,UACA,kBACA,qCAEA,iBACA,CAKA,gBACA,iBAEA,wBACA,wBACA,GAAgB,EAAS,kBACzB,0BACA,UAAwB,gBAAkB,CACjC,EAAI,YAAe,EAC5B,kBACA,qBACA,qBACA,CACA,gBACA,uBAEA,iBACA,iBACA,CACA,aACA,oBAEA,cACA,OACA,gBACA,GACA,uDACA,wDACA,CACA,iBACA,uBACA,YACA,YAGA,qBACA,YACA,sBACA,CAEA,CAAS,CACT,CACA,6BACA,MACA,8CACA,OAGA,iBADA,mCAEA,4BACA,OACA,IAAgB,iBAAe,CAC/B,uEACA,CACA,0BACA,oBACA,yCACA,MACA,CACA,wCACA,IACA,iCACA,CACA,SACA,oDACA,CACA,CACA,6BACA,yCACA,sCACA,uCACA,CAQA,6BACA,6EAA4F,KAAsB,sGAClH,eACA,MAAyB,IACzB,GACA,oBACA,GAAgB,EAAS,kBACzB,0BACA,QACA,OACA,aACA,EACA,oCACA,gCACA,mBACA,gDAEA,iBACS,CACT,CACA,YACA,mCACA,CACA,sBACA,qCACA,CACA,YACA,8CACA,qBACA,MACA,CACA,IACA,qBACA,CACA,SAEA,CACA,CACA,uBAA2C,QAnS3C,GAmS2C,CAA0B,MAIrE,EAHA,WAIA,OAHA,iBAGA,cACA,oBACA,yBACA,mBAAgD,GAA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1E,CAAC,SAAU,MAAO,WAAI,+BALlC,iBAKkC,CAAwC,CAC1D,CAAC,cACD,CAAC,YAAa,UAAwB,OC1C/C,+BCEA,UACP,cACA,iBACA,wBAAkC,EAClC,CACA,SACA,EAHgD,CAGhD,cACA,0DAEA,6BACA,gBACA,CACA,4BACA,cDdO,uBCc4C,WACnD,qCXGO,WACP,IACA,cATA,IACA,kCAEA,SACA,QACA,CACA,KAGA,WACA,2BAEA,uBAEA,SACA,uBAEA,IWb2D,MAC3D,GACA,kCAEA,iCACA,uBACA,cACA,4BACA,SACA,CACA,8BACA,6BACA,0CACA,kBACA,mBACA,gCACA,CAAa,CACJ,EACT,gBACA,gCACA,CAAS,IACT,CACA,kBAEA,WACA,2BACA,CACA,CACA,CCjCO,SACP,eACA,0BAAqC,0BACrC,CADoE,GACpE,aAA2B,WZiB3B,MACA,2JACA,IYlBA,uBACA,gBACA,2BAAyD,IAMzD,GALA,GAEA,iBAHoF,IAGpF,IAEA,6BACA,GACA,mBACA,sDACA,yCACA,8BAEA,CACA,EACA,6BACA,yBACA,EACA,0BACA,uCACA,2CAGA,0BACA,UACA,YACA,EACA,oBACA,4CAEA,EACA,wBACA,uBACA,2BAEA,sCAIA,8DACA,uBACA,iCACA,WACqB,CACrB,CAAiB,EACjB,qCAEA,EACA,mDACA,6BACA,uBACA,yBACA,yCACA,mCACA,YAAgB,qBAA0B,gBAC1C,iBACA,kBACA,2BAAqC,GACrC,UACA,gBACA,CACA,YACA,MAAwB,GAAiB,oBAAuB,GAAiB,qBACjF,YAAgB,GAAa,KAC7B,MAA+B,GAAoB,CACnD,UACA,MAFmD,KAEnD,EACA,cACS,EACT,uBAA0C,GAAe,IAAS,GAElE,KAFyD,EACzD,OADmF,EACnF,GACA,SAAiB,oBACjB,CACA,iBACA,gBACA,UACA,UASA,MAAkC,GAAiB,mBACnD,0CACgB,EAAkB,WAElC,KAFkC,IAElC,iBACA,CAAS,EACT,WAA6B,CAC7B,CACA,2BACA,yBACA,iCACA,QACA,0BACA,sBACA,SAA0B,EAAsB,YAChD,KAAsB,EAAmB,CADO,CACP,SACzC,MADyC,EACzC,MACA,8BAAsD,EAAsB,sBAC5E,6BAAqD,EAAsB,sBAC3E,qCACsB,EAAsB,iBAC5C,GAD4C,EAE5C,oBAA4C,EAAsB,iBAClE,GADkE,KAClE,UACA,eACA,CAAa,CACJ,CACT,CACA,oCACA,yBACA,iCACA,QACA,0BACA,sBACA,SAA0B,EAAsB,YAChD,KAAsB,EAAmB,CADO,CACP,SACzC,MADyC,EACzC,MACA,8BAAsD,EAAsB,sBAC5E,4BAAoD,EAAsB,qBAC1E,4CACsB,EAAsB,wBAC5C,KACA,oBAA4C,EAAsB,iBAClE,GADkE,KAClE,UACA,eACA,CAAa,CACJ,CACT,CACA,+BACA,yBACA,mCACA,QACA,kBAAmC,EAAmB,MACtD,SACA,CAAa,CAFyC,CAItD,CACA,uBACA,qBAEA,eACA,WACA,EAAmB,EAAc,GACjC,MACA,GAFiC,CAEjC,oCACA,uCACA,YACA,EACA,2BAEA,0BACA,+CACA,WACA,sCACiB,EAEjB,2CAEA,GADA,aACoB,GAAe,GACnC,SADmC,MACnC,iBAEA,IACA,CAAa,EACb,iCACA,CAAS,CACT,CACA,6BACA,OAA0B,oCAC1B,sCACA,UAA4B,EAC5B,UACA,qCACA,gBACA,uBACa,CACb,CAAS,EACT,kBACA,yCAEA,CAEA,8BACA,sBAAiC,GAGjC,UACA,EAJgD,EAIhD,0BACA,0BACA,MACA,SACA,oCACA,qCACA,mCACA,CAAqB,EAAI,QAAY,CACrC,CAAiB,EAAI,QAAY,EACjC,oCAEA,CACA,CACA,mCAKA,wCAJA,CACA,6BACA,IACA,EACA,UACA,CACA,oBACA,0CACA,CACA,+BACA,yCACA,kEACA,qCACA,MACA,CACA,wBACA,CACA,2BACA,MACA,qFACA,kCACA,SACA,cACA,CAAS,CACT,CACA,oBACA,8CACA,IACA,KACA,2CAEA,CACA,0BACA,YAAgB,gBAAsB,cACtC,GACA,iCACA,QACA,UACA,YACA,CAAa,EAGb,EAAmB,EAAc,GACjC,SADiC,EACjC,gBACA,2CAIA,GAAoB,GAAe,GACnC,SADmC,MACnC,iBAEA,IACA,CAAa,EACb,oCACA,iCACA,CAAS,CACT,CACA,wBACA,OACA,oBACA,QACA,OACA,SACA,UACA,SACA,WACA,OACA,CAAiB,CACjB,SACA,CAAa,EAEb,OACA,EAAmB,EAAc,GAajC,OANA,EAPiC,IAOjC,oBACA,+CACA,SARA,IACA,wCACA,uCACA,YACA,EAKA,sCACa,EAEb,oBACA,2CAEA,GADA,aACoB,GAAe,GACnC,gCAEA,IACA,CAAa,EACb,iCACA,CAAS,CACT,CACA,8BACA,OACA,0BACA,QACA,UACA,UACA,oBACA,YACA,WACA,gBACA,CAAa,EAEb,OACA,EAAmB,EAAc,GAajC,OANA,EAPiC,IAOjC,oBACA,+CACA,SARA,IACA,wCACA,uCACA,YACA,EAKA,sCACa,EAEb,oBACA,2CAEA,GADA,aACoB,GAAe,GACnC,SADmC,MACnC,iBAEA,IACA,CAAa,EACb,iCACA,CAAS,CACT,CACA,yBACA,OACA,6BACA,8BAAoC,EAAS,UAAI,EAAS,CAC1D,EACA,OACA,EAAmB,EAAc,GAajC,OANA,EAPiC,IAOjC,oBACA,+CACA,SARA,IACA,wCACA,uCACA,YACA,EAKA,sCACa,EAEb,oBACA,0CAEA,CADA,aACoB,GAAe,iBACnC,EAAkC,EAAc,iBAChD,EADgD,GAChD,YACA,mFACA,CAAqB,GAEI,GAAe,GACxC,SADwC,CACxC,oBAEA,MAEA,iCACA,CAAS,CACT,CACA,CACA,4DC5XA,wBACA,sBAEO,UACP,eACA,iBACA,mBACA,yBACA,kBAA4B,EAAkB,aAAe,GAAf,CAC9C,UAD2E,GAC3E,kBACA,4BAAsD,IACtD,MACA,iBAFiF,CAGjF,YACA,0BAA6D,EAAmB,IAEhF,CACA,YAHgF,QAGhF,EACA,CACA,aAEA,OAAgB,YADhB,uBAC6B,uBAC7B,UAAiB,WACjB,CACA,kBACA,iCACA,CACA,sBACA,iCACA,CACA,iBACA,MACA,gEACA,CACA,kBACA,2BACA,CACA,wBACA,KACA,mBAEA,wBACA,yCAC6B,EAAe,QAE5C,KAF4C,GAE5C,0DAAoG,EAAmB,IAEvH,CA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","sources":["webpack://_N_E/./node_modules/@noble/hashes/_assert.js","webpack://_N_E/./node_modules/@noble/hashes/_u64.js","webpack://_N_E/./node_modules/@noble/hashes/crypto.js","webpack://_N_E/./node_modules/@noble/hashes/sha3.js","webpack://_N_E/./node_modules/@noble/hashes/utils.js","webpack://_N_E/./node_modules/clsx/dist/clsx.m.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/abi.cjs","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/index.cjs","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/util.cjs","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/core/storage/ScopedLocalStorage.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/core/error/constants.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/core/error/utils.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/core/error/errors.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/core/type/index.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/core/type/util.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/util/cipher.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/scw/SCWKeyManager.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sdk-info.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/util/provider.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/scw/SCWSigner.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/constants.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/type/Web3Response.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/connection/WalletLinkCipher.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/connection/WalletLinkHTTP.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/connection/WalletLinkWebSocket.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/connection/WalletLinkConnection.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/RelayEventManager.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/type/WalletLinkSession.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/util.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/cssReset/cssReset-css.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/cssReset/cssReset.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/node_modules/preact/dist/preact.module.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/node_modules/preact/hooks/dist/hooks.module.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/Snackbar/Snackbar-css.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/Snackbar/Snackbar.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/WalletLinkRelayUI.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/RedirectDialog/RedirectDialog-css.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/RedirectDialog/RedirectDialog.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/core/constants.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/WLMobileRelayUI.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/WalletLinkRelay.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/WalletLinkSigner.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/sign/util.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/util/checkCrossOriginOpenerPolicy.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/util/web.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/core/communicator/Communicator.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/core/error/serialize.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/core/provider/interface.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/CoinbaseWalletProvider.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/createCoinbaseWalletProvider.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/util/validatePreferences.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/createCoinbaseWalletSDK.js","webpack://_N_E/./node_modules/@coinbase/wallet-sdk/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isBytes = isBytes;\nexports.number = number;\nexports.bool = bool;\nexports.bytes = bytes;\nexports.hash = hash;\nexports.exists = exists;\nexports.output = output;\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nconst assert = { number, bool, bytes, hash, exists, output };\nexports.default = assert;\n//# sourceMappingURL=_assert.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = void 0;\nexports.fromBig = fromBig;\nexports.split = split;\nexports.add = add;\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nexports.shrSH = shrSH;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.shrSL = shrSL;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nexports.rotrSH = rotrSH;\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.rotrSL = rotrSL;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nexports.rotrBH = rotrBH;\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\nexports.rotrBL = rotrBL;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nexports.rotr32H = rotr32H;\nconst rotr32L = (h, _l) => h;\nexports.rotr32L = rotr32L;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nexports.rotlSH = rotlSH;\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\nexports.rotlSL = rotlSL;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nexports.rotlBH = rotlBH;\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\nexports.rotlBL = rotlBL;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nexports.add3L = add3L;\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nexports.add3H = add3H;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nexports.add4L = add4L;\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nexports.add4H = add4H;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nexports.add5L = add5L;\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\nexports.add5H = add5H;\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexports.default = u64;\n//# sourceMappingURL=_u64.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.crypto = void 0;\nexports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;\nexports.keccakP = keccakP;\nconst _assert_js_1 = require(\"./_assert.js\");\nconst _u64_js_1 = require(\"./_u64.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nclass Keccak extends utils_js_1.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0, _assert_js_1.number)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = (0, utils_js_1.u32)(this.state);\n    }\n    keccak() {\n        if (!utils_js_1.isLE)\n            (0, utils_js_1.byteSwap32)(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!utils_js_1.isLE)\n            (0, utils_js_1.byteSwap32)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0, _assert_js_1.exists)(this);\n        const { blockLen, state } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0, _assert_js_1.exists)(this, false);\n        (0, _assert_js_1.bytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0, _assert_js_1.number)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0, _assert_js_1.output)(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nexports.Keccak = Keccak;\nconst gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));\nexports.sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexports.sha3_256 = gen(0x06, 136, 256 / 8);\nexports.sha3_384 = gen(0x06, 104, 384 / 8);\nexports.sha3_512 = gen(0x06, 72, 512 / 8);\nexports.keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexports.keccak_256 = gen(0x01, 136, 256 / 8);\nexports.keccak_384 = gen(0x01, 104, 384 / 8);\nexports.keccak_512 = gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nexports.shake128 = genShake(0x1f, 168, 128 / 8);\nexports.shake256 = genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map","\"use strict\";\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Hash = exports.nextTick = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\nexports.isBytes = isBytes;\nexports.byteSwap32 = byteSwap32;\nexports.bytesToHex = bytesToHex;\nexports.hexToBytes = hexToBytes;\nexports.asyncLoop = asyncLoop;\nexports.utf8ToBytes = utf8ToBytes;\nexports.toBytes = toBytes;\nexports.concatBytes = concatBytes;\nexports.checkOpts = checkOpts;\nexports.wrapConstructor = wrapConstructor;\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\nexports.randomBytes = randomBytes;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nconst crypto_1 = require(\"@noble/hashes/crypto\");\nconst _assert_js_1 = require(\"./_assert.js\");\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexports.rotr = rotr;\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nexports.rotl = rotl;\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\nexports.byteSwap = byteSwap;\n// Conditionally byte swap if on a big-endian platform\nexports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = (0, exports.byteSwap)(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0, _assert_js_1.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    (0, _assert_js_1.bytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0, _assert_js_1.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {\n        return crypto_1.crypto.randomBytes(bytesLength);\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f);else for(t in e)e[t]&&(n&&(n+=\" \"),n+=t);return n}export function clsx(){for(var e,t,f=0,n=\"\";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;","// Extracted from https://github.com/ethereumjs/ethereumjs-abi and stripped out irrelevant code\n// Original code licensed under the MIT License - Copyright (c) 2015 Alex Beregszaszi\n\n/* eslint-disable */\n//prettier-ignore\nconst util = require('./util.cjs')\n\n// Convert from short to canonical names\n// FIXME: optimise or make this nicer?\nfunction elementaryName (name) {\n  if (name.startsWith('int[')) {\n    return 'int256' + name.slice(3)\n  } else if (name === 'int') {\n    return 'int256'\n  } else if (name.startsWith('uint[')) {\n    return 'uint256' + name.slice(4)\n  } else if (name === 'uint') {\n    return 'uint256'\n  } else if (name.startsWith('fixed[')) {\n    return 'fixed128x128' + name.slice(5)\n  } else if (name === 'fixed') {\n    return 'fixed128x128'\n  } else if (name.startsWith('ufixed[')) {\n    return 'ufixed128x128' + name.slice(6)\n  } else if (name === 'ufixed') {\n    return 'ufixed128x128'\n  }\n  return name\n}\n\n// Parse N from type<N>\nfunction parseTypeN (type) {\n  return Number.parseInt(/^\\D+(\\d+)$/.exec(type)[1], 10)\n}\n\n// Parse N,M from type<N>x<M>\nfunction parseTypeNxM (type) {\n  var tmp = /^\\D+(\\d+)x(\\d+)$/.exec(type)\n  return [ Number.parseInt(tmp[1], 10), Number.parseInt(tmp[2], 10) ]\n}\n\n// Parse N in type[<N>] where \"type\" can itself be an array type.\nfunction parseTypeArray (type) {\n  var tmp = type.match(/(.*)\\[(.*?)\\]$/)\n  if (tmp) {\n    return tmp[2] === '' ? 'dynamic' : Number.parseInt(tmp[2], 10)\n  }\n  return null\n}\n\nfunction parseNumber (arg) {\n  var type = typeof arg\n  if (type === 'string' || type === 'number') {\n    return BigInt(arg)\n  } else if (type === 'bigint') {\n    return arg\n  } else {\n    throw new Error('Argument is not a number')\n  }\n}\n\n// Encodes a single item (can be dynamic array)\n// @returns: Buffer\nfunction encodeSingle (type, arg) {\n  var size, num, ret, i\n\n  if (type === 'address') {\n    return encodeSingle('uint160', parseNumber(arg))\n  } else if (type === 'bool') {\n    return encodeSingle('uint8', arg ? 1 : 0)\n  } else if (type === 'string') {\n    return encodeSingle('bytes', new Buffer(arg, 'utf8'))\n  } else if (isArray(type)) {\n    // this part handles fixed-length ([2]) and variable length ([]) arrays\n    // NOTE: we catch here all calls to arrays, that simplifies the rest\n    if (typeof arg.length === 'undefined') {\n      throw new Error('Not an array?')\n    }\n    size = parseTypeArray(type)\n    if (size !== 'dynamic' && size !== 0 && arg.length > size) {\n      throw new Error('Elements exceed array size: ' + size)\n    }\n    ret = []\n    type = type.slice(0, type.lastIndexOf('['))\n    if (typeof arg === 'string') {\n      arg = JSON.parse(arg)\n    }\n    for (i in arg) {\n      ret.push(encodeSingle(type, arg[i]))\n    }\n    if (size === 'dynamic') {\n      var length = encodeSingle('uint256', arg.length)\n      ret.unshift(length)\n    }\n    return Buffer.concat(ret)\n  } else if (type === 'bytes') {\n    arg = new Buffer(arg)\n\n    ret = Buffer.concat([ encodeSingle('uint256', arg.length), arg ])\n\n    if ((arg.length % 32) !== 0) {\n      ret = Buffer.concat([ ret, util.zeros(32 - (arg.length % 32)) ])\n    }\n\n    return ret\n  } else if (type.startsWith('bytes')) {\n    size = parseTypeN(type)\n    if (size < 1 || size > 32) {\n      throw new Error('Invalid bytes<N> width: ' + size)\n    }\n\n    return util.setLengthRight(arg, 32)\n  } else if (type.startsWith('uint')) {\n    size = parseTypeN(type)\n    if ((size % 8) || (size < 8) || (size > 256)) {\n      throw new Error('Invalid uint<N> width: ' + size)\n    }\n\n    num = parseNumber(arg)\n    const bitLength = util.bitLengthFromBigInt(num)\n    if (bitLength > size) {\n      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + bitLength)\n    }\n\n    if (num < 0) {\n      throw new Error('Supplied uint is negative')\n    }\n\n    return util.bufferBEFromBigInt(num, 32);\n  } else if (type.startsWith('int')) {\n    size = parseTypeN(type)\n    if ((size % 8) || (size < 8) || (size > 256)) {\n      throw new Error('Invalid int<N> width: ' + size)\n    }\n\n    num = parseNumber(arg)\n    const bitLength = util.bitLengthFromBigInt(num)\n    if (bitLength > size) {\n      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + bitLength)\n    }\n\n    const twos = util.twosFromBigInt(num, 256);\n\n    return util.bufferBEFromBigInt(twos, 32);\n  } else if (type.startsWith('ufixed')) {\n    size = parseTypeNxM(type)\n\n    num = parseNumber(arg)\n\n    if (num < 0) {\n      throw new Error('Supplied ufixed is negative')\n    }\n\n    return encodeSingle('uint256', num * BigInt(2) ** BigInt(size[1]))\n  } else if (type.startsWith('fixed')) {\n    size = parseTypeNxM(type)\n\n    return encodeSingle('int256', parseNumber(arg) * BigInt(2) ** BigInt(size[1]))\n  }\n\n  throw new Error('Unsupported or invalid type: ' + type)\n}\n\n// Is a type dynamic?\nfunction isDynamic (type) {\n  // FIXME: handle all types? I don't think anything is missing now\n  return (type === 'string') || (type === 'bytes') || (parseTypeArray(type) === 'dynamic')\n}\n\n// Is a type an array?\nfunction isArray (type) {\n  return type.lastIndexOf(']') === type.length - 1\n}\n\n// Encode a method/event with arguments\n// @types an array of string type names\n// @args  an array of the appropriate values\nfunction rawEncode (types, values) {\n  var output = []\n  var data = []\n\n  var headLength = 32 * types.length\n\n  for (var i in types) {\n    var type = elementaryName(types[i])\n    var value = values[i]\n    var cur = encodeSingle(type, value)\n\n    // Use the head/tail method for storing dynamic data\n    if (isDynamic(type)) {\n      output.push(encodeSingle('uint256', headLength))\n      data.push(cur)\n      headLength += cur.length\n    } else {\n      output.push(cur)\n    }\n  }\n\n  return Buffer.concat(output.concat(data))\n}\n\nfunction solidityPack (types, values) {\n  if (types.length !== values.length) {\n    throw new Error('Number of types are not matching the values')\n  }\n\n  var size, num\n  var ret = []\n\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i])\n    var value = values[i]\n\n    if (type === 'bytes') {\n      ret.push(value)\n    } else if (type === 'string') {\n      ret.push(new Buffer(value, 'utf8'))\n    } else if (type === 'bool') {\n      ret.push(new Buffer(value ? '01' : '00', 'hex'))\n    } else if (type === 'address') {\n      ret.push(util.setLength(value, 20))\n    } else if (type.startsWith('bytes')) {\n      size = parseTypeN(type)\n      if (size < 1 || size > 32) {\n        throw new Error('Invalid bytes<N> width: ' + size)\n      }\n\n      ret.push(util.setLengthRight(value, size))\n    } else if (type.startsWith('uint')) {\n      size = parseTypeN(type)\n      if ((size % 8) || (size < 8) || (size > 256)) {\n        throw new Error('Invalid uint<N> width: ' + size)\n      }\n\n      num = parseNumber(value)\n      const bitLength = util.bitLengthFromBigInt(num)\n      if (bitLength > size) {\n        throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + bitLength)\n      }\n\n      ret.push(util.bufferBEFromBigInt(num, size / 8))\n    } else if (type.startsWith('int')) {\n      size = parseTypeN(type)\n      if ((size % 8) || (size < 8) || (size > 256)) {\n        throw new Error('Invalid int<N> width: ' + size)\n      }\n\n      num = parseNumber(value)\n      const bitLength = util.bitLengthFromBigInt(num)\n      if (bitLength > size) {\n        throw new Error('Supplied int exceeds width: ' + size + ' vs ' + bitLength)\n      }\n\n      const twos = util.twosFromBigInt(num, size);\n      ret.push(util.bufferBEFromBigInt(twos, size / 8))\n    } else {\n      // FIXME: support all other types\n      throw new Error('Unsupported or invalid type: ' + type)\n    }\n  }\n\n  return Buffer.concat(ret)\n}\n\nfunction soliditySHA3 (types, values) {\n  return util.keccak(solidityPack(types, values))\n}\n\nmodule.exports = {\n  rawEncode,\n  solidityPack,\n  soliditySHA3\n}\n","/* eslint-disable */\n//prettier-ignore\n\nconst util = require('./util.cjs')\nconst abi = require('./abi.cjs')\n\nconst TYPED_MESSAGE_SCHEMA = {\n  type: 'object',\n  properties: {\n    types: {\n      type: 'object',\n      additionalProperties: {\n        type: 'array',\n        items: {\n          type: 'object',\n          properties: {\n            name: {type: 'string'},\n            type: {type: 'string'},\n          },\n          required: ['name', 'type'],\n        },\n      },\n    },\n    primaryType: {type: 'string'},\n    domain: {type: 'object'},\n    message: {type: 'object'},\n  },\n  required: ['types', 'primaryType', 'domain', 'message'],\n}\n\n/**\n * A collection of utility functions used for signing typed data\n */\nconst TypedDataUtils = {\n  /**\n   * Encodes an object by encoding and concatenating each of its members\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of an object\n   */\n  encodeData (primaryType, data, types, useV4 = true) {\n    const encodedTypes = ['bytes32']\n    const encodedValues = [this.hashType(primaryType, types)]\n\n    if(useV4) {\n      const encodeField = (name, type, value) => {\n        if (types[type] !== undefined) {\n          return ['bytes32', value == null ?\n            '0x0000000000000000000000000000000000000000000000000000000000000000' :\n            util.keccak(this.encodeData(type, value, types, useV4))]\n        }\n\n        if(value === undefined)\n          throw new Error(`missing value for field ${name} of type ${type}`)\n\n        if (type === 'bytes') {\n          return ['bytes32', util.keccak(value)]\n        }\n\n        if (type === 'string') {\n          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n          if (typeof value === 'string') {\n            value = Buffer.from(value, 'utf8')\n          }\n          return ['bytes32', util.keccak(value)]\n        }\n\n        if (type.lastIndexOf(']') === type.length - 1) {\n          const parsedType = type.slice(0, type.lastIndexOf('['))\n          const typeValuePairs = value.map(item =>\n            encodeField(name, parsedType, item))\n          return ['bytes32', util.keccak(abi.rawEncode(\n            typeValuePairs.map(([type]) => type),\n            typeValuePairs.map(([, value]) => value),\n          ))]\n        }\n\n        return [type, value]\n      }\n\n      for (const field of types[primaryType]) {\n        const [type, value] = encodeField(field.name, field.type, data[field.name])\n        encodedTypes.push(type)\n        encodedValues.push(value)\n      }\n    } else {\n      for (const field of types[primaryType]) {\n        let value = data[field.name]\n        if (value !== undefined) {\n          if (field.type === 'bytes') {\n            encodedTypes.push('bytes32')\n            value = util.keccak(value)\n            encodedValues.push(value)\n          } else if (field.type === 'string') {\n            encodedTypes.push('bytes32')\n            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n            if (typeof value === 'string') {\n              value = Buffer.from(value, 'utf8')\n            }\n            value = util.keccak(value)\n            encodedValues.push(value)\n          } else if (types[field.type] !== undefined) {\n            encodedTypes.push('bytes32')\n            value = util.keccak(this.encodeData(field.type, value, types, useV4))\n            encodedValues.push(value)\n          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n            throw new Error('Arrays currently unimplemented in encodeData')\n          } else {\n            encodedTypes.push(field.type)\n            encodedValues.push(value)\n          }\n        }\n      }\n    }\n\n    return abi.rawEncode(encodedTypes, encodedValues)\n  },\n\n  /**\n   * Encodes the type of an object by encoding a comma delimited list of its members\n   *\n   * @param {string} primaryType - Root type to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of the type of an object\n   */\n  encodeType (primaryType, types) {\n    let result = ''\n    let deps = this.findTypeDependencies(primaryType, types).filter(dep => dep !== primaryType)\n    deps = [primaryType].concat(deps.sort())\n    for (const type of deps) {\n      const children = types[type]\n      if (!children) {\n        throw new Error('No type definition specified: ' + type)\n      }\n      result += type + '(' + types[type].map(({ name, type }) => type + ' ' + name).join(',') + ')'\n    }\n    return result\n  },\n\n  /**\n   * Finds all types within a type definition object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} types - Type definitions\n   * @param {Array} results - current set of accumulated types\n   * @returns {Array} - Set of all types found in the type definition\n   */\n  findTypeDependencies (primaryType, types, results = []) {\n    primaryType = primaryType.match(/^\\w*/)[0]\n    if (results.includes(primaryType) || types[primaryType] === undefined) { return results }\n    results.push(primaryType)\n    for (const field of types[primaryType]) {\n      for (const dep of this.findTypeDependencies(field.type, types, results)) {\n        !results.includes(dep) && results.push(dep)\n      }\n    }\n    return results\n  },\n\n  /**\n   * Hashes an object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to hash\n   * @param {Object} types - Type definitions\n   * @returns {Buffer} - Hash of an object\n   */\n  hashStruct (primaryType, data, types, useV4 = true) {\n    return util.keccak(this.encodeData(primaryType, data, types, useV4))\n  },\n\n  /**\n   * Hashes the type of an object\n   *\n   * @param {string} primaryType - Root type to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashType (primaryType, types) {\n    return util.keccak(this.encodeType(primaryType, types))\n  },\n\n  /**\n   * Removes properties from a message object that are not defined per EIP-712\n   *\n   * @param {Object} data - typed message object\n   * @returns {Object} - typed message object with only allowed fields\n   */\n  sanitizeData (data) {\n    const sanitizedData = {}\n    for (const key in TYPED_MESSAGE_SCHEMA.properties) {\n      data[key] && (sanitizedData[key] = data[key])\n    }\n    if (sanitizedData.types) {\n      sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types)\n    }\n    return sanitizedData\n  },\n\n  /**\n   * Returns the hash of a typed message as per EIP-712 for signing\n   *\n   * @param {Object} typedData - Types message data to sign\n   * @returns {string} - sha3 hash for signing\n   */\n  hash (typedData, useV4 = true) {\n    const sanitizedData = this.sanitizeData(typedData)\n    const parts = [Buffer.from('1901', 'hex')]\n    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4))\n    if (sanitizedData.primaryType !== 'EIP712Domain') {\n      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4))\n    }\n    return util.keccak(Buffer.concat(parts))\n  },\n}\n\nmodule.exports = {\n  TYPED_MESSAGE_SCHEMA,\n  TypedDataUtils,\n\n  hashForSignTypedDataLegacy: function (msgParams) {\n    return typedSignatureHashLegacy(msgParams.data)\n  },\n\n  hashForSignTypedData_v3: function (msgParams) {\n    return TypedDataUtils.hash(msgParams.data, false)\n  },\n\n  hashForSignTypedData_v4: function (msgParams) {\n    return TypedDataUtils.hash(msgParams.data)\n  },\n}\n\n/**\n * @param typedData - Array of data along with types, as per EIP712.\n * @returns Buffer\n */\nfunction typedSignatureHashLegacy(typedData) {\n  const error = new Error('Expect argument to be non-empty array')\n  if (typeof typedData !== 'object' || !typedData.length) throw error\n\n  const data = typedData.map(function (e) {\n    return e.type === 'bytes' ? util.toBuffer(e.value) : e.value\n  })\n  const types = typedData.map(function (e) { return e.type })\n  const schema = typedData.map(function (e) {\n    if (!e.name) throw error\n    return e.type + ' ' + e.name\n  })\n\n  return abi.soliditySHA3(\n    ['bytes32', 'bytes32'],\n    [\n      abi.soliditySHA3(new Array(typedData.length).fill('string'), schema),\n      abi.soliditySHA3(types, data)\n    ]\n  )\n}","// Extracted from https://github.com/ethereumjs/ethereumjs-util and stripped out irrelevant code\n// Original code licensed under the Mozilla Public License Version 2.0\n\n/* eslint-disable */\n//prettier-ignore\nconst { keccak_256 } = require('@noble/hashes/sha3')\n\n/**\n * Returns a buffer filled with 0s\n * @method zeros\n * @param {Number} bytes  the number of bytes the buffer should be\n * @return {Buffer}\n */\nfunction zeros (bytes) {\n  return Buffer.allocUnsafe(bytes).fill(0)\n}\n\nfunction bitLengthFromBigInt (num) {\n  return num.toString(2).length\n}\n\nfunction bufferBEFromBigInt(num, length) {\n  let hex = num.toString(16);\n  // Ensure the hex string length is even\n  if (hex.length % 2 !== 0) hex = '0' + hex;\n  // Convert hex string to a byte array\n  const byteArray = hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16));\n  // Ensure the byte array is of the specified length\n  while (byteArray.length < length) {\n    byteArray.unshift(0); // Prepend with zeroes if shorter than required length\n  }\n\n  return Buffer.from(byteArray);\n}\n\nfunction twosFromBigInt(value, width) {\n  const isNegative = value < 0n;\n  let result;\n  if (isNegative) {\n    // Prepare a mask for the specified width to perform NOT operation\n    const mask = (1n << BigInt(width)) - 1n;\n    // Invert bits (using NOT) and add one\n    result = (~value & mask) + 1n;\n  } else {\n    result = value;\n  }\n  // Ensure the result fits in the specified width\n  result &= (1n << BigInt(width)) - 1n;\n\n  return result;\n}\n\n/**\n * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @method setLength\n * @param {Buffer|Array} msg the value to pad\n * @param {Number} length the number of bytes the output should be\n * @param {Boolean} [right=false] whether to start padding form the left or right\n * @return {Buffer|Array}\n */\nfunction setLength (msg, length, right) {\n  const buf = zeros(length)\n  msg = toBuffer(msg)\n  if (right) {\n    if (msg.length < length) {\n      msg.copy(buf)\n      return buf\n    }\n    return msg.slice(0, length)\n  } else {\n    if (msg.length < length) {\n      msg.copy(buf, length - msg.length)\n      return buf\n    }\n    return msg.slice(-length)\n  }\n}\n\n/**\n * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param {Buffer|Array} msg the value to pad\n * @param {Number} length the number of bytes the output should be\n * @return {Buffer|Array}\n */\nfunction setLengthRight (msg, length) {\n  return setLength(msg, length, true)\n}\n\n/**\n * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BIgInt` and other objects with a `toArray()` method.\n * @param {*} v the value\n */\nfunction toBuffer (v) {\n  if (!Buffer.isBuffer(v)) {\n    if (Array.isArray(v)) {\n      v = Buffer.from(v)\n    } else if (typeof v === 'string') {\n      if (isHexString(v)) {\n        v = Buffer.from(padToEven(stripHexPrefix(v)), 'hex')\n      } else {\n        v = Buffer.from(v)\n      }\n    } else if (typeof v === 'number') {\n      v = intToBuffer(v)\n    } else if (v === null || v === undefined) {\n      v = Buffer.allocUnsafe(0)\n    } else if (typeof v === 'bigint') {\n      v = bufferBEFromBigInt(v)\n    } else if (v.toArray) {\n      // TODO: bigint should be handled above, may remove this duplicate\n      // converts a BigInt to a Buffer\n      v = Buffer.from(v.toArray())\n    } else {\n      throw new Error('invalid type')\n    }\n  }\n  return v\n}\n\n/**\n * Converts a `Buffer` into a hex `String`\n * @param {Buffer} buf\n * @return {String}\n */\nfunction bufferToHex (buf) {\n  buf = toBuffer(buf)\n  return '0x' + buf.toString('hex')\n}\n\n/**\n * Creates Keccak hash of the input\n * @param {Buffer|Array|String|Number} a the input data\n * @param {Number} [bits=256] the Keccak width\n * @return {Buffer}\n */\nfunction keccak (a, bits) {\n  a = toBuffer(a)\n  if (!bits) bits = 256\n  if (bits !== 256) {\n    throw new Error('unsupported')\n  }\n  return Buffer.from(keccak_256(new Uint8Array(a)))\n}\n\nfunction padToEven (str) {\n  return str.length % 2 ? '0' + str : str\n}\n\nfunction isHexString (str) {\n  return typeof str === 'string' && str.match(/^0x[0-9A-Fa-f]*$/)\n}\n\nfunction stripHexPrefix (str) {\n  if (typeof str === 'string' && str.startsWith('0x')) {\n    return str.slice(2)\n  }\n  return str\n}\n\nmodule.exports = {\n  zeros,\n  setLength,\n  setLengthRight,\n  isHexString,\n  stripHexPrefix,\n  toBuffer,\n  bufferToHex,\n  keccak,\n  bitLengthFromBigInt,\n  bufferBEFromBigInt,\n  twosFromBigInt\n}\n","// Copyright (c) 2018-2024 Coinbase, Inc. <https://www.coinbase.com/>\n// TODO: clean up, or possibly deprecate Storage class\nexport class ScopedLocalStorage {\n    constructor(scope, module) {\n        this.scope = scope;\n        this.module = module;\n    }\n    storeObject(key, item) {\n        this.setItem(key, JSON.stringify(item));\n    }\n    loadObject(key) {\n        const item = this.getItem(key);\n        return item ? JSON.parse(item) : undefined;\n    }\n    setItem(key, value) {\n        localStorage.setItem(this.scopedKey(key), value);\n    }\n    getItem(key) {\n        return localStorage.getItem(this.scopedKey(key));\n    }\n    removeItem(key) {\n        localStorage.removeItem(this.scopedKey(key));\n    }\n    clear() {\n        const prefix = this.scopedKey('');\n        const keysToRemove = [];\n        for (let i = 0; i < localStorage.length; i++) {\n            const key = localStorage.key(i);\n            if (typeof key === 'string' && key.startsWith(prefix)) {\n                keysToRemove.push(key);\n            }\n        }\n        keysToRemove.forEach((key) => localStorage.removeItem(key));\n    }\n    scopedKey(key) {\n        return `-${this.scope}${this.module ? `:${this.module}` : ''}:${key}`;\n    }\n    static clearAll() {\n        new ScopedLocalStorage('CBWSDK').clear();\n        new ScopedLocalStorage('walletlink').clear();\n    }\n}\n//# sourceMappingURL=ScopedLocalStorage.js.map","export const standardErrorCodes = {\n    rpc: {\n        invalidInput: -32000,\n        resourceNotFound: -32001,\n        resourceUnavailable: -32002,\n        transactionRejected: -32003,\n        methodNotSupported: -32004,\n        limitExceeded: -32005,\n        parse: -32700,\n        invalidRequest: -32600,\n        methodNotFound: -32601,\n        invalidParams: -32602,\n        internal: -32603,\n    },\n    provider: {\n        userRejectedRequest: 4001,\n        unauthorized: 4100,\n        unsupportedMethod: 4200,\n        disconnected: 4900,\n        chainDisconnected: 4901,\n        unsupportedChain: 4902,\n    },\n};\nexport const errorValues = {\n    '-32700': {\n        standard: 'JSON RPC 2.0',\n        message: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',\n    },\n    '-32600': {\n        standard: 'JSON RPC 2.0',\n        message: 'The JSON sent is not a valid Request object.',\n    },\n    '-32601': {\n        standard: 'JSON RPC 2.0',\n        message: 'The method does not exist / is not available.',\n    },\n    '-32602': {\n        standard: 'JSON RPC 2.0',\n        message: 'Invalid method parameter(s).',\n    },\n    '-32603': {\n        standard: 'JSON RPC 2.0',\n        message: 'Internal JSON-RPC error.',\n    },\n    '-32000': {\n        standard: 'EIP-1474',\n        message: 'Invalid input.',\n    },\n    '-32001': {\n        standard: 'EIP-1474',\n        message: 'Resource not found.',\n    },\n    '-32002': {\n        standard: 'EIP-1474',\n        message: 'Resource unavailable.',\n    },\n    '-32003': {\n        standard: 'EIP-1474',\n        message: 'Transaction rejected.',\n    },\n    '-32004': {\n        standard: 'EIP-1474',\n        message: 'Method not supported.',\n    },\n    '-32005': {\n        standard: 'EIP-1474',\n        message: 'Request limit exceeded.',\n    },\n    '4001': {\n        standard: 'EIP-1193',\n        message: 'User rejected the request.',\n    },\n    '4100': {\n        standard: 'EIP-1193',\n        message: 'The requested account and/or method has not been authorized by the user.',\n    },\n    '4200': {\n        standard: 'EIP-1193',\n        message: 'The requested method is not supported by this Ethereum provider.',\n    },\n    '4900': {\n        standard: 'EIP-1193',\n        message: 'The provider is disconnected from all chains.',\n    },\n    '4901': {\n        standard: 'EIP-1193',\n        message: 'The provider is disconnected from the specified chain.',\n    },\n    '4902': {\n        standard: 'EIP-3085',\n        message: 'Unrecognized chain ID.',\n    },\n};\n//# sourceMappingURL=constants.js.map","import { errorValues, standardErrorCodes } from './constants.js';\nconst FALLBACK_MESSAGE = 'Unspecified error message.';\nexport const JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.';\n/**\n * Gets the message for a given code, or a fallback message if the code has\n * no corresponding message.\n */\nexport function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {\n    if (code && Number.isInteger(code)) {\n        const codeString = code.toString();\n        if (hasKey(errorValues, codeString)) {\n            return errorValues[codeString].message;\n        }\n        if (isJsonRpcServerError(code)) {\n            return JSON_RPC_SERVER_ERROR_MESSAGE;\n        }\n    }\n    return fallbackMessage;\n}\n/**\n * Returns whether the given code is valid.\n * A code is only valid if it has a message.\n */\nexport function isValidCode(code) {\n    if (!Number.isInteger(code)) {\n        return false;\n    }\n    const codeString = code.toString();\n    if (errorValues[codeString]) {\n        return true;\n    }\n    if (isJsonRpcServerError(code)) {\n        return true;\n    }\n    return false;\n}\n/**\n * Returns the error code from an error object.\n */\nexport function getErrorCode(error) {\n    var _a;\n    if (typeof error === 'number') {\n        return error;\n    }\n    else if (isErrorWithCode(error)) {\n        return (_a = error.code) !== null && _a !== void 0 ? _a : error.errorCode;\n    }\n    return undefined;\n}\nfunction isErrorWithCode(error) {\n    return (typeof error === 'object' &&\n        error !== null &&\n        (typeof error.code === 'number' ||\n            typeof error.errorCode === 'number'));\n}\nexport function serialize(error, { shouldIncludeStack = false } = {}) {\n    const serialized = {};\n    if (error &&\n        typeof error === 'object' &&\n        !Array.isArray(error) &&\n        hasKey(error, 'code') &&\n        isValidCode(error.code)) {\n        const _error = error;\n        serialized.code = _error.code;\n        if (_error.message && typeof _error.message === 'string') {\n            serialized.message = _error.message;\n            if (hasKey(_error, 'data')) {\n                serialized.data = _error.data;\n            }\n        }\n        else {\n            serialized.message = getMessageFromCode(serialized.code);\n            serialized.data = { originalError: assignOriginalError(error) };\n        }\n    }\n    else {\n        serialized.code = standardErrorCodes.rpc.internal;\n        serialized.message = hasStringProperty(error, 'message') ? error.message : FALLBACK_MESSAGE;\n        serialized.data = { originalError: assignOriginalError(error) };\n    }\n    if (shouldIncludeStack) {\n        serialized.stack = hasStringProperty(error, 'stack') ? error.stack : undefined;\n    }\n    return serialized;\n}\n// Internal\nfunction isJsonRpcServerError(code) {\n    return code >= -32099 && code <= -32000;\n}\nfunction assignOriginalError(error) {\n    if (error && typeof error === 'object' && !Array.isArray(error)) {\n        return Object.assign({}, error);\n    }\n    return error;\n}\nfunction hasKey(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction hasStringProperty(obj, prop) {\n    return (typeof obj === 'object' && obj !== null && prop in obj && typeof obj[prop] === 'string');\n}\n//# sourceMappingURL=utils.js.map","import { standardErrorCodes } from './constants.js';\nimport { getMessageFromCode } from './utils.js';\nexport const standardErrors = {\n    rpc: {\n        parse: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.parse, arg),\n        invalidRequest: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.invalidRequest, arg),\n        invalidParams: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.invalidParams, arg),\n        methodNotFound: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.methodNotFound, arg),\n        internal: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.internal, arg),\n        server: (opts) => {\n            if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {\n                throw new Error('Ethereum RPC Server errors must provide single object argument.');\n            }\n            const { code } = opts;\n            if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n                throw new Error('\"code\" must be an integer such that: -32099 <= code <= -32005');\n            }\n            return getEthJsonRpcError(code, opts);\n        },\n        invalidInput: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.invalidInput, arg),\n        resourceNotFound: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.resourceNotFound, arg),\n        resourceUnavailable: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.resourceUnavailable, arg),\n        transactionRejected: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.transactionRejected, arg),\n        methodNotSupported: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.methodNotSupported, arg),\n        limitExceeded: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.limitExceeded, arg),\n    },\n    provider: {\n        userRejectedRequest: (arg) => {\n            return getEthProviderError(standardErrorCodes.provider.userRejectedRequest, arg);\n        },\n        unauthorized: (arg) => {\n            return getEthProviderError(standardErrorCodes.provider.unauthorized, arg);\n        },\n        unsupportedMethod: (arg) => {\n            return getEthProviderError(standardErrorCodes.provider.unsupportedMethod, arg);\n        },\n        disconnected: (arg) => {\n            return getEthProviderError(standardErrorCodes.provider.disconnected, arg);\n        },\n        chainDisconnected: (arg) => {\n            return getEthProviderError(standardErrorCodes.provider.chainDisconnected, arg);\n        },\n        unsupportedChain: (arg) => {\n            return getEthProviderError(standardErrorCodes.provider.unsupportedChain, arg);\n        },\n        custom: (opts) => {\n            if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {\n                throw new Error('Ethereum Provider custom errors must provide single object argument.');\n            }\n            const { code, message, data } = opts;\n            if (!message || typeof message !== 'string') {\n                throw new Error('\"message\" must be a nonempty string');\n            }\n            return new EthereumProviderError(code, message, data);\n        },\n    },\n};\n// Internal\nfunction getEthJsonRpcError(code, arg) {\n    const [message, data] = parseOpts(arg);\n    return new EthereumRpcError(code, message || getMessageFromCode(code), data);\n}\nfunction getEthProviderError(code, arg) {\n    const [message, data] = parseOpts(arg);\n    return new EthereumProviderError(code, message || getMessageFromCode(code), data);\n}\nfunction parseOpts(arg) {\n    if (arg) {\n        if (typeof arg === 'string') {\n            return [arg];\n        }\n        else if (typeof arg === 'object' && !Array.isArray(arg)) {\n            const { message, data } = arg;\n            if (message && typeof message !== 'string') {\n                throw new Error('Must specify string message.');\n            }\n            return [message || undefined, data];\n        }\n    }\n    return [];\n}\nclass EthereumRpcError extends Error {\n    constructor(code, message, data) {\n        if (!Number.isInteger(code)) {\n            throw new Error('\"code\" must be an integer.');\n        }\n        if (!message || typeof message !== 'string') {\n            throw new Error('\"message\" must be a nonempty string.');\n        }\n        super(message);\n        this.code = code;\n        if (data !== undefined) {\n            this.data = data;\n        }\n    }\n}\nclass EthereumProviderError extends EthereumRpcError {\n    /**\n     * Create an Ethereum Provider JSON-RPC error.\n     * `code` must be an integer in the 1000 <= 4999 range.\n     */\n    constructor(code, message, data) {\n        if (!isValidEthProviderCode(code)) {\n            throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n        }\n        super(code, message, data);\n    }\n}\nfunction isValidEthProviderCode(code) {\n    return Number.isInteger(code) && code >= 1000 && code <= 4999;\n}\n//# sourceMappingURL=errors.js.map","export function OpaqueType() {\n    return (value) => value;\n}\nexport const HexString = OpaqueType();\nexport const AddressString = OpaqueType();\nexport const BigIntString = OpaqueType();\nexport function IntNumber(num) {\n    return Math.floor(num);\n}\nexport const RegExpString = OpaqueType();\n//# sourceMappingURL=index.js.map","/* eslint-disable @typescript-eslint/no-explicit-any */\n// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>\nimport { standardErrors } from '../error/errors.js';\nimport { AddressString, BigIntString, HexString, IntNumber, RegExpString } from './index.js';\nconst INT_STRING_REGEX = /^[0-9]*$/;\nconst HEXADECIMAL_STRING_REGEX = /^[a-f0-9]*$/;\n/**\n * @param length number of bytes\n */\nexport function randomBytesHex(length) {\n    return uint8ArrayToHex(crypto.getRandomValues(new Uint8Array(length)));\n}\nexport function uint8ArrayToHex(value) {\n    return [...value].map((b) => b.toString(16).padStart(2, '0')).join('');\n}\nexport function hexStringToUint8Array(hexString) {\n    return new Uint8Array(hexString.match(/.{1,2}/g).map((byte) => Number.parseInt(byte, 16)));\n}\nexport function hexStringFromBuffer(buf, includePrefix = false) {\n    const hex = buf.toString('hex');\n    return HexString(includePrefix ? `0x${hex}` : hex);\n}\nexport function encodeToHexString(str) {\n    return hexStringFromBuffer(ensureBuffer(str), true);\n}\nexport function bigIntStringFromBigInt(bi) {\n    return BigIntString(bi.toString(10));\n}\nexport function intNumberFromHexString(hex) {\n    return IntNumber(Number(BigInt(ensureEvenLengthHexString(hex, true))));\n}\nexport function hexStringFromNumber(num) {\n    return HexString(`0x${BigInt(num).toString(16)}`);\n}\nexport function has0xPrefix(str) {\n    return str.startsWith('0x') || str.startsWith('0X');\n}\nexport function strip0x(hex) {\n    if (has0xPrefix(hex)) {\n        return hex.slice(2);\n    }\n    return hex;\n}\nexport function prepend0x(hex) {\n    if (has0xPrefix(hex)) {\n        return `0x${hex.slice(2)}`;\n    }\n    return `0x${hex}`;\n}\nexport function isHexString(hex) {\n    if (typeof hex !== 'string') {\n        return false;\n    }\n    const s = strip0x(hex).toLowerCase();\n    return HEXADECIMAL_STRING_REGEX.test(s);\n}\nexport function ensureHexString(hex, includePrefix = false) {\n    if (typeof hex === 'string') {\n        const s = strip0x(hex).toLowerCase();\n        if (HEXADECIMAL_STRING_REGEX.test(s)) {\n            return HexString(includePrefix ? `0x${s}` : s);\n        }\n    }\n    throw standardErrors.rpc.invalidParams(`\"${String(hex)}\" is not a hexadecimal string`);\n}\nexport function ensureEvenLengthHexString(hex, includePrefix = false) {\n    let h = ensureHexString(hex, false);\n    if (h.length % 2 === 1) {\n        h = HexString(`0${h}`);\n    }\n    return includePrefix ? HexString(`0x${h}`) : h;\n}\nexport function ensureAddressString(str) {\n    if (typeof str === 'string') {\n        const s = strip0x(str).toLowerCase();\n        if (isHexString(s) && s.length === 40) {\n            return AddressString(prepend0x(s));\n        }\n    }\n    throw standardErrors.rpc.invalidParams(`Invalid Ethereum address: ${String(str)}`);\n}\nexport function ensureBuffer(str) {\n    if (Buffer.isBuffer(str)) {\n        return str;\n    }\n    if (typeof str === 'string') {\n        if (isHexString(str)) {\n            const s = ensureEvenLengthHexString(str, false);\n            return Buffer.from(s, 'hex');\n        }\n        return Buffer.from(str, 'utf8');\n    }\n    throw standardErrors.rpc.invalidParams(`Not binary data: ${String(str)}`);\n}\nexport function ensureIntNumber(num) {\n    if (typeof num === 'number' && Number.isInteger(num)) {\n        return IntNumber(num);\n    }\n    if (typeof num === 'string') {\n        if (INT_STRING_REGEX.test(num)) {\n            return IntNumber(Number(num));\n        }\n        if (isHexString(num)) {\n            return IntNumber(Number(BigInt(ensureEvenLengthHexString(num, true))));\n        }\n    }\n    throw standardErrors.rpc.invalidParams(`Not an integer: ${String(num)}`);\n}\nexport function ensureRegExpString(regExp) {\n    if (regExp instanceof RegExp) {\n        return RegExpString(regExp.toString());\n    }\n    throw standardErrors.rpc.invalidParams(`Not a RegExp: ${String(regExp)}`);\n}\nexport function ensureBigInt(val) {\n    if (val !== null && (typeof val === 'bigint' || isBigNumber(val))) {\n        return BigInt(val.toString(10));\n    }\n    if (typeof val === 'number') {\n        return BigInt(ensureIntNumber(val));\n    }\n    if (typeof val === 'string') {\n        if (INT_STRING_REGEX.test(val)) {\n            return BigInt(val);\n        }\n        if (isHexString(val)) {\n            return BigInt(ensureEvenLengthHexString(val, true));\n        }\n    }\n    throw standardErrors.rpc.invalidParams(`Not an integer: ${String(val)}`);\n}\nexport function ensureParsedJSONObject(val) {\n    if (typeof val === 'string') {\n        return JSON.parse(val);\n    }\n    if (typeof val === 'object') {\n        return val;\n    }\n    throw standardErrors.rpc.invalidParams(`Not a JSON string or an object: ${String(val)}`);\n}\nexport function isBigNumber(val) {\n    if (val == null || typeof val.constructor !== 'function') {\n        return false;\n    }\n    const { constructor } = val;\n    return typeof constructor.config === 'function' && typeof constructor.EUCLID === 'number';\n}\nexport function range(start, stop) {\n    return Array.from({ length: stop - start }, (_, i) => start + i);\n}\nexport function getFavicon() {\n    const el = document.querySelector('link[sizes=\"192x192\"]') ||\n        document.querySelector('link[sizes=\"180x180\"]') ||\n        document.querySelector('link[rel=\"icon\"]') ||\n        document.querySelector('link[rel=\"shortcut icon\"]');\n    const { protocol, host } = document.location;\n    const href = el ? el.getAttribute('href') : null;\n    if (!href || href.startsWith('javascript:') || href.startsWith('vbscript:')) {\n        return `${protocol}//${host}/favicon.ico`; // fallback\n    }\n    if (href.startsWith('http://') || href.startsWith('https://') || href.startsWith('data:')) {\n        return href;\n    }\n    if (href.startsWith('//')) {\n        return protocol + href;\n    }\n    return `${protocol}//${host}${href}`;\n}\nexport function areAddressArraysEqual(arr1, arr2) {\n    return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);\n}\n//# sourceMappingURL=util.js.map","import { hexStringToUint8Array, uint8ArrayToHex } from '../core/type/util.js';\nexport async function generateKeyPair() {\n    return crypto.subtle.generateKey({\n        name: 'ECDH',\n        namedCurve: 'P-256',\n    }, true, ['deriveKey']);\n}\nexport async function deriveSharedSecret(ownPrivateKey, peerPublicKey) {\n    return crypto.subtle.deriveKey({\n        name: 'ECDH',\n        public: peerPublicKey,\n    }, ownPrivateKey, {\n        name: 'AES-GCM',\n        length: 256,\n    }, false, ['encrypt', 'decrypt']);\n}\nexport async function encrypt(sharedSecret, plainText) {\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const cipherText = await crypto.subtle.encrypt({\n        name: 'AES-GCM',\n        iv,\n    }, sharedSecret, new TextEncoder().encode(plainText));\n    return { iv, cipherText };\n}\nexport async function decrypt(sharedSecret, { iv, cipherText }) {\n    const plainText = await crypto.subtle.decrypt({\n        name: 'AES-GCM',\n        iv,\n    }, sharedSecret, cipherText);\n    return new TextDecoder().decode(plainText);\n}\nfunction getFormat(keyType) {\n    switch (keyType) {\n        case 'public':\n            return 'spki';\n        case 'private':\n            return 'pkcs8';\n    }\n}\nexport async function exportKeyToHexString(type, key) {\n    const format = getFormat(type);\n    const exported = await crypto.subtle.exportKey(format, key);\n    return uint8ArrayToHex(new Uint8Array(exported));\n}\nexport async function importKeyFromHexString(type, hexString) {\n    const format = getFormat(type);\n    const arrayBuffer = hexStringToUint8Array(hexString).buffer;\n    return await crypto.subtle.importKey(format, new Uint8Array(arrayBuffer), {\n        name: 'ECDH',\n        namedCurve: 'P-256',\n    }, true, type === 'private' ? ['deriveKey'] : []);\n}\nexport async function encryptContent(content, sharedSecret) {\n    const serialized = JSON.stringify(content, (_, value) => {\n        if (!(value instanceof Error))\n            return value;\n        const error = value;\n        return Object.assign(Object.assign({}, (error.code ? { code: error.code } : {})), { message: error.message });\n    });\n    return encrypt(sharedSecret, serialized);\n}\nexport async function decryptContent(encryptedData, sharedSecret) {\n    return JSON.parse(await decrypt(sharedSecret, encryptedData));\n}\n//# sourceMappingURL=cipher.js.map","import { ScopedLocalStorage } from '../../core/storage/ScopedLocalStorage.js';\nimport { deriveSharedSecret, exportKeyToHexString, generateKeyPair, importKeyFromHexString, } from '../../util/cipher.js';\nconst OWN_PRIVATE_KEY = {\n    storageKey: 'ownPrivateKey',\n    keyType: 'private',\n};\nconst OWN_PUBLIC_KEY = {\n    storageKey: 'ownPublicKey',\n    keyType: 'public',\n};\nconst PEER_PUBLIC_KEY = {\n    storageKey: 'peerPublicKey',\n    keyType: 'public',\n};\nexport class SCWKeyManager {\n    constructor() {\n        this.storage = new ScopedLocalStorage('CBWSDK', 'SCWKeyManager');\n        this.ownPrivateKey = null;\n        this.ownPublicKey = null;\n        this.peerPublicKey = null;\n        this.sharedSecret = null;\n    }\n    async getOwnPublicKey() {\n        await this.loadKeysIfNeeded();\n        return this.ownPublicKey;\n    }\n    // returns null if the shared secret is not yet derived\n    async getSharedSecret() {\n        await this.loadKeysIfNeeded();\n        return this.sharedSecret;\n    }\n    async setPeerPublicKey(key) {\n        this.sharedSecret = null;\n        this.peerPublicKey = key;\n        await this.storeKey(PEER_PUBLIC_KEY, key);\n        await this.loadKeysIfNeeded();\n    }\n    async clear() {\n        this.ownPrivateKey = null;\n        this.ownPublicKey = null;\n        this.peerPublicKey = null;\n        this.sharedSecret = null;\n        this.storage.removeItem(OWN_PUBLIC_KEY.storageKey);\n        this.storage.removeItem(OWN_PRIVATE_KEY.storageKey);\n        this.storage.removeItem(PEER_PUBLIC_KEY.storageKey);\n    }\n    async generateKeyPair() {\n        const newKeyPair = await generateKeyPair();\n        this.ownPrivateKey = newKeyPair.privateKey;\n        this.ownPublicKey = newKeyPair.publicKey;\n        await this.storeKey(OWN_PRIVATE_KEY, newKeyPair.privateKey);\n        await this.storeKey(OWN_PUBLIC_KEY, newKeyPair.publicKey);\n    }\n    async loadKeysIfNeeded() {\n        if (this.ownPrivateKey === null) {\n            this.ownPrivateKey = await this.loadKey(OWN_PRIVATE_KEY);\n        }\n        if (this.ownPublicKey === null) {\n            this.ownPublicKey = await this.loadKey(OWN_PUBLIC_KEY);\n        }\n        if (this.ownPrivateKey === null || this.ownPublicKey === null) {\n            await this.generateKeyPair();\n        }\n        if (this.peerPublicKey === null) {\n            this.peerPublicKey = await this.loadKey(PEER_PUBLIC_KEY);\n        }\n        if (this.sharedSecret === null) {\n            if (this.ownPrivateKey === null || this.peerPublicKey === null)\n                return;\n            this.sharedSecret = await deriveSharedSecret(this.ownPrivateKey, this.peerPublicKey);\n        }\n    }\n    // storage methods\n    async loadKey(item) {\n        const key = this.storage.getItem(item.storageKey);\n        if (!key)\n            return null;\n        return importKeyFromHexString(item.keyType, key);\n    }\n    async storeKey(item, key) {\n        const hexString = await exportKeyToHexString(item.keyType, key);\n        this.storage.setItem(item.storageKey, hexString);\n    }\n}\n//# sourceMappingURL=SCWKeyManager.js.map","export const VERSION = '4.2.3';\nexport const NAME = '@coinbase/wallet-sdk';\n//# sourceMappingURL=sdk-info.js.map","import { NAME, VERSION } from '../sdk-info.js';\nimport { standardErrors } from '../core/error/errors.js';\nexport async function fetchRPCRequest(request, rpcUrl) {\n    const requestBody = Object.assign(Object.assign({}, request), { jsonrpc: '2.0', id: crypto.randomUUID() });\n    const res = await window.fetch(rpcUrl, {\n        method: 'POST',\n        body: JSON.stringify(requestBody),\n        mode: 'cors',\n        headers: {\n            'Content-Type': 'application/json',\n            'X-Cbw-Sdk-Version': VERSION,\n            'X-Cbw-Sdk-Platform': NAME,\n        },\n    });\n    const { result, error } = await res.json();\n    if (error)\n        throw error;\n    return result;\n}\nfunction getCoinbaseInjectedLegacyProvider() {\n    const window = globalThis;\n    return window.coinbaseWalletExtension;\n}\nfunction getInjectedEthereum() {\n    var _a, _b;\n    try {\n        const window = globalThis;\n        return (_a = window.ethereum) !== null && _a !== void 0 ? _a : (_b = window.top) === null || _b === void 0 ? void 0 : _b.ethereum;\n    }\n    catch (_c) {\n        return undefined;\n    }\n}\nexport function getCoinbaseInjectedProvider({ metadata, preference, }) {\n    var _a, _b;\n    const { appName, appLogoUrl, appChainIds } = metadata;\n    if (preference.options !== 'smartWalletOnly') {\n        const extension = getCoinbaseInjectedLegacyProvider();\n        if (extension) {\n            (_a = extension.setAppInfo) === null || _a === void 0 ? void 0 : _a.call(extension, appName, appLogoUrl, appChainIds, preference);\n            return extension;\n        }\n    }\n    const ethereum = getInjectedEthereum();\n    if (ethereum === null || ethereum === void 0 ? void 0 : ethereum.isCoinbaseBrowser) {\n        (_b = ethereum.setAppInfo) === null || _b === void 0 ? void 0 : _b.call(ethereum, appName, appLogoUrl, appChainIds, preference);\n        return ethereum;\n    }\n    return undefined;\n}\n/**\n * Validates the arguments for an invalid request and returns an error if any validation fails.\n * Valid request args are defined here: https://eips.ethereum.org/EIPS/eip-1193#request\n * @param args The request arguments to validate.\n * @returns An error object if the arguments are invalid, otherwise undefined.\n */\nexport function checkErrorForInvalidRequestArgs(args) {\n    if (!args || typeof args !== 'object' || Array.isArray(args)) {\n        throw standardErrors.rpc.invalidParams({\n            message: 'Expected a single, non-array, object argument.',\n            data: args,\n        });\n    }\n    const { method, params } = args;\n    if (typeof method !== 'string' || method.length === 0) {\n        throw standardErrors.rpc.invalidParams({\n            message: \"'args.method' must be a non-empty string.\",\n            data: args,\n        });\n    }\n    if (params !== undefined &&\n        !Array.isArray(params) &&\n        (typeof params !== 'object' || params === null)) {\n        throw standardErrors.rpc.invalidParams({\n            message: \"'args.params' must be an object or array if provided.\",\n            data: args,\n        });\n    }\n    switch (method) {\n        case 'eth_sign':\n        case 'eth_signTypedData_v2':\n        case 'eth_subscribe':\n        case 'eth_unsubscribe':\n            throw standardErrors.provider.unsupportedMethod();\n    }\n}\n//# sourceMappingURL=provider.js.map","import { SCWKeyManager } from './SCWKeyManager.js';\nimport { standardErrors } from '../../core/error/errors.js';\nimport { ScopedLocalStorage } from '../../core/storage/ScopedLocalStorage.js';\nimport { ensureIntNumber, hexStringFromNumber } from '../../core/type/util.js';\nimport { decryptContent, encryptContent, exportKeyToHexString, importKeyFromHexString, } from '../../util/cipher.js';\nimport { fetchRPCRequest } from '../../util/provider.js';\nconst ACCOUNTS_KEY = 'accounts';\nconst ACTIVE_CHAIN_STORAGE_KEY = 'activeChain';\nconst AVAILABLE_CHAINS_STORAGE_KEY = 'availableChains';\nconst WALLET_CAPABILITIES_STORAGE_KEY = 'walletCapabilities';\nexport class SCWSigner {\n    constructor(params) {\n        var _a, _b, _c;\n        this.metadata = params.metadata;\n        this.communicator = params.communicator;\n        this.callback = params.callback;\n        this.keyManager = new SCWKeyManager();\n        this.storage = new ScopedLocalStorage('CBWSDK', 'SCWStateManager');\n        this.accounts = (_a = this.storage.loadObject(ACCOUNTS_KEY)) !== null && _a !== void 0 ? _a : [];\n        this.chain = this.storage.loadObject(ACTIVE_CHAIN_STORAGE_KEY) || {\n            id: (_c = (_b = params.metadata.appChainIds) === null || _b === void 0 ? void 0 : _b[0]) !== null && _c !== void 0 ? _c : 1,\n        };\n        this.handshake = this.handshake.bind(this);\n        this.request = this.request.bind(this);\n        this.createRequestMessage = this.createRequestMessage.bind(this);\n        this.decryptResponseMessage = this.decryptResponseMessage.bind(this);\n    }\n    async handshake(args) {\n        var _a, _b;\n        const handshakeMessage = await this.createRequestMessage({\n            handshake: {\n                method: args.method,\n                params: Object.assign({}, this.metadata, (_a = args.params) !== null && _a !== void 0 ? _a : {}),\n            },\n        });\n        const response = await this.communicator.postRequestAndWaitForResponse(handshakeMessage);\n        // store peer's public key\n        if ('failure' in response.content)\n            throw response.content.failure;\n        const peerPublicKey = await importKeyFromHexString('public', response.sender);\n        await this.keyManager.setPeerPublicKey(peerPublicKey);\n        const decrypted = await this.decryptResponseMessage(response);\n        const result = decrypted.result;\n        if ('error' in result)\n            throw result.error;\n        const accounts = result.value;\n        this.accounts = accounts;\n        this.storage.storeObject(ACCOUNTS_KEY, accounts);\n        (_b = this.callback) === null || _b === void 0 ? void 0 : _b.call(this, 'accountsChanged', accounts);\n    }\n    async request(request) {\n        var _a;\n        if (this.accounts.length === 0) {\n            throw standardErrors.provider.unauthorized();\n        }\n        switch (request.method) {\n            case 'eth_requestAccounts':\n                (_a = this.callback) === null || _a === void 0 ? void 0 : _a.call(this, 'connect', { chainId: hexStringFromNumber(this.chain.id) });\n                return this.accounts;\n            case 'eth_accounts':\n                return this.accounts;\n            case 'eth_coinbase':\n                return this.accounts[0];\n            case 'net_version':\n                return this.chain.id;\n            case 'eth_chainId':\n                return hexStringFromNumber(this.chain.id);\n            case 'wallet_getCapabilities':\n                return this.storage.loadObject(WALLET_CAPABILITIES_STORAGE_KEY);\n            case 'wallet_switchEthereumChain':\n                return this.handleSwitchChainRequest(request);\n            case 'eth_ecRecover':\n            case 'personal_sign':\n            case 'personal_ecRecover':\n            case 'eth_signTransaction':\n            case 'eth_sendTransaction':\n            case 'eth_signTypedData_v1':\n            case 'eth_signTypedData_v3':\n            case 'eth_signTypedData_v4':\n            case 'eth_signTypedData':\n            case 'wallet_addEthereumChain':\n            case 'wallet_watchAsset':\n            case 'wallet_sendCalls':\n            case 'wallet_showCallsStatus':\n            case 'wallet_grantPermissions':\n                return this.sendRequestToPopup(request);\n            default:\n                if (!this.chain.rpcUrl)\n                    throw standardErrors.rpc.internal('No RPC URL set for chain');\n                return fetchRPCRequest(request, this.chain.rpcUrl);\n        }\n    }\n    async sendRequestToPopup(request) {\n        var _a, _b;\n        // Open the popup before constructing the request message.\n        // This is to ensure that the popup is not blocked by some browsers (i.e. Safari)\n        await ((_b = (_a = this.communicator).waitForPopupLoaded) === null || _b === void 0 ? void 0 : _b.call(_a));\n        const response = await this.sendEncryptedRequest(request);\n        const decrypted = await this.decryptResponseMessage(response);\n        const result = decrypted.result;\n        if ('error' in result)\n            throw result.error;\n        return result.value;\n    }\n    async cleanup() {\n        var _a, _b;\n        this.storage.clear();\n        await this.keyManager.clear();\n        this.accounts = [];\n        this.chain = {\n            id: (_b = (_a = this.metadata.appChainIds) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 1,\n        };\n    }\n    /**\n     * @returns `null` if the request was successful.\n     * https://eips.ethereum.org/EIPS/eip-3326#wallet_switchethereumchain\n     */\n    async handleSwitchChainRequest(request) {\n        var _a;\n        const params = request.params;\n        if (!params || !((_a = params[0]) === null || _a === void 0 ? void 0 : _a.chainId)) {\n            throw standardErrors.rpc.invalidParams();\n        }\n        const chainId = ensureIntNumber(params[0].chainId);\n        const localResult = this.updateChain(chainId);\n        if (localResult)\n            return null;\n        const popupResult = await this.sendRequestToPopup(request);\n        if (popupResult === null) {\n            this.updateChain(chainId);\n        }\n        return popupResult;\n    }\n    async sendEncryptedRequest(request) {\n        const sharedSecret = await this.keyManager.getSharedSecret();\n        if (!sharedSecret) {\n            throw standardErrors.provider.unauthorized('No valid session found, try requestAccounts before other methods');\n        }\n        const encrypted = await encryptContent({\n            action: request,\n            chainId: this.chain.id,\n        }, sharedSecret);\n        const message = await this.createRequestMessage({ encrypted });\n        return this.communicator.postRequestAndWaitForResponse(message);\n    }\n    async createRequestMessage(content) {\n        const publicKey = await exportKeyToHexString('public', await this.keyManager.getOwnPublicKey());\n        return {\n            id: crypto.randomUUID(),\n            sender: publicKey,\n            content,\n            timestamp: new Date(),\n        };\n    }\n    async decryptResponseMessage(message) {\n        var _a, _b;\n        const content = message.content;\n        // throw protocol level error\n        if ('failure' in content) {\n            throw content.failure;\n        }\n        const sharedSecret = await this.keyManager.getSharedSecret();\n        if (!sharedSecret) {\n            throw standardErrors.provider.unauthorized('Invalid session');\n        }\n        const response = await decryptContent(content.encrypted, sharedSecret);\n        const availableChains = (_a = response.data) === null || _a === void 0 ? void 0 : _a.chains;\n        if (availableChains) {\n            const chains = Object.entries(availableChains).map(([id, rpcUrl]) => ({\n                id: Number(id),\n                rpcUrl,\n            }));\n            this.storage.storeObject(AVAILABLE_CHAINS_STORAGE_KEY, chains);\n            this.updateChain(this.chain.id, chains);\n        }\n        const walletCapabilities = (_b = response.data) === null || _b === void 0 ? void 0 : _b.capabilities;\n        if (walletCapabilities) {\n            this.storage.storeObject(WALLET_CAPABILITIES_STORAGE_KEY, walletCapabilities);\n        }\n        return response;\n    }\n    updateChain(chainId, newAvailableChains) {\n        var _a;\n        const chains = newAvailableChains !== null && newAvailableChains !== void 0 ? newAvailableChains : this.storage.loadObject(AVAILABLE_CHAINS_STORAGE_KEY);\n        const chain = chains === null || chains === void 0 ? void 0 : chains.find((chain) => chain.id === chainId);\n        if (!chain)\n            return false;\n        if (chain !== this.chain) {\n            this.chain = chain;\n            this.storage.storeObject(ACTIVE_CHAIN_STORAGE_KEY, chain);\n            (_a = this.callback) === null || _a === void 0 ? void 0 : _a.call(this, 'chainChanged', hexStringFromNumber(chain.id));\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=SCWSigner.js.map","export const WALLET_USER_NAME_KEY = 'walletUsername';\nexport const LOCAL_STORAGE_ADDRESSES_KEY = 'Addresses';\nexport const APP_VERSION_KEY = 'AppVersion';\n//# sourceMappingURL=constants.js.map","// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>\nexport function isErrorResponse(response) {\n    return response.errorMessage !== undefined;\n}\n//# sourceMappingURL=Web3Response.js.map","// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>\nimport { hexStringToUint8Array, uint8ArrayToHex } from '../../../../core/type/util.js';\nexport class WalletLinkCipher {\n    // @param secret hex representation of 32-byte secret\n    constructor(secret) {\n        this.secret = secret;\n    }\n    /**\n     *\n     * @param plainText string to be encrypted\n     * returns hex string representation of bytes in the order: initialization vector (iv),\n     * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the\n     * encrypted plainText.\n     */\n    async encrypt(plainText) {\n        const secret = this.secret;\n        if (secret.length !== 64)\n            throw Error(`secret must be 256 bits`);\n        const ivBytes = crypto.getRandomValues(new Uint8Array(12));\n        const secretKey = await crypto.subtle.importKey('raw', hexStringToUint8Array(secret), { name: 'aes-gcm' }, false, ['encrypt', 'decrypt']);\n        const enc = new TextEncoder();\n        // Will return encrypted plainText with auth tag (ie MAC or checksum) appended at the end\n        const encryptedResult = await window.crypto.subtle.encrypt({\n            name: 'AES-GCM',\n            iv: ivBytes,\n        }, secretKey, enc.encode(plainText));\n        const tagLength = 16;\n        const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);\n        const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);\n        const authTagBytes = new Uint8Array(authTag);\n        const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);\n        const concatted = new Uint8Array([...ivBytes, ...authTagBytes, ...encryptedPlaintextBytes]);\n        return uint8ArrayToHex(concatted);\n    }\n    /**\n     *\n     * @param cipherText hex string representation of bytes in the order: initialization vector (iv),\n     * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.\n     */\n    async decrypt(cipherText) {\n        const secret = this.secret;\n        if (secret.length !== 64)\n            throw Error(`secret must be 256 bits`);\n        return new Promise((resolve, reject) => {\n            void (async function () {\n                const secretKey = await crypto.subtle.importKey('raw', hexStringToUint8Array(secret), { name: 'aes-gcm' }, false, ['encrypt', 'decrypt']);\n                const encrypted = hexStringToUint8Array(cipherText);\n                const ivBytes = encrypted.slice(0, 12);\n                const authTagBytes = encrypted.slice(12, 28);\n                const encryptedPlaintextBytes = encrypted.slice(28);\n                const concattedBytes = new Uint8Array([...encryptedPlaintextBytes, ...authTagBytes]);\n                const algo = {\n                    name: 'AES-GCM',\n                    iv: new Uint8Array(ivBytes),\n                };\n                try {\n                    const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);\n                    const decoder = new TextDecoder();\n                    resolve(decoder.decode(decrypted));\n                }\n                catch (err) {\n                    reject(err);\n                }\n            })();\n        });\n    }\n}\n//# sourceMappingURL=WalletLinkCipher.js.map","export class WalletLinkHTTP {\n    constructor(linkAPIUrl, sessionId, sessionKey) {\n        this.linkAPIUrl = linkAPIUrl;\n        this.sessionId = sessionId;\n        const credentials = `${sessionId}:${sessionKey}`;\n        this.auth = `Basic ${btoa(credentials)}`;\n    }\n    // mark unseen events as seen\n    async markUnseenEventsAsSeen(events) {\n        return Promise.all(events.map((e) => fetch(`${this.linkAPIUrl}/events/${e.eventId}/seen`, {\n            method: 'POST',\n            headers: {\n                Authorization: this.auth,\n            },\n        }))).catch((error) => console.error('Unabled to mark event as failed:', error));\n    }\n    async fetchUnseenEvents() {\n        var _a;\n        const response = await fetch(`${this.linkAPIUrl}/events?unseen=true`, {\n            headers: {\n                Authorization: this.auth,\n            },\n        });\n        if (response.ok) {\n            const { events, error } = (await response.json());\n            if (error) {\n                throw new Error(`Check unseen events failed: ${error}`);\n            }\n            const responseEvents = (_a = events === null || events === void 0 ? void 0 : events.filter((e) => e.event === 'Web3Response').map((e) => ({\n                type: 'Event',\n                sessionId: this.sessionId,\n                eventId: e.id,\n                event: e.event,\n                data: e.data,\n            }))) !== null && _a !== void 0 ? _a : [];\n            this.markUnseenEventsAsSeen(responseEvents);\n            return responseEvents;\n        }\n        throw new Error(`Check unseen events failed: ${response.status}`);\n    }\n}\n//# sourceMappingURL=WalletLinkHTTP.js.map","// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>\nexport var ConnectionState;\n(function (ConnectionState) {\n    ConnectionState[ConnectionState[\"DISCONNECTED\"] = 0] = \"DISCONNECTED\";\n    ConnectionState[ConnectionState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    ConnectionState[ConnectionState[\"CONNECTED\"] = 2] = \"CONNECTED\";\n})(ConnectionState || (ConnectionState = {}));\nexport class WalletLinkWebSocket {\n    setConnectionStateListener(listener) {\n        this.connectionStateListener = listener;\n    }\n    setIncomingDataListener(listener) {\n        this.incomingDataListener = listener;\n    }\n    /**\n     * Constructor\n     * @param url WebSocket server URL\n     * @param [WebSocketClass] Custom WebSocket implementation\n     */\n    constructor(url, WebSocketClass = WebSocket) {\n        this.WebSocketClass = WebSocketClass;\n        this.webSocket = null;\n        this.pendingData = [];\n        this.url = url.replace(/^http/, 'ws');\n    }\n    /**\n     * Make a websocket connection\n     * @returns a Promise that resolves when connected\n     */\n    async connect() {\n        if (this.webSocket) {\n            throw new Error('webSocket object is not null');\n        }\n        return new Promise((resolve, reject) => {\n            var _a;\n            let webSocket;\n            try {\n                this.webSocket = webSocket = new this.WebSocketClass(this.url);\n            }\n            catch (err) {\n                reject(err);\n                return;\n            }\n            (_a = this.connectionStateListener) === null || _a === void 0 ? void 0 : _a.call(this, ConnectionState.CONNECTING);\n            webSocket.onclose = (evt) => {\n                var _a;\n                this.clearWebSocket();\n                reject(new Error(`websocket error ${evt.code}: ${evt.reason}`));\n                (_a = this.connectionStateListener) === null || _a === void 0 ? void 0 : _a.call(this, ConnectionState.DISCONNECTED);\n            };\n            webSocket.onopen = (_) => {\n                var _a;\n                resolve();\n                (_a = this.connectionStateListener) === null || _a === void 0 ? void 0 : _a.call(this, ConnectionState.CONNECTED);\n                if (this.pendingData.length > 0) {\n                    const pending = [...this.pendingData];\n                    pending.forEach((data) => this.sendData(data));\n                    this.pendingData = [];\n                }\n            };\n            webSocket.onmessage = (evt) => {\n                var _a, _b;\n                if (evt.data === 'h') {\n                    (_a = this.incomingDataListener) === null || _a === void 0 ? void 0 : _a.call(this, {\n                        type: 'Heartbeat',\n                    });\n                }\n                else {\n                    try {\n                        const message = JSON.parse(evt.data);\n                        (_b = this.incomingDataListener) === null || _b === void 0 ? void 0 : _b.call(this, message);\n                    }\n                    catch (_c) {\n                        /* empty */\n                    }\n                }\n            };\n        });\n    }\n    /**\n     * Disconnect from server\n     */\n    disconnect() {\n        var _a;\n        const { webSocket } = this;\n        if (!webSocket) {\n            return;\n        }\n        this.clearWebSocket();\n        (_a = this.connectionStateListener) === null || _a === void 0 ? void 0 : _a.call(this, ConnectionState.DISCONNECTED);\n        this.connectionStateListener = undefined;\n        this.incomingDataListener = undefined;\n        try {\n            webSocket.close();\n        }\n        catch (_b) {\n            // noop\n        }\n    }\n    /**\n     * Send data to server\n     * @param data text to send\n     */\n    sendData(data) {\n        const { webSocket } = this;\n        if (!webSocket) {\n            this.pendingData.push(data);\n            this.connect();\n            return;\n        }\n        webSocket.send(data);\n    }\n    clearWebSocket() {\n        const { webSocket } = this;\n        if (!webSocket) {\n            return;\n        }\n        this.webSocket = null;\n        webSocket.onclose = null;\n        webSocket.onerror = null;\n        webSocket.onmessage = null;\n        webSocket.onopen = null;\n    }\n}\n//# sourceMappingURL=WalletLinkWebSocket.js.map","// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>\nimport { APP_VERSION_KEY, WALLET_USER_NAME_KEY } from '../constants.js';\nimport { WalletLinkCipher } from './WalletLinkCipher.js';\nimport { WalletLinkHTTP } from './WalletLinkHTTP.js';\nimport { ConnectionState, WalletLinkWebSocket } from './WalletLinkWebSocket.js';\nimport { IntNumber } from '../../../../core/type/index.js';\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * Coinbase Wallet Connection\n */\nexport class WalletLinkConnection {\n    /**\n     * Constructor\n     * @param session Session\n     * @param linkAPIUrl Coinbase Wallet link server URL\n     * @param listener WalletLinkConnectionUpdateListener\n     * @param [WebSocketClass] Custom WebSocket implementation\n     */\n    constructor({ session, linkAPIUrl, listener }) {\n        this.destroyed = false;\n        this.lastHeartbeatResponse = 0;\n        this.nextReqId = IntNumber(1);\n        /**\n         * true if connected and authenticated, else false\n         * runs listener when connected status changes\n         */\n        this._connected = false;\n        /**\n         * true if linked (a guest has joined before)\n         * runs listener when linked status changes\n         */\n        this._linked = false;\n        this.shouldFetchUnseenEventsOnConnect = false;\n        this.requestResolutions = new Map();\n        this.handleSessionMetadataUpdated = (metadata) => {\n            if (!metadata)\n                return;\n            // Map of metadata key to handler function\n            const handlers = new Map([\n                ['__destroyed', this.handleDestroyed],\n                ['EthereumAddress', this.handleAccountUpdated],\n                ['WalletUsername', this.handleWalletUsernameUpdated],\n                ['AppVersion', this.handleAppVersionUpdated],\n                [\n                    'ChainId', // ChainId and JsonRpcUrl are always updated together\n                    (v) => metadata.JsonRpcUrl && this.handleChainUpdated(v, metadata.JsonRpcUrl),\n                ],\n            ]);\n            // call handler for each metadata key if value is defined\n            handlers.forEach((handler, key) => {\n                const value = metadata[key];\n                if (value === undefined)\n                    return;\n                handler(value);\n            });\n        };\n        this.handleDestroyed = (__destroyed) => {\n            var _a;\n            if (__destroyed !== '1')\n                return;\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.resetAndReload();\n        };\n        this.handleAccountUpdated = async (encryptedEthereumAddress) => {\n            var _a;\n            const address = await this.cipher.decrypt(encryptedEthereumAddress);\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.accountUpdated(address);\n        };\n        this.handleMetadataUpdated = async (key, encryptedMetadataValue) => {\n            var _a;\n            const decryptedValue = await this.cipher.decrypt(encryptedMetadataValue);\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.metadataUpdated(key, decryptedValue);\n        };\n        this.handleWalletUsernameUpdated = async (walletUsername) => {\n            this.handleMetadataUpdated(WALLET_USER_NAME_KEY, walletUsername);\n        };\n        this.handleAppVersionUpdated = async (appVersion) => {\n            this.handleMetadataUpdated(APP_VERSION_KEY, appVersion);\n        };\n        this.handleChainUpdated = async (encryptedChainId, encryptedJsonRpcUrl) => {\n            var _a;\n            const chainId = await this.cipher.decrypt(encryptedChainId);\n            const jsonRpcUrl = await this.cipher.decrypt(encryptedJsonRpcUrl);\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.chainUpdated(chainId, jsonRpcUrl);\n        };\n        this.session = session;\n        this.cipher = new WalletLinkCipher(session.secret);\n        this.listener = listener;\n        const ws = new WalletLinkWebSocket(`${linkAPIUrl}/rpc`, WebSocket);\n        ws.setConnectionStateListener(async (state) => {\n            // attempt to reconnect every 5 seconds when disconnected\n            let connected = false;\n            switch (state) {\n                case ConnectionState.DISCONNECTED:\n                    // if DISCONNECTED and not destroyed\n                    if (!this.destroyed) {\n                        const connect = async () => {\n                            // wait 5 seconds\n                            await new Promise((resolve) => setTimeout(resolve, 5000));\n                            // check whether it's destroyed again\n                            if (!this.destroyed) {\n                                // reconnect\n                                ws.connect().catch(() => {\n                                    connect();\n                                });\n                            }\n                        };\n                        connect();\n                    }\n                    break;\n                case ConnectionState.CONNECTED:\n                    // perform authentication upon connection\n                    // if CONNECTED, authenticate, and then check link status\n                    connected = await this.handleConnected();\n                    // send heartbeat every n seconds while connected\n                    // if CONNECTED, start the heartbeat timer\n                    // first timer event updates lastHeartbeat timestamp\n                    // subsequent calls send heartbeat message\n                    this.updateLastHeartbeat();\n                    setInterval(() => {\n                        this.heartbeat();\n                    }, HEARTBEAT_INTERVAL);\n                    // check for unseen events\n                    if (this.shouldFetchUnseenEventsOnConnect) {\n                        this.fetchUnseenEventsAPI();\n                    }\n                    break;\n                case ConnectionState.CONNECTING:\n                    break;\n            }\n            // distinctUntilChanged\n            if (this.connected !== connected) {\n                this.connected = connected;\n            }\n        });\n        ws.setIncomingDataListener((m) => {\n            var _a;\n            switch (m.type) {\n                // handle server's heartbeat responses\n                case 'Heartbeat':\n                    this.updateLastHeartbeat();\n                    return;\n                // handle link status updates\n                case 'IsLinkedOK':\n                case 'Linked': {\n                    const linked = m.type === 'IsLinkedOK' ? m.linked : undefined;\n                    this.linked = linked || m.onlineGuests > 0;\n                    break;\n                }\n                // handle session config updates\n                case 'GetSessionConfigOK':\n                case 'SessionConfigUpdated': {\n                    this.handleSessionMetadataUpdated(m.metadata);\n                    break;\n                }\n                case 'Event': {\n                    this.handleIncomingEvent(m);\n                    break;\n                }\n            }\n            // resolve request promises\n            if (m.id !== undefined) {\n                (_a = this.requestResolutions.get(m.id)) === null || _a === void 0 ? void 0 : _a(m);\n            }\n        });\n        this.ws = ws;\n        this.http = new WalletLinkHTTP(linkAPIUrl, session.id, session.key);\n    }\n    /**\n     * Make a connection to the server\n     */\n    connect() {\n        if (this.destroyed) {\n            throw new Error('instance is destroyed');\n        }\n        this.ws.connect();\n    }\n    /**\n     * Terminate connection, and mark as destroyed. To reconnect, create a new\n     * instance of WalletSDKConnection\n     */\n    async destroy() {\n        if (this.destroyed)\n            return;\n        await this.makeRequest({\n            type: 'SetSessionConfig',\n            id: IntNumber(this.nextReqId++),\n            sessionId: this.session.id,\n            metadata: { __destroyed: '1' },\n        }, { timeout: 1000 });\n        this.destroyed = true;\n        this.ws.disconnect();\n        this.listener = undefined;\n    }\n    get connected() {\n        return this._connected;\n    }\n    set connected(connected) {\n        this._connected = connected;\n    }\n    get linked() {\n        return this._linked;\n    }\n    set linked(linked) {\n        var _a, _b;\n        this._linked = linked;\n        if (linked)\n            (_a = this.onceLinked) === null || _a === void 0 ? void 0 : _a.call(this);\n        (_b = this.listener) === null || _b === void 0 ? void 0 : _b.linkedUpdated(linked);\n    }\n    setOnceLinked(callback) {\n        return new Promise((resolve) => {\n            if (this.linked) {\n                callback().then(resolve);\n            }\n            else {\n                this.onceLinked = () => {\n                    callback().then(resolve);\n                    this.onceLinked = undefined;\n                };\n            }\n        });\n    }\n    async handleIncomingEvent(m) {\n        var _a;\n        if (m.type !== 'Event' || m.event !== 'Web3Response') {\n            return;\n        }\n        const decryptedData = await this.cipher.decrypt(m.data);\n        const message = JSON.parse(decryptedData);\n        if (message.type !== 'WEB3_RESPONSE')\n            return;\n        const { id, response } = message;\n        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.handleWeb3ResponseMessage(id, response);\n    }\n    async checkUnseenEvents() {\n        if (!this.connected) {\n            this.shouldFetchUnseenEventsOnConnect = true;\n            return;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 250));\n        try {\n            await this.fetchUnseenEventsAPI();\n        }\n        catch (e) {\n            console.error('Unable to check for unseen events', e);\n        }\n    }\n    async fetchUnseenEventsAPI() {\n        this.shouldFetchUnseenEventsOnConnect = false;\n        const responseEvents = await this.http.fetchUnseenEvents();\n        responseEvents.forEach((e) => this.handleIncomingEvent(e));\n    }\n    /**\n     * Publish an event and emit event ID when successful\n     * @param event event name\n     * @param unencryptedData unencrypted event data\n     * @param callWebhook whether the webhook should be invoked\n     * @returns a Promise that emits event ID when successful\n     */\n    async publishEvent(event, unencryptedData, callWebhook = false) {\n        const data = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, unencryptedData), { origin: location.origin, relaySource: 'coinbaseWalletExtension' in window && window.coinbaseWalletExtension\n                ? 'injected_sdk'\n                : 'sdk' })));\n        const message = {\n            type: 'PublishEvent',\n            id: IntNumber(this.nextReqId++),\n            sessionId: this.session.id,\n            event,\n            data,\n            callWebhook,\n        };\n        return this.setOnceLinked(async () => {\n            const res = await this.makeRequest(message);\n            if (res.type === 'Fail') {\n                throw new Error(res.error || 'failed to publish event');\n            }\n            return res.eventId;\n        });\n    }\n    sendData(message) {\n        this.ws.sendData(JSON.stringify(message));\n    }\n    updateLastHeartbeat() {\n        this.lastHeartbeatResponse = Date.now();\n    }\n    heartbeat() {\n        if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n            this.ws.disconnect();\n            return;\n        }\n        try {\n            this.ws.sendData('h');\n        }\n        catch (_a) {\n            // noop\n        }\n    }\n    async makeRequest(message, options = { timeout: REQUEST_TIMEOUT }) {\n        const reqId = message.id;\n        this.sendData(message);\n        // await server message with corresponding id\n        let timeoutId;\n        return Promise.race([\n            new Promise((_, reject) => {\n                timeoutId = window.setTimeout(() => {\n                    reject(new Error(`request ${reqId} timed out`));\n                }, options.timeout);\n            }),\n            new Promise((resolve) => {\n                this.requestResolutions.set(reqId, (m) => {\n                    clearTimeout(timeoutId); // clear the timeout\n                    resolve(m);\n                    this.requestResolutions.delete(reqId);\n                });\n            }),\n        ]);\n    }\n    async handleConnected() {\n        const res = await this.makeRequest({\n            type: 'HostSession',\n            id: IntNumber(this.nextReqId++),\n            sessionId: this.session.id,\n            sessionKey: this.session.key,\n        });\n        if (res.type === 'Fail')\n            return false;\n        this.sendData({\n            type: 'IsLinked',\n            id: IntNumber(this.nextReqId++),\n            sessionId: this.session.id,\n        });\n        this.sendData({\n            type: 'GetSessionConfig',\n            id: IntNumber(this.nextReqId++),\n            sessionId: this.session.id,\n        });\n        return true;\n    }\n}\n//# sourceMappingURL=WalletLinkConnection.js.map","import { prepend0x } from '../../../core/type/util.js';\nexport class RelayEventManager {\n    constructor() {\n        this._nextRequestId = 0;\n        this.callbacks = new Map();\n    }\n    makeRequestId() {\n        // max nextId == max int32 for compatibility with mobile\n        this._nextRequestId = (this._nextRequestId + 1) % 0x7fffffff;\n        const id = this._nextRequestId;\n        const idStr = prepend0x(id.toString(16));\n        // unlikely that this will ever be an issue, but just to be safe\n        const callback = this.callbacks.get(idStr);\n        if (callback) {\n            this.callbacks.delete(idStr);\n        }\n        return id;\n    }\n}\n//# sourceMappingURL=RelayEventManager.js.map","// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>\nimport { sha256 } from '@noble/hashes/sha256';\nimport { bytesToHex } from '@noble/hashes/utils';\nimport { randomBytesHex } from '../../../../core/type/util.js';\nconst STORAGE_KEY_SESSION_ID = 'session:id';\nconst STORAGE_KEY_SESSION_SECRET = 'session:secret';\nconst STORAGE_KEY_SESSION_LINKED = 'session:linked';\nexport class WalletLinkSession {\n    constructor(storage, id, secret, linked = false) {\n        this.storage = storage;\n        this.id = id;\n        this.secret = secret;\n        this.key = bytesToHex(sha256(`${id}, ${secret} WalletLink`));\n        this._linked = !!linked;\n    }\n    static create(storage) {\n        const id = randomBytesHex(16);\n        const secret = randomBytesHex(32);\n        return new WalletLinkSession(storage, id, secret).save();\n    }\n    static load(storage) {\n        const id = storage.getItem(STORAGE_KEY_SESSION_ID);\n        const linked = storage.getItem(STORAGE_KEY_SESSION_LINKED);\n        const secret = storage.getItem(STORAGE_KEY_SESSION_SECRET);\n        if (id && secret) {\n            return new WalletLinkSession(storage, id, secret, linked === '1');\n        }\n        return null;\n    }\n    get linked() {\n        return this._linked;\n    }\n    set linked(val) {\n        this._linked = val;\n        this.persistLinked();\n    }\n    save() {\n        this.storage.setItem(STORAGE_KEY_SESSION_ID, this.id);\n        this.storage.setItem(STORAGE_KEY_SESSION_SECRET, this.secret);\n        this.persistLinked();\n        return this;\n    }\n    persistLinked() {\n        this.storage.setItem(STORAGE_KEY_SESSION_LINKED, this._linked ? '1' : '0');\n    }\n}\n//# sourceMappingURL=WalletLinkSession.js.map","export function createQrUrl(sessionId, sessionSecret, serverUrl, isParentConnection, version, chainId) {\n    const sessionIdKey = isParentConnection ? 'parent-id' : 'id';\n    const query = new URLSearchParams({\n        [sessionIdKey]: sessionId,\n        secret: sessionSecret,\n        server: serverUrl,\n        v: version,\n        chainId: chainId.toString(),\n    }).toString();\n    const qrUrl = `${serverUrl}/#/link?${query}`;\n    return qrUrl;\n}\nfunction isInIFrame() {\n    try {\n        return window.frameElement !== null;\n    }\n    catch (e) {\n        return false;\n    }\n}\nexport function getLocation() {\n    try {\n        if (isInIFrame() && window.top) {\n            return window.top.location;\n        }\n        return window.location;\n    }\n    catch (e) {\n        return window.location;\n    }\n}\nexport function isMobileWeb() {\n    var _a;\n    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test((_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent);\n}\nexport function isDarkMode() {\n    var _a, _b;\n    return (_b = (_a = window === null || window === void 0 ? void 0 : window.matchMedia) === null || _a === void 0 ? void 0 : _a.call(window, '(prefers-color-scheme: dark)').matches) !== null && _b !== void 0 ? _b : false;\n}\n//# sourceMappingURL=util.js.map","export default (() => `@namespace svg \"http://www.w3.org/2000/svg\";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",\"Helvetica Neue\",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:\"\\\\201C\" \"\\\\201D\" \"\\\\2018\" \"\\\\2019\";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",\"Helvetica Neue\",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}`)();\n//# sourceMappingURL=cssReset-css.js.map","// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>\nimport css from './cssReset-css.js';\nexport function injectCssReset() {\n    const styleEl = document.createElement('style');\n    styleEl.type = 'text/css';\n    styleEl.appendChild(document.createTextNode(css));\n    document.documentElement.appendChild(styleEl);\n}\n//# sourceMappingURL=cssReset.js.map","var n,l,u,t,i,o,r,f,e,c,s,a,h={},v=[],p=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,y=Array.isArray;function d(n,l){for(var u in l)n[u]=l[u];return n}function w(n){n&&n.parentNode&&n.parentNode.removeChild(n)}function _(l,u,t){var i,o,r,f={};for(r in u)\"key\"==r?i=u[r]:\"ref\"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):t),\"function\"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return g(l,f,i,o,null)}function g(n,t,i,o,r){var f={type:n,props:t,key:i,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:null==r?++u:r,__i:-1,__u:0};return null==r&&null!=l.vnode&&l.vnode(f),f}function m(){return{current:null}}function b(n){return n.children}function k(n,l){this.props=n,this.context=l}function x(n,l){if(null==l)return n.__?x(n.__,n.__i+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return\"function\"==typeof n.type?x(n):null}function C(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return C(n)}}function S(n){(!n.__d&&(n.__d=!0)&&i.push(n)&&!M.__r++||o!==l.debounceRendering)&&((o=l.debounceRendering)||r)(M)}function M(){var n,u,t,o,r,e,c,s;for(i.sort(f);n=i.shift();)n.__d&&(u=i.length,o=void 0,e=(r=(t=n).__v).__e,c=[],s=[],t.__P&&((o=d({},r)).__v=r.__v+1,l.vnode&&l.vnode(o),O(t.__P,o,r,t.__n,t.__P.namespaceURI,32&r.__u?[e]:null,c,null==e?x(r):e,!!(32&r.__u),s),o.__v=r.__v,o.__.__k[o.__i]=o,j(c,o,s),o.__e!=e&&C(o)),i.length>u&&i.sort(f));M.__r=0}function P(n,l,u,t,i,o,r,f,e,c,s){var a,p,y,d,w,_=t&&t.__k||v,g=l.length;for(u.__d=e,$(u,l,_),e=u.__d,a=0;a<g;a++)null!=(y=u.__k[a])&&(p=-1===y.__i?h:_[y.__i]||h,y.__i=a,O(n,y,p,i,o,r,f,e,c,s),d=y.__e,y.ref&&p.ref!=y.ref&&(p.ref&&N(p.ref,null,y),s.push(y.ref,y.__c||d,y)),null==w&&null!=d&&(w=d),65536&y.__u||p.__k===y.__k?e=I(y,e,n):\"function\"==typeof y.type&&void 0!==y.__d?e=y.__d:d&&(e=d.nextSibling),y.__d=void 0,y.__u&=-196609);u.__d=e,u.__e=w}function $(n,l,u){var t,i,o,r,f,e=l.length,c=u.length,s=c,a=0;for(n.__k=[],t=0;t<e;t++)null!=(i=l[t])&&\"boolean\"!=typeof i&&\"function\"!=typeof i?(r=t+a,(i=n.__k[t]=\"string\"==typeof i||\"number\"==typeof i||\"bigint\"==typeof i||i.constructor==String?g(null,i,null,null,null):y(i)?g(b,{children:i},null,null,null):void 0===i.constructor&&i.__b>0?g(i.type,i.props,i.key,i.ref?i.ref:null,i.__v):i).__=n,i.__b=n.__b+1,o=null,-1!==(f=i.__i=L(i,u,r,s))&&(s--,(o=u[f])&&(o.__u|=131072)),null==o||null===o.__v?(-1==f&&a--,\"function\"!=typeof i.type&&(i.__u|=65536)):f!==r&&(f==r-1?a--:f==r+1?a++:(f>r?a--:a++,i.__u|=65536))):i=n.__k[t]=null;if(s)for(t=0;t<c;t++)null!=(o=u[t])&&0==(131072&o.__u)&&(o.__e==n.__d&&(n.__d=x(o)),V(o,o))}function I(n,l,u){var t,i;if(\"function\"==typeof n.type){for(t=n.__k,i=0;t&&i<t.length;i++)t[i]&&(t[i].__=n,l=I(t[i],l,u));return l}n.__e!=l&&(l&&n.type&&!u.contains(l)&&(l=x(n)),u.insertBefore(n.__e,l||null),l=n.__e);do{l=l&&l.nextSibling}while(null!=l&&8===l.nodeType);return l}function H(n,l){return l=l||[],null==n||\"boolean\"==typeof n||(y(n)?n.some(function(n){H(n,l)}):l.push(n)),l}function L(n,l,u,t){var i=n.key,o=n.type,r=u-1,f=u+1,e=l[u];if(null===e||e&&i==e.key&&o===e.type&&0==(131072&e.__u))return u;if(t>(null!=e&&0==(131072&e.__u)?1:0))for(;r>=0||f<l.length;){if(r>=0){if((e=l[r])&&0==(131072&e.__u)&&i==e.key&&o===e.type)return r;r--}if(f<l.length){if((e=l[f])&&0==(131072&e.__u)&&i==e.key&&o===e.type)return f;f++}}return-1}function T(n,l,u){\"-\"===l[0]?n.setProperty(l,null==u?\"\":u):n[l]=null==u?\"\":\"number\"!=typeof u||p.test(l)?u:u+\"px\"}function A(n,l,u,t,i){var o;n:if(\"style\"===l)if(\"string\"==typeof u)n.style.cssText=u;else{if(\"string\"==typeof t&&(n.style.cssText=t=\"\"),t)for(l in t)u&&l in u||T(n.style,l,\"\");if(u)for(l in u)t&&u[l]===t[l]||T(n.style,l,u[l])}else if(\"o\"===l[0]&&\"n\"===l[1])o=l!==(l=l.replace(/(PointerCapture)$|Capture$/i,\"$1\")),l=l.toLowerCase()in n||\"onFocusOut\"===l||\"onFocusIn\"===l?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?t?u.u=t.u:(u.u=e,n.addEventListener(l,o?s:c,o)):n.removeEventListener(l,o?s:c,o);else{if(\"http://www.w3.org/2000/svg\"==i)l=l.replace(/xlink(H|:h)/,\"h\").replace(/sName$/,\"s\");else if(\"width\"!=l&&\"height\"!=l&&\"href\"!=l&&\"list\"!=l&&\"form\"!=l&&\"tabIndex\"!=l&&\"download\"!=l&&\"rowSpan\"!=l&&\"colSpan\"!=l&&\"role\"!=l&&\"popover\"!=l&&l in n)try{n[l]=null==u?\"\":u;break n}catch(n){}\"function\"==typeof u||(null==u||!1===u&&\"-\"!==l[4]?n.removeAttribute(l):n.setAttribute(l,\"popover\"==l&&1==u?\"\":u))}}function F(n){return function(u){if(this.l){var t=this.l[u.type+n];if(null==u.t)u.t=e++;else if(u.t<t.u)return;return t(l.event?l.event(u):u)}}}function O(n,u,t,i,o,r,f,e,c,s){var a,h,v,p,w,_,g,m,x,C,S,M,$,I,H,L,T=u.type;if(void 0!==u.constructor)return null;128&t.__u&&(c=!!(32&t.__u),r=[e=u.__e=t.__e]),(a=l.__b)&&a(u);n:if(\"function\"==typeof T)try{if(m=u.props,x=\"prototype\"in T&&T.prototype.render,C=(a=T.contextType)&&i[a.__c],S=a?C?C.props.value:a.__:i,t.__c?g=(h=u.__c=t.__c).__=h.__E:(x?u.__c=h=new T(m,S):(u.__c=h=new k(m,S),h.constructor=T,h.render=q),C&&C.sub(h),h.props=m,h.state||(h.state={}),h.context=S,h.__n=i,v=h.__d=!0,h.__h=[],h._sb=[]),x&&null==h.__s&&(h.__s=h.state),x&&null!=T.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=d({},h.__s)),d(h.__s,T.getDerivedStateFromProps(m,h.__s))),p=h.props,w=h.state,h.__v=u,v)x&&null==T.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),x&&null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(x&&null==T.getDerivedStateFromProps&&m!==p&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(m,S),!h.__e&&(null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(m,h.__s,S)||u.__v===t.__v)){for(u.__v!==t.__v&&(h.props=m,h.state=h.__s,h.__d=!1),u.__e=t.__e,u.__k=t.__k,u.__k.some(function(n){n&&(n.__=u)}),M=0;M<h._sb.length;M++)h.__h.push(h._sb[M]);h._sb=[],h.__h.length&&f.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(m,h.__s,S),x&&null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(p,w,_)})}if(h.context=S,h.props=m,h.__P=n,h.__e=!1,$=l.__r,I=0,x){for(h.state=h.__s,h.__d=!1,$&&$(u),a=h.render(h.props,h.state,h.context),H=0;H<h._sb.length;H++)h.__h.push(h._sb[H]);h._sb=[]}else do{h.__d=!1,$&&$(u),a=h.render(h.props,h.state,h.context),h.state=h.__s}while(h.__d&&++I<25);h.state=h.__s,null!=h.getChildContext&&(i=d(d({},i),h.getChildContext())),x&&!v&&null!=h.getSnapshotBeforeUpdate&&(_=h.getSnapshotBeforeUpdate(p,w)),P(n,y(L=null!=a&&a.type===b&&null==a.key?a.props.children:a)?L:[L],u,t,i,o,r,f,e,c,s),h.base=u.__e,u.__u&=-161,h.__h.length&&f.push(h),g&&(h.__E=h.__=null)}catch(n){if(u.__v=null,c||null!=r){for(u.__u|=c?160:128;e&&8===e.nodeType&&e.nextSibling;)e=e.nextSibling;r[r.indexOf(e)]=null,u.__e=e}else u.__e=t.__e,u.__k=t.__k;l.__e(n,u,t)}else null==r&&u.__v===t.__v?(u.__k=t.__k,u.__e=t.__e):u.__e=z(t.__e,u,t,i,o,r,f,c,s);(a=l.diffed)&&a(u)}function j(n,u,t){u.__d=void 0;for(var i=0;i<t.length;i++)N(t[i],t[++i],t[++i]);l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function z(u,t,i,o,r,f,e,c,s){var a,v,p,d,_,g,m,b=i.props,k=t.props,C=t.type;if(\"svg\"===C?r=\"http://www.w3.org/2000/svg\":\"math\"===C?r=\"http://www.w3.org/1998/Math/MathML\":r||(r=\"http://www.w3.org/1999/xhtml\"),null!=f)for(a=0;a<f.length;a++)if((_=f[a])&&\"setAttribute\"in _==!!C&&(C?_.localName===C:3===_.nodeType)){u=_,f[a]=null;break}if(null==u){if(null===C)return document.createTextNode(k);u=document.createElementNS(r,C,k.is&&k),c&&(l.__m&&l.__m(t,f),c=!1),f=null}if(null===C)b===k||c&&u.data===k||(u.data=k);else{if(f=f&&n.call(u.childNodes),b=i.props||h,!c&&null!=f)for(b={},a=0;a<u.attributes.length;a++)b[(_=u.attributes[a]).name]=_.value;for(a in b)if(_=b[a],\"children\"==a);else if(\"dangerouslySetInnerHTML\"==a)p=_;else if(!(a in k)){if(\"value\"==a&&\"defaultValue\"in k||\"checked\"==a&&\"defaultChecked\"in k)continue;A(u,a,null,_,r)}for(a in k)_=k[a],\"children\"==a?d=_:\"dangerouslySetInnerHTML\"==a?v=_:\"value\"==a?g=_:\"checked\"==a?m=_:c&&\"function\"!=typeof _||b[a]===_||A(u,a,_,b[a],r);if(v)c||p&&(v.__html===p.__html||v.__html===u.innerHTML)||(u.innerHTML=v.__html),t.__k=[];else if(p&&(u.innerHTML=\"\"),P(u,y(d)?d:[d],t,i,o,\"foreignObject\"===C?\"http://www.w3.org/1999/xhtml\":r,f,e,f?f[0]:i.__k&&x(i,0),c,s),null!=f)for(a=f.length;a--;)w(f[a]);c||(a=\"value\",\"progress\"===C&&null==g?u.removeAttribute(\"value\"):void 0!==g&&(g!==u[a]||\"progress\"===C&&!g||\"option\"===C&&g!==b[a])&&A(u,a,g,b[a],r),a=\"checked\",void 0!==m&&m!==u[a]&&A(u,a,m,b[a],r))}return u}function N(n,u,t){try{if(\"function\"==typeof n){var i=\"function\"==typeof n.__u;i&&n.__u(),i&&null==u||(n.__u=n(u))}else n.current=u}catch(n){l.__e(n,t)}}function V(n,u,t){var i,o;if(l.unmount&&l.unmount(n),(i=n.ref)&&(i.current&&i.current!==n.__e||N(i,null,u)),null!=(i=n.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(n){l.__e(n,u)}i.base=i.__P=null}if(i=n.__k)for(o=0;o<i.length;o++)i[o]&&V(i[o],u,t||\"function\"!=typeof n.type);t||w(n.__e),n.__c=n.__=n.__e=n.__d=void 0}function q(n,l,u){return this.constructor(n,u)}function B(u,t,i){var o,r,f,e;l.__&&l.__(u,t),r=(o=\"function\"==typeof i)?null:i&&i.__k||t.__k,f=[],e=[],O(t,u=(!o&&i||t).__k=_(b,null,[u]),r||h,h,t.namespaceURI,!o&&i?[i]:r?null:t.firstChild?n.call(t.childNodes):null,f,!o&&i?i:r?r.__e:t.firstChild,o,e),j(f,u,e)}function D(n,l){B(n,l,D)}function E(l,u,t){var i,o,r,f,e=d({},l.props);for(r in l.type&&l.type.defaultProps&&(f=l.type.defaultProps),u)\"key\"==r?i=u[r]:\"ref\"==r?o=u[r]:e[r]=void 0===u[r]&&void 0!==f?f[r]:u[r];return arguments.length>2&&(e.children=arguments.length>3?n.call(arguments,2):t),g(l.type,e,i||l.key,o||l.ref,null)}function G(n,l){var u={__c:l=\"__cC\"+a++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,t;return this.getChildContext||(u=new Set,(t={})[l]=this,this.getChildContext=function(){return t},this.componentWillUnmount=function(){u=null},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.forEach(function(n){n.__e=!0,S(n)})},this.sub=function(n){u.add(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u&&u.delete(n),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=v.slice,l={__e:function(n,l,u,t){for(var i,o,r;l=l.__;)if((i=l.__c)&&!i.__)try{if((o=i.constructor)&&null!=o.getDerivedStateFromError&&(i.setState(o.getDerivedStateFromError(n)),r=i.__d),null!=i.componentDidCatch&&(i.componentDidCatch(n,t||{}),r=i.__d),r)return i.__E=i}catch(l){n=l}throw n}},u=0,t=function(n){return null!=n&&null==n.constructor},k.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=d({},this.state),\"function\"==typeof n&&(n=n(d({},u),this.props)),n&&d(u,n),null!=n&&this.__v&&(l&&this._sb.push(l),S(this))},k.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),S(this))},k.prototype.render=b,i=[],r=\"function\"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,f=function(n,l){return n.__v.__b-l.__v.__b},M.__r=0,e=0,c=F(!1),s=F(!0),a=0;export{k as Component,b as Fragment,E as cloneElement,G as createContext,_ as createElement,m as createRef,_ as h,D as hydrate,t as isValidElement,l as options,B as render,H as toChildArray};\n//# sourceMappingURL=preact.module.js.map\n","import{options as n}from\"preact\";var t,r,u,i,o=0,f=[],c=n,e=c.__b,a=c.__r,v=c.diffed,l=c.__c,m=c.unmount,s=c.__;function d(n,t){c.__h&&c.__h(r,n,o||t),o=0;var u=r.__H||(r.__H={__:[],__h:[]});return n>=u.__.length&&u.__.push({}),u.__[n]}function h(n){return o=1,p(D,n)}function p(n,u,i){var o=d(t++,2);if(o.t=n,!o.__c&&(o.__=[i?i(u):D(void 0,u),function(n){var t=o.__N?o.__N[0]:o.__[0],r=o.t(t,n);t!==r&&(o.__N=[r,o.__[1]],o.__c.setState({}))}],o.__c=r,!r.u)){var f=function(n,t,r){if(!o.__c.__H)return!0;var u=o.__c.__H.__.filter(function(n){return!!n.__c});if(u.every(function(n){return!n.__N}))return!c||c.call(this,n,t,r);var i=!1;return u.forEach(function(n){if(n.__N){var t=n.__[0];n.__=n.__N,n.__N=void 0,t!==n.__[0]&&(i=!0)}}),!(!i&&o.__c.props===n)&&(!c||c.call(this,n,t,r))};r.u=!0;var c=r.shouldComponentUpdate,e=r.componentWillUpdate;r.componentWillUpdate=function(n,t,r){if(this.__e){var u=c;c=void 0,f(n,t,r),c=u}e&&e.call(this,n,t,r)},r.shouldComponentUpdate=f}return o.__N||o.__}function y(n,u){var i=d(t++,3);!c.__s&&C(i.__H,u)&&(i.__=n,i.i=u,r.__H.__h.push(i))}function _(n,u){var i=d(t++,4);!c.__s&&C(i.__H,u)&&(i.__=n,i.i=u,r.__h.push(i))}function A(n){return o=5,T(function(){return{current:n}},[])}function F(n,t,r){o=6,_(function(){return\"function\"==typeof n?(n(t()),function(){return n(null)}):n?(n.current=t(),function(){return n.current=null}):void 0},null==r?r:r.concat(n))}function T(n,r){var u=d(t++,7);return C(u.__H,r)&&(u.__=n(),u.__H=r,u.__h=n),u.__}function q(n,t){return o=8,T(function(){return n},t)}function x(n){var u=r.context[n.__c],i=d(t++,9);return i.c=n,u?(null==i.__&&(i.__=!0,u.sub(r)),u.props.value):n.__}function P(n,t){c.useDebugValue&&c.useDebugValue(t?t(n):n)}function b(n){var u=d(t++,10),i=h();return u.__=n,r.componentDidCatch||(r.componentDidCatch=function(n,t){u.__&&u.__(n,t),i[1](n)}),[i[0],function(){i[1](void 0)}]}function g(){var n=d(t++,11);if(!n.__){for(var u=r.__v;null!==u&&!u.__m&&null!==u.__;)u=u.__;var i=u.__m||(u.__m=[0,0]);n.__=\"P\"+i[0]+\"-\"+i[1]++}return n.__}function j(){for(var n;n=f.shift();)if(n.__P&&n.__H)try{n.__H.__h.forEach(z),n.__H.__h.forEach(B),n.__H.__h=[]}catch(t){n.__H.__h=[],c.__e(t,n.__v)}}c.__b=function(n){r=null,e&&e(n)},c.__=function(n,t){n&&t.__k&&t.__k.__m&&(n.__m=t.__k.__m),s&&s(n,t)},c.__r=function(n){a&&a(n),t=0;var i=(r=n.__c).__H;i&&(u===r?(i.__h=[],r.__h=[],i.__.forEach(function(n){n.__N&&(n.__=n.__N),n.i=n.__N=void 0})):(i.__h.forEach(z),i.__h.forEach(B),i.__h=[],t=0)),u=r},c.diffed=function(n){v&&v(n);var t=n.__c;t&&t.__H&&(t.__H.__h.length&&(1!==f.push(t)&&i===c.requestAnimationFrame||((i=c.requestAnimationFrame)||w)(j)),t.__H.__.forEach(function(n){n.i&&(n.__H=n.i),n.i=void 0})),u=r=null},c.__c=function(n,t){t.some(function(n){try{n.__h.forEach(z),n.__h=n.__h.filter(function(n){return!n.__||B(n)})}catch(r){t.some(function(n){n.__h&&(n.__h=[])}),t=[],c.__e(r,n.__v)}}),l&&l(n,t)},c.unmount=function(n){m&&m(n);var t,r=n.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{z(n)}catch(n){t=n}}),r.__H=void 0,t&&c.__e(t,r.__v))};var k=\"function\"==typeof requestAnimationFrame;function w(n){var t,r=function(){clearTimeout(u),k&&cancelAnimationFrame(t),setTimeout(n)},u=setTimeout(r,100);k&&(t=requestAnimationFrame(r))}function z(n){var t=r,u=n.__c;\"function\"==typeof u&&(n.__c=void 0,u()),r=t}function B(n){var t=r;n.__c=n.__(),r=t}function C(n,t){return!n||n.length!==t.length||t.some(function(t,r){return t!==n[r]})}function D(n,t){return\"function\"==typeof t?t(n):t}export{q as useCallback,x as useContext,P as useDebugValue,y as useEffect,b as useErrorBoundary,g as useId,F as useImperativeHandle,_ as useLayoutEffect,T as useMemo,p as useReducer,A as useRef,h as useState};\n//# sourceMappingURL=hooks.module.js.map\n","export default (() => `.-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}`)();\n//# sourceMappingURL=Snackbar-css.js.map","// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>\nimport { clsx } from 'clsx';\nimport { h, render } from 'preact';\nimport { useEffect, useState } from 'preact/hooks';\nimport { isDarkMode } from '../util.js';\nimport css from './Snackbar-css.js';\nconst cblogo = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+`;\nconst gearIcon = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=`;\nexport class Snackbar {\n    constructor() {\n        this.items = new Map();\n        this.nextItemKey = 0;\n        this.root = null;\n        this.darkMode = isDarkMode();\n    }\n    attach(el) {\n        this.root = document.createElement('div');\n        this.root.className = '-cbwsdk-snackbar-root';\n        el.appendChild(this.root);\n        this.render();\n    }\n    presentItem(itemProps) {\n        const key = this.nextItemKey++;\n        this.items.set(key, itemProps);\n        this.render();\n        return () => {\n            this.items.delete(key);\n            this.render();\n        };\n    }\n    clear() {\n        this.items.clear();\n        this.render();\n    }\n    render() {\n        if (!this.root) {\n            return;\n        }\n        render(h(\"div\", null,\n            h(SnackbarContainer, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([key, itemProps]) => (h(SnackbarInstance, Object.assign({}, itemProps, { key: key })))))), this.root);\n    }\n}\nexport const SnackbarContainer = (props) => (h(\"div\", { class: clsx('-cbwsdk-snackbar-container') },\n    h(\"style\", null, css),\n    h(\"div\", { class: \"-cbwsdk-snackbar\" }, props.children)));\nexport const SnackbarInstance = ({ autoExpand, message, menuItems, }) => {\n    const [hidden, setHidden] = useState(true);\n    const [expanded, setExpanded] = useState(autoExpand !== null && autoExpand !== void 0 ? autoExpand : false);\n    useEffect(() => {\n        const timers = [\n            window.setTimeout(() => {\n                setHidden(false);\n            }, 1),\n            window.setTimeout(() => {\n                setExpanded(true);\n            }, 10000),\n        ];\n        return () => {\n            timers.forEach(window.clearTimeout);\n        };\n    });\n    const toggleExpanded = () => {\n        setExpanded(!expanded);\n    };\n    return (h(\"div\", { class: clsx('-cbwsdk-snackbar-instance', hidden && '-cbwsdk-snackbar-instance-hidden', expanded && '-cbwsdk-snackbar-instance-expanded') },\n        h(\"div\", { class: \"-cbwsdk-snackbar-instance-header\", onClick: toggleExpanded },\n            h(\"img\", { src: cblogo, class: \"-cbwsdk-snackbar-instance-header-cblogo\" }),\n            ' ',\n            h(\"div\", { class: \"-cbwsdk-snackbar-instance-header-message\" }, message),\n            h(\"div\", { class: \"-gear-container\" },\n                !expanded && (h(\"svg\", { width: \"24\", height: \"24\", viewBox: \"0 0 24 24\", fill: \"none\", xmlns: \"http://www.w3.org/2000/svg\" },\n                    h(\"circle\", { cx: \"12\", cy: \"12\", r: \"12\", fill: \"#F5F7F8\" }))),\n                h(\"img\", { src: gearIcon, class: \"-gear-icon\", title: \"Expand\" }))),\n        menuItems && menuItems.length > 0 && (h(\"div\", { class: \"-cbwsdk-snackbar-instance-menu\" }, menuItems.map((action, i) => (h(\"div\", { class: clsx('-cbwsdk-snackbar-instance-menu-item', action.isRed && '-cbwsdk-snackbar-instance-menu-item-is-red'), onClick: action.onClick, key: i },\n            h(\"svg\", { width: action.svgWidth, height: action.svgHeight, viewBox: \"0 0 10 11\", fill: \"none\", xmlns: \"http://www.w3.org/2000/svg\" },\n                h(\"path\", { \"fill-rule\": action.defaultFillRule, \"clip-rule\": action.defaultClipRule, d: action.path, fill: \"#AAAAAA\" })),\n            h(\"span\", { class: clsx('-cbwsdk-snackbar-instance-menu-item-info', action.isRed && '-cbwsdk-snackbar-instance-menu-item-info-is-red') }, action.info))))))));\n};\n//# sourceMappingURL=Snackbar.js.map","import { injectCssReset } from './components/cssReset/cssReset.js';\nimport { Snackbar } from './components/Snackbar/Snackbar.js';\nexport class WalletLinkRelayUI {\n    constructor() {\n        this.attached = false;\n        this.snackbar = new Snackbar();\n    }\n    attach() {\n        if (this.attached) {\n            throw new Error('Coinbase Wallet SDK UI is already attached');\n        }\n        const el = document.documentElement;\n        const container = document.createElement('div');\n        container.className = '-cbwsdk-css-reset';\n        el.appendChild(container);\n        this.snackbar.attach(container);\n        this.attached = true;\n        injectCssReset();\n    }\n    showConnecting(options) {\n        let snackbarProps;\n        if (options.isUnlinkedErrorState) {\n            snackbarProps = {\n                autoExpand: true,\n                message: 'Connection lost',\n                menuItems: [\n                    {\n                        isRed: false,\n                        info: 'Reset connection',\n                        svgWidth: '10',\n                        svgHeight: '11',\n                        path: 'M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z',\n                        defaultFillRule: 'evenodd',\n                        defaultClipRule: 'evenodd',\n                        onClick: options.onResetConnection,\n                    },\n                ],\n            };\n        }\n        else {\n            snackbarProps = {\n                message: 'Confirm on phone',\n                menuItems: [\n                    {\n                        isRed: true,\n                        info: 'Cancel transaction',\n                        svgWidth: '11',\n                        svgHeight: '11',\n                        path: 'M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z',\n                        defaultFillRule: 'inherit',\n                        defaultClipRule: 'inherit',\n                        onClick: options.onCancel,\n                    },\n                    {\n                        isRed: false,\n                        info: 'Reset connection',\n                        svgWidth: '10',\n                        svgHeight: '11',\n                        path: 'M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z',\n                        defaultFillRule: 'evenodd',\n                        defaultClipRule: 'evenodd',\n                        onClick: options.onResetConnection,\n                    },\n                ],\n            };\n        }\n        return this.snackbar.presentItem(snackbarProps);\n    }\n}\n//# sourceMappingURL=WalletLinkRelayUI.js.map","export default (() => `.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop{position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s;background-color:rgba(10,11,13,.5)}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box{display:block;position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);padding:20px;border-radius:8px;background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box p{display:block;font-weight:400;font-size:14px;line-height:20px;padding-bottom:12px;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box button{appearance:none;border:none;background:none;color:#0052ff;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark{background-color:#0a0b0d;color:#fff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark button{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light{background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light button{color:#0052ff}`)();\n//# sourceMappingURL=RedirectDialog-css.js.map","import { clsx } from 'clsx';\nimport { h, render } from 'preact';\nimport { injectCssReset } from '../cssReset/cssReset.js';\nimport { SnackbarContainer } from '../Snackbar/Snackbar.js';\nimport { isDarkMode } from '../util.js';\nimport css from './RedirectDialog-css.js';\nexport class RedirectDialog {\n    constructor() {\n        this.root = null;\n        this.darkMode = isDarkMode();\n    }\n    attach() {\n        const el = document.documentElement;\n        this.root = document.createElement('div');\n        this.root.className = '-cbwsdk-css-reset';\n        el.appendChild(this.root);\n        injectCssReset();\n    }\n    present(props) {\n        this.render(props);\n    }\n    clear() {\n        this.render(null);\n    }\n    render(props) {\n        if (!this.root)\n            return;\n        render(null, this.root);\n        if (!props)\n            return;\n        render(h(RedirectDialogContent, Object.assign({}, props, { onDismiss: () => {\n                this.clear();\n            }, darkMode: this.darkMode })), this.root);\n    }\n}\nconst RedirectDialogContent = ({ title, buttonText, darkMode, onButtonClick, onDismiss }) => {\n    const theme = darkMode ? 'dark' : 'light';\n    return (h(SnackbarContainer, { darkMode: darkMode },\n        h(\"div\", { class: \"-cbwsdk-redirect-dialog\" },\n            h(\"style\", null, css),\n            h(\"div\", { class: \"-cbwsdk-redirect-dialog-backdrop\", onClick: onDismiss }),\n            h(\"div\", { class: clsx('-cbwsdk-redirect-dialog-box', theme) },\n                h(\"p\", null, title),\n                h(\"button\", { onClick: onButtonClick }, buttonText)))));\n};\n//# sourceMappingURL=RedirectDialog.js.map","export const CB_KEYS_URL = 'https://keys.coinbase.com/connect';\nexport const WALLETLINK_URL = 'https://www.walletlink.org';\nexport const CBW_MOBILE_DEEPLINK_URL = 'https://go.cb-w.com/walletlink';\n//# sourceMappingURL=constants.js.map","import { RedirectDialog } from './components/RedirectDialog/RedirectDialog.js';\nimport { getLocation } from './components/util.js';\nimport { CBW_MOBILE_DEEPLINK_URL } from '../../../../core/constants.js';\nexport class WLMobileRelayUI {\n    constructor() {\n        this.attached = false;\n        this.redirectDialog = new RedirectDialog();\n    }\n    attach() {\n        if (this.attached) {\n            throw new Error('Coinbase Wallet SDK UI is already attached');\n        }\n        this.redirectDialog.attach();\n        this.attached = true;\n    }\n    redirectToCoinbaseWallet(walletLinkUrl) {\n        const url = new URL(CBW_MOBILE_DEEPLINK_URL);\n        url.searchParams.append('redirect_url', getLocation().href);\n        if (walletLinkUrl) {\n            url.searchParams.append('wl_url', walletLinkUrl);\n        }\n        const anchorTag = document.createElement('a');\n        anchorTag.target = 'cbw-opener';\n        anchorTag.href = url.href;\n        anchorTag.rel = 'noreferrer noopener';\n        anchorTag.click();\n    }\n    openCoinbaseWalletDeeplink(walletLinkUrl) {\n        this.redirectDialog.present({\n            title: 'Redirecting to Coinbase Wallet...',\n            buttonText: 'Open',\n            onButtonClick: () => {\n                this.redirectToCoinbaseWallet(walletLinkUrl);\n            },\n        });\n        setTimeout(() => {\n            this.redirectToCoinbaseWallet(walletLinkUrl);\n        }, 99);\n    }\n    showConnecting(_options) {\n        // it uses the return callback to clear the dialog\n        return () => {\n            this.redirectDialog.clear();\n        };\n    }\n}\n//# sourceMappingURL=WLMobileRelayUI.js.map","// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>\nimport { WalletLinkConnection, } from './connection/WalletLinkConnection.js';\nimport { LOCAL_STORAGE_ADDRESSES_KEY } from './constants.js';\nimport { RelayEventManager } from './RelayEventManager.js';\nimport { WalletLinkSession } from './type/WalletLinkSession.js';\nimport { isErrorResponse } from './type/Web3Response.js';\nimport { isMobileWeb } from './ui/components/util.js';\nimport { WalletLinkRelayUI } from './ui/WalletLinkRelayUI.js';\nimport { WLMobileRelayUI } from './ui/WLMobileRelayUI.js';\nimport { standardErrors } from '../../../core/error/errors.js';\nimport { ScopedLocalStorage } from '../../../core/storage/ScopedLocalStorage.js';\nimport { bigIntStringFromBigInt, hexStringFromBuffer, randomBytesHex } from '../../../core/type/util.js';\nexport class WalletLinkRelay {\n    constructor(options) {\n        this.chainCallbackParams = { chainId: '', jsonRpcUrl: '' }; // to implement distinctUntilChanged\n        this.isMobileWeb = isMobileWeb();\n        this.linkedUpdated = (linked) => {\n            this.isLinked = linked;\n            const cachedAddresses = this.storage.getItem(LOCAL_STORAGE_ADDRESSES_KEY);\n            if (linked) {\n                // Only set linked session variable one way\n                this._session.linked = linked;\n            }\n            this.isUnlinkedErrorState = false;\n            if (cachedAddresses) {\n                const addresses = cachedAddresses.split(' ');\n                const wasConnectedViaStandalone = this.storage.getItem('IsStandaloneSigning') === 'true';\n                if (addresses[0] !== '' && !linked && this._session.linked && !wasConnectedViaStandalone) {\n                    this.isUnlinkedErrorState = true;\n                }\n            }\n        };\n        this.metadataUpdated = (key, value) => {\n            this.storage.setItem(key, value);\n        };\n        this.chainUpdated = (chainId, jsonRpcUrl) => {\n            if (this.chainCallbackParams.chainId === chainId &&\n                this.chainCallbackParams.jsonRpcUrl === jsonRpcUrl) {\n                return;\n            }\n            this.chainCallbackParams = {\n                chainId,\n                jsonRpcUrl,\n            };\n            if (this.chainCallback) {\n                this.chainCallback(jsonRpcUrl, Number.parseInt(chainId, 10));\n            }\n        };\n        this.accountUpdated = (selectedAddress) => {\n            if (this.accountsCallback) {\n                this.accountsCallback([selectedAddress]);\n            }\n            if (WalletLinkRelay.accountRequestCallbackIds.size > 0) {\n                // We get the ethereum address from the metadata.  If for whatever\n                // reason we don't get a response via an explicit web3 message\n                // we can still fulfill the eip1102 request.\n                Array.from(WalletLinkRelay.accountRequestCallbackIds.values()).forEach((id) => {\n                    this.invokeCallback(id, {\n                        method: 'requestEthereumAccounts',\n                        result: [selectedAddress],\n                    });\n                });\n                WalletLinkRelay.accountRequestCallbackIds.clear();\n            }\n        };\n        this.resetAndReload = this.resetAndReload.bind(this);\n        this.linkAPIUrl = options.linkAPIUrl;\n        this.storage = options.storage;\n        this.metadata = options.metadata;\n        this.accountsCallback = options.accountsCallback;\n        this.chainCallback = options.chainCallback;\n        const { session, ui, connection } = this.subscribe();\n        this._session = session;\n        this.connection = connection;\n        this.relayEventManager = new RelayEventManager();\n        this.ui = ui;\n        this.ui.attach();\n    }\n    subscribe() {\n        const session = WalletLinkSession.load(this.storage) || WalletLinkSession.create(this.storage);\n        const { linkAPIUrl } = this;\n        const connection = new WalletLinkConnection({\n            session,\n            linkAPIUrl,\n            listener: this,\n        });\n        const ui = this.isMobileWeb ? new WLMobileRelayUI() : new WalletLinkRelayUI();\n        connection.connect();\n        return { session, ui, connection };\n    }\n    resetAndReload() {\n        this.connection\n            .destroy()\n            .then(() => {\n            /**\n             * Only clear storage if the session id we have in memory matches the one on disk\n             * Otherwise, in the case where we have 2 tabs, another tab might have cleared\n             * storage already.  In that case if we clear storage again, the user will be in\n             * a state where the first tab allows the user to connect but the session that\n             * was used isn't persisted.  This leaves the user in a state where they aren't\n             * connected to the mobile app.\n             */\n            const storedSession = WalletLinkSession.load(this.storage);\n            if ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) === this._session.id) {\n                ScopedLocalStorage.clearAll();\n            }\n            document.location.reload();\n        })\n            .catch((_) => { });\n    }\n    signEthereumTransaction(params) {\n        return this.sendRequest({\n            method: 'signEthereumTransaction',\n            params: {\n                fromAddress: params.fromAddress,\n                toAddress: params.toAddress,\n                weiValue: bigIntStringFromBigInt(params.weiValue),\n                data: hexStringFromBuffer(params.data, true),\n                nonce: params.nonce,\n                gasPriceInWei: params.gasPriceInWei ? bigIntStringFromBigInt(params.gasPriceInWei) : null,\n                maxFeePerGas: params.gasPriceInWei ? bigIntStringFromBigInt(params.gasPriceInWei) : null,\n                maxPriorityFeePerGas: params.gasPriceInWei\n                    ? bigIntStringFromBigInt(params.gasPriceInWei)\n                    : null,\n                gasLimit: params.gasLimit ? bigIntStringFromBigInt(params.gasLimit) : null,\n                chainId: params.chainId,\n                shouldSubmit: false,\n            },\n        });\n    }\n    signAndSubmitEthereumTransaction(params) {\n        return this.sendRequest({\n            method: 'signEthereumTransaction',\n            params: {\n                fromAddress: params.fromAddress,\n                toAddress: params.toAddress,\n                weiValue: bigIntStringFromBigInt(params.weiValue),\n                data: hexStringFromBuffer(params.data, true),\n                nonce: params.nonce,\n                gasPriceInWei: params.gasPriceInWei ? bigIntStringFromBigInt(params.gasPriceInWei) : null,\n                maxFeePerGas: params.maxFeePerGas ? bigIntStringFromBigInt(params.maxFeePerGas) : null,\n                maxPriorityFeePerGas: params.maxPriorityFeePerGas\n                    ? bigIntStringFromBigInt(params.maxPriorityFeePerGas)\n                    : null,\n                gasLimit: params.gasLimit ? bigIntStringFromBigInt(params.gasLimit) : null,\n                chainId: params.chainId,\n                shouldSubmit: true,\n            },\n        });\n    }\n    submitEthereumTransaction(signedTransaction, chainId) {\n        return this.sendRequest({\n            method: 'submitEthereumTransaction',\n            params: {\n                signedTransaction: hexStringFromBuffer(signedTransaction, true),\n                chainId,\n            },\n        });\n    }\n    getWalletLinkSession() {\n        return this._session;\n    }\n    sendRequest(request) {\n        let hideSnackbarItem = null;\n        const id = randomBytesHex(8);\n        const cancel = (error) => {\n            this.publishWeb3RequestCanceledEvent(id);\n            this.handleErrorResponse(id, request.method, error);\n            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n        };\n        return new Promise((resolve, reject) => {\n            {\n                hideSnackbarItem = this.ui.showConnecting({\n                    isUnlinkedErrorState: this.isUnlinkedErrorState,\n                    onCancel: cancel,\n                    onResetConnection: this.resetAndReload, // eslint-disable-line @typescript-eslint/unbound-method\n                });\n            }\n            this.relayEventManager.callbacks.set(id, (response) => {\n                hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n                if (isErrorResponse(response)) {\n                    return reject(new Error(response.errorMessage));\n                }\n                resolve(response);\n            });\n            this.publishWeb3RequestEvent(id, request);\n        });\n    }\n    publishWeb3RequestEvent(id, request) {\n        const message = { type: 'WEB3_REQUEST', id, request };\n        this.publishEvent('Web3Request', message, true)\n            .then((_) => { })\n            .catch((err) => {\n            this.handleWeb3ResponseMessage(message.id, {\n                method: request.method,\n                errorMessage: err.message,\n            });\n        });\n        if (this.isMobileWeb) {\n            this.openCoinbaseWalletDeeplink(request.method);\n        }\n    }\n    // copied from MobileRelay\n    openCoinbaseWalletDeeplink(method) {\n        if (!(this.ui instanceof WLMobileRelayUI))\n            return;\n        // For mobile relay requests, open the Coinbase Wallet app\n        switch (method) {\n            case 'requestEthereumAccounts': // requestEthereumAccounts is handled via popup\n            case 'switchEthereumChain': // switchEthereumChain doesn't need to open the app\n                return;\n            default:\n                window.addEventListener('blur', () => {\n                    window.addEventListener('focus', () => {\n                        this.connection.checkUnseenEvents();\n                    }, { once: true });\n                }, { once: true });\n                this.ui.openCoinbaseWalletDeeplink();\n                break;\n        }\n    }\n    publishWeb3RequestCanceledEvent(id) {\n        const message = {\n            type: 'WEB3_REQUEST_CANCELED',\n            id,\n        };\n        this.publishEvent('Web3RequestCanceled', message, false).then();\n    }\n    publishEvent(event, message, callWebhook) {\n        return this.connection.publishEvent(event, message, callWebhook);\n    }\n    handleWeb3ResponseMessage(id, response) {\n        if (response.method === 'requestEthereumAccounts') {\n            WalletLinkRelay.accountRequestCallbackIds.forEach((id) => this.invokeCallback(id, response));\n            WalletLinkRelay.accountRequestCallbackIds.clear();\n            return;\n        }\n        this.invokeCallback(id, response);\n    }\n    handleErrorResponse(id, method, error) {\n        var _a;\n        const errorMessage = (_a = error === null || error === void 0 ? void 0 : error.message) !== null && _a !== void 0 ? _a : 'Unspecified error message.';\n        this.handleWeb3ResponseMessage(id, {\n            method,\n            errorMessage,\n        });\n    }\n    invokeCallback(id, response) {\n        const callback = this.relayEventManager.callbacks.get(id);\n        if (callback) {\n            callback(response);\n            this.relayEventManager.callbacks.delete(id);\n        }\n    }\n    requestEthereumAccounts() {\n        const { appName, appLogoUrl } = this.metadata;\n        const request = {\n            method: 'requestEthereumAccounts',\n            params: {\n                appName,\n                appLogoUrl,\n            },\n        };\n        const hideSnackbarItem = null;\n        const id = randomBytesHex(8);\n        return new Promise((resolve, reject) => {\n            this.relayEventManager.callbacks.set(id, (response) => {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n                if (isErrorResponse(response)) {\n                    return reject(new Error(response.errorMessage));\n                }\n                resolve(response);\n            });\n            WalletLinkRelay.accountRequestCallbackIds.add(id);\n            this.publishWeb3RequestEvent(id, request);\n        });\n    }\n    watchAsset(type, address, symbol, decimals, image, chainId) {\n        const request = {\n            method: 'watchAsset',\n            params: {\n                type,\n                options: {\n                    address,\n                    symbol,\n                    decimals,\n                    image,\n                },\n                chainId,\n            },\n        };\n        let hideSnackbarItem = null;\n        const id = randomBytesHex(8);\n        const cancel = (error) => {\n            this.publishWeb3RequestCanceledEvent(id);\n            this.handleErrorResponse(id, request.method, error);\n            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n        };\n        {\n            hideSnackbarItem = this.ui.showConnecting({\n                isUnlinkedErrorState: this.isUnlinkedErrorState,\n                onCancel: cancel,\n                onResetConnection: this.resetAndReload, // eslint-disable-line @typescript-eslint/unbound-method\n            });\n        }\n        return new Promise((resolve, reject) => {\n            this.relayEventManager.callbacks.set(id, (response) => {\n                hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n                if (isErrorResponse(response)) {\n                    return reject(new Error(response.errorMessage));\n                }\n                resolve(response);\n            });\n            this.publishWeb3RequestEvent(id, request);\n        });\n    }\n    addEthereumChain(chainId, rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency) {\n        const request = {\n            method: 'addEthereumChain',\n            params: {\n                chainId,\n                rpcUrls,\n                blockExplorerUrls,\n                chainName,\n                iconUrls,\n                nativeCurrency,\n            },\n        };\n        let hideSnackbarItem = null;\n        const id = randomBytesHex(8);\n        const cancel = (error) => {\n            this.publishWeb3RequestCanceledEvent(id);\n            this.handleErrorResponse(id, request.method, error);\n            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n        };\n        {\n            hideSnackbarItem = this.ui.showConnecting({\n                isUnlinkedErrorState: this.isUnlinkedErrorState,\n                onCancel: cancel,\n                onResetConnection: this.resetAndReload, // eslint-disable-line @typescript-eslint/unbound-method\n            });\n        }\n        return new Promise((resolve, reject) => {\n            this.relayEventManager.callbacks.set(id, (response) => {\n                hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n                if (isErrorResponse(response)) {\n                    return reject(new Error(response.errorMessage));\n                }\n                resolve(response);\n            });\n            this.publishWeb3RequestEvent(id, request);\n        });\n    }\n    switchEthereumChain(chainId, address) {\n        const request = {\n            method: 'switchEthereumChain',\n            params: Object.assign({ chainId }, { address }),\n        };\n        let hideSnackbarItem = null;\n        const id = randomBytesHex(8);\n        const cancel = (error) => {\n            this.publishWeb3RequestCanceledEvent(id);\n            this.handleErrorResponse(id, request.method, error);\n            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n        };\n        {\n            hideSnackbarItem = this.ui.showConnecting({\n                isUnlinkedErrorState: this.isUnlinkedErrorState,\n                onCancel: cancel,\n                onResetConnection: this.resetAndReload, // eslint-disable-line @typescript-eslint/unbound-method\n            });\n        }\n        return new Promise((resolve, reject) => {\n            this.relayEventManager.callbacks.set(id, (response) => {\n                hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n                if (isErrorResponse(response) && response.errorCode) {\n                    return reject(standardErrors.provider.custom({\n                        code: response.errorCode,\n                        message: `Unrecognized chain ID. Try adding the chain using addEthereumChain first.`,\n                    }));\n                }\n                else if (isErrorResponse(response)) {\n                    return reject(new Error(response.errorMessage));\n                }\n                resolve(response);\n            });\n            this.publishWeb3RequestEvent(id, request);\n        });\n    }\n}\nWalletLinkRelay.accountRequestCallbackIds = new Set();\n//# sourceMappingURL=WalletLinkRelay.js.map","// Copyright (c) 2018-2024 Coinbase, Inc. <https://www.coinbase.com/>\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\nimport eip712 from '../../vendor-js/eth-eip712-util/index.cjs';\nimport { LOCAL_STORAGE_ADDRESSES_KEY } from './relay/constants.js';\nimport { isErrorResponse } from './relay/type/Web3Response.js';\nimport { WalletLinkRelay } from './relay/WalletLinkRelay.js';\nimport { WALLETLINK_URL } from '../../core/constants.js';\nimport { standardErrors } from '../../core/error/errors.js';\nimport { ScopedLocalStorage } from '../../core/storage/ScopedLocalStorage.js';\nimport { encodeToHexString, ensureAddressString, ensureBigInt, ensureBuffer, ensureIntNumber, ensureParsedJSONObject, hexStringFromBuffer, hexStringFromNumber, } from '../../core/type/util.js';\nimport { fetchRPCRequest } from '../../util/provider.js';\nconst DEFAULT_CHAIN_ID_KEY = 'DefaultChainId';\nconst DEFAULT_JSON_RPC_URL = 'DefaultJsonRpcUrl';\n// original source: https://github.com/coinbase/coinbase-wallet-sdk/blob/v3.7.1/packages/wallet-sdk/src/provider/CoinbaseWalletProvider.ts\nexport class WalletLinkSigner {\n    constructor(options) {\n        this._relay = null;\n        this._addresses = [];\n        this.metadata = options.metadata;\n        this._storage = new ScopedLocalStorage('walletlink', WALLETLINK_URL);\n        this.callback = options.callback || null;\n        const cachedAddresses = this._storage.getItem(LOCAL_STORAGE_ADDRESSES_KEY);\n        if (cachedAddresses) {\n            const addresses = cachedAddresses.split(' ');\n            if (addresses[0] !== '') {\n                this._addresses = addresses.map((address) => ensureAddressString(address));\n            }\n        }\n        this.initializeRelay();\n    }\n    getSession() {\n        const relay = this.initializeRelay();\n        const { id, secret } = relay.getWalletLinkSession();\n        return { id, secret };\n    }\n    async handshake() {\n        await this._eth_requestAccounts();\n    }\n    get selectedAddress() {\n        return this._addresses[0] || undefined;\n    }\n    get jsonRpcUrl() {\n        var _a;\n        return (_a = this._storage.getItem(DEFAULT_JSON_RPC_URL)) !== null && _a !== void 0 ? _a : undefined;\n    }\n    set jsonRpcUrl(value) {\n        this._storage.setItem(DEFAULT_JSON_RPC_URL, value);\n    }\n    updateProviderInfo(jsonRpcUrl, chainId) {\n        var _a;\n        this.jsonRpcUrl = jsonRpcUrl;\n        // emit chainChanged event if necessary\n        const originalChainId = this.getChainId();\n        this._storage.setItem(DEFAULT_CHAIN_ID_KEY, chainId.toString(10));\n        const chainChanged = ensureIntNumber(chainId) !== originalChainId;\n        if (chainChanged) {\n            (_a = this.callback) === null || _a === void 0 ? void 0 : _a.call(this, 'chainChanged', hexStringFromNumber(chainId));\n        }\n    }\n    async watchAsset(params) {\n        const request = (Array.isArray(params) ? params[0] : params);\n        if (!request.type) {\n            throw standardErrors.rpc.invalidParams('Type is required');\n        }\n        if ((request === null || request === void 0 ? void 0 : request.type) !== 'ERC20') {\n            throw standardErrors.rpc.invalidParams(`Asset of type '${request.type}' is not supported`);\n        }\n        if (!(request === null || request === void 0 ? void 0 : request.options)) {\n            throw standardErrors.rpc.invalidParams('Options are required');\n        }\n        if (!(request === null || request === void 0 ? void 0 : request.options.address)) {\n            throw standardErrors.rpc.invalidParams('Address is required');\n        }\n        const chainId = this.getChainId();\n        const { address, symbol, image, decimals } = request.options;\n        const relay = this.initializeRelay();\n        const result = await relay.watchAsset(request.type, address, symbol, decimals, image, chainId === null || chainId === void 0 ? void 0 : chainId.toString());\n        if (isErrorResponse(result))\n            return false;\n        return !!result.result;\n    }\n    async addEthereumChain(params) {\n        var _a, _b;\n        const request = params[0];\n        if (((_a = request.rpcUrls) === null || _a === void 0 ? void 0 : _a.length) === 0) {\n            throw standardErrors.rpc.invalidParams('please pass in at least 1 rpcUrl');\n        }\n        if (!request.chainName || request.chainName.trim() === '') {\n            throw standardErrors.rpc.invalidParams('chainName is a required field');\n        }\n        if (!request.nativeCurrency) {\n            throw standardErrors.rpc.invalidParams('nativeCurrency is a required field');\n        }\n        const chainIdNumber = Number.parseInt(request.chainId, 16);\n        if (chainIdNumber === this.getChainId()) {\n            return false;\n        }\n        const relay = this.initializeRelay();\n        const { rpcUrls = [], blockExplorerUrls = [], chainName, iconUrls = [], nativeCurrency, } = request;\n        const res = await relay.addEthereumChain(chainIdNumber.toString(), rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency);\n        if (isErrorResponse(res))\n            return false;\n        if (((_b = res.result) === null || _b === void 0 ? void 0 : _b.isApproved) === true) {\n            this.updateProviderInfo(rpcUrls[0], chainIdNumber);\n            return null;\n        }\n        throw standardErrors.rpc.internal('unable to add ethereum chain');\n    }\n    async switchEthereumChain(params) {\n        const request = params[0];\n        const chainId = Number.parseInt(request.chainId, 16);\n        const relay = this.initializeRelay();\n        const res = await relay.switchEthereumChain(chainId.toString(10), this.selectedAddress || undefined);\n        if (isErrorResponse(res))\n            throw res;\n        const switchResponse = res.result;\n        if (switchResponse.isApproved && switchResponse.rpcUrl.length > 0) {\n            this.updateProviderInfo(switchResponse.rpcUrl, chainId);\n        }\n        return null;\n    }\n    async cleanup() {\n        this.callback = null;\n        if (this._relay) {\n            this._relay.resetAndReload();\n        }\n        this._storage.clear();\n    }\n    _setAddresses(addresses, _) {\n        var _a;\n        if (!Array.isArray(addresses)) {\n            throw new Error('addresses is not an array');\n        }\n        const newAddresses = addresses.map((address) => ensureAddressString(address));\n        if (JSON.stringify(newAddresses) === JSON.stringify(this._addresses)) {\n            return;\n        }\n        this._addresses = newAddresses;\n        (_a = this.callback) === null || _a === void 0 ? void 0 : _a.call(this, 'accountsChanged', newAddresses);\n        this._storage.setItem(LOCAL_STORAGE_ADDRESSES_KEY, newAddresses.join(' '));\n    }\n    async request(request) {\n        const params = request.params || [];\n        switch (request.method) {\n            case 'eth_accounts':\n                return [...this._addresses];\n            case 'eth_coinbase':\n                return this.selectedAddress || null;\n            case 'net_version':\n                return this.getChainId().toString(10);\n            case 'eth_chainId':\n                return hexStringFromNumber(this.getChainId());\n            case 'eth_requestAccounts':\n                return this._eth_requestAccounts();\n            case 'eth_ecRecover':\n            case 'personal_ecRecover':\n                return this.ecRecover(request);\n            case 'personal_sign':\n                return this.personalSign(request);\n            case 'eth_signTransaction':\n                return this._eth_signTransaction(params);\n            case 'eth_sendRawTransaction':\n                return this._eth_sendRawTransaction(params);\n            case 'eth_sendTransaction':\n                return this._eth_sendTransaction(params);\n            case 'eth_signTypedData_v1':\n            case 'eth_signTypedData_v3':\n            case 'eth_signTypedData_v4':\n            case 'eth_signTypedData':\n                return this.signTypedData(request);\n            case 'wallet_addEthereumChain':\n                return this.addEthereumChain(params);\n            case 'wallet_switchEthereumChain':\n                return this.switchEthereumChain(params);\n            case 'wallet_watchAsset':\n                return this.watchAsset(params);\n            default:\n                if (!this.jsonRpcUrl)\n                    throw standardErrors.rpc.internal('No RPC URL set for chain');\n                return fetchRPCRequest(request, this.jsonRpcUrl);\n        }\n    }\n    _ensureKnownAddress(addressString) {\n        const addressStr = ensureAddressString(addressString);\n        const lowercaseAddresses = this._addresses.map((address) => ensureAddressString(address));\n        if (!lowercaseAddresses.includes(addressStr)) {\n            throw new Error('Unknown Ethereum address');\n        }\n    }\n    _prepareTransactionParams(tx) {\n        const fromAddress = tx.from ? ensureAddressString(tx.from) : this.selectedAddress;\n        if (!fromAddress) {\n            throw new Error('Ethereum address is unavailable');\n        }\n        this._ensureKnownAddress(fromAddress);\n        const toAddress = tx.to ? ensureAddressString(tx.to) : null;\n        const weiValue = tx.value != null ? ensureBigInt(tx.value) : BigInt(0);\n        const data = tx.data ? ensureBuffer(tx.data) : Buffer.alloc(0);\n        const nonce = tx.nonce != null ? ensureIntNumber(tx.nonce) : null;\n        const gasPriceInWei = tx.gasPrice != null ? ensureBigInt(tx.gasPrice) : null;\n        const maxFeePerGas = tx.maxFeePerGas != null ? ensureBigInt(tx.maxFeePerGas) : null;\n        const maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? ensureBigInt(tx.maxPriorityFeePerGas) : null;\n        const gasLimit = tx.gas != null ? ensureBigInt(tx.gas) : null;\n        const chainId = tx.chainId ? ensureIntNumber(tx.chainId) : this.getChainId();\n        return {\n            fromAddress,\n            toAddress,\n            weiValue,\n            data,\n            nonce,\n            gasPriceInWei,\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n            gasLimit,\n            chainId,\n        };\n    }\n    async ecRecover(request) {\n        const { method, params } = request;\n        if (!Array.isArray(params))\n            throw standardErrors.rpc.invalidParams();\n        const relay = this.initializeRelay();\n        const res = await relay.sendRequest({\n            method: 'ethereumAddressFromSignedMessage',\n            params: {\n                message: encodeToHexString(params[0]),\n                signature: encodeToHexString(params[1]),\n                addPrefix: method === 'personal_ecRecover',\n            },\n        });\n        if (isErrorResponse(res))\n            throw res;\n        return res.result;\n    }\n    getChainId() {\n        var _a;\n        return Number.parseInt((_a = this._storage.getItem(DEFAULT_CHAIN_ID_KEY)) !== null && _a !== void 0 ? _a : '1', 10);\n    }\n    async _eth_requestAccounts() {\n        var _a, _b;\n        if (this._addresses.length > 0) {\n            (_a = this.callback) === null || _a === void 0 ? void 0 : _a.call(this, 'connect', { chainId: hexStringFromNumber(this.getChainId()) });\n            return this._addresses;\n        }\n        const relay = this.initializeRelay();\n        const res = await relay.requestEthereumAccounts();\n        if (isErrorResponse(res))\n            throw res;\n        if (!res.result) {\n            throw new Error('accounts received is empty');\n        }\n        this._setAddresses(res.result);\n        (_b = this.callback) === null || _b === void 0 ? void 0 : _b.call(this, 'connect', { chainId: hexStringFromNumber(this.getChainId()) });\n        return this._addresses;\n    }\n    async personalSign({ params }) {\n        if (!Array.isArray(params))\n            throw standardErrors.rpc.invalidParams();\n        const address = params[1];\n        const rawData = params[0];\n        this._ensureKnownAddress(address);\n        const relay = this.initializeRelay();\n        const res = await relay.sendRequest({\n            method: 'signEthereumMessage',\n            params: {\n                address: ensureAddressString(address),\n                message: encodeToHexString(rawData),\n                addPrefix: true,\n                typedDataJson: null,\n            },\n        });\n        if (isErrorResponse(res))\n            throw res;\n        return res.result;\n    }\n    async _eth_signTransaction(params) {\n        const tx = this._prepareTransactionParams(params[0] || {});\n        const relay = this.initializeRelay();\n        const res = await relay.signEthereumTransaction(tx);\n        if (isErrorResponse(res))\n            throw res;\n        return res.result;\n    }\n    async _eth_sendRawTransaction(params) {\n        const signedTransaction = ensureBuffer(params[0]);\n        const relay = this.initializeRelay();\n        const res = await relay.submitEthereumTransaction(signedTransaction, this.getChainId());\n        if (isErrorResponse(res))\n            throw res;\n        return res.result;\n    }\n    async _eth_sendTransaction(params) {\n        const tx = this._prepareTransactionParams(params[0] || {});\n        const relay = this.initializeRelay();\n        const res = await relay.signAndSubmitEthereumTransaction(tx);\n        if (isErrorResponse(res))\n            throw res;\n        return res.result;\n    }\n    async signTypedData(request) {\n        const { method, params } = request;\n        if (!Array.isArray(params))\n            throw standardErrors.rpc.invalidParams();\n        const encode = (input) => {\n            const hashFuncMap = {\n                eth_signTypedData_v1: eip712.hashForSignTypedDataLegacy,\n                eth_signTypedData_v3: eip712.hashForSignTypedData_v3,\n                eth_signTypedData_v4: eip712.hashForSignTypedData_v4,\n                eth_signTypedData: eip712.hashForSignTypedData_v4,\n            };\n            return hexStringFromBuffer(hashFuncMap[method]({\n                data: ensureParsedJSONObject(input),\n            }), true);\n        };\n        const address = params[method === 'eth_signTypedData_v1' ? 1 : 0];\n        const rawData = params[method === 'eth_signTypedData_v1' ? 0 : 1];\n        this._ensureKnownAddress(address);\n        const relay = this.initializeRelay();\n        const res = await relay.sendRequest({\n            method: 'signEthereumMessage',\n            params: {\n                address: ensureAddressString(address),\n                message: encode(rawData),\n                typedDataJson: JSON.stringify(rawData, null, 2),\n                addPrefix: false,\n            },\n        });\n        if (isErrorResponse(res))\n            throw res;\n        return res.result;\n    }\n    initializeRelay() {\n        if (!this._relay) {\n            this._relay = new WalletLinkRelay({\n                linkAPIUrl: WALLETLINK_URL,\n                storage: this._storage,\n                metadata: this.metadata,\n                accountsCallback: this._setAddresses.bind(this),\n                chainCallback: this.updateProviderInfo.bind(this),\n            });\n        }\n        return this._relay;\n    }\n}\n//# sourceMappingURL=WalletLinkSigner.js.map","import { SCWSigner } from './scw/SCWSigner.js';\nimport { WalletLinkSigner } from './walletlink/WalletLinkSigner.js';\nimport { ScopedLocalStorage } from '../core/storage/ScopedLocalStorage.js';\nconst SIGNER_TYPE_KEY = 'SignerType';\nconst storage = new ScopedLocalStorage('CBWSDK', 'SignerConfigurator');\nexport function loadSignerType() {\n    return storage.getItem(SIGNER_TYPE_KEY);\n}\nexport function storeSignerType(signerType) {\n    storage.setItem(SIGNER_TYPE_KEY, signerType);\n}\nexport async function fetchSignerType(params) {\n    const { communicator, metadata, handshakeRequest, callback } = params;\n    listenForWalletLinkSessionRequest(communicator, metadata, callback).catch(() => { });\n    const request = {\n        id: crypto.randomUUID(),\n        event: 'selectSignerType',\n        data: Object.assign(Object.assign({}, params.preference), { handshakeRequest }),\n    };\n    const { data } = await communicator.postRequestAndWaitForResponse(request);\n    return data;\n}\nexport function createSigner(params) {\n    const { signerType, metadata, communicator, callback } = params;\n    switch (signerType) {\n        case 'scw': {\n            return new SCWSigner({\n                metadata,\n                callback,\n                communicator,\n            });\n        }\n        case 'walletlink': {\n            return new WalletLinkSigner({\n                metadata,\n                callback,\n            });\n        }\n    }\n}\nasync function listenForWalletLinkSessionRequest(communicator, metadata, callback) {\n    await communicator.onMessage(({ event }) => event === 'WalletLinkSessionRequest');\n    // temporary walletlink signer instance to handle WalletLinkSessionRequest\n    // will revisit this when refactoring the walletlink signer\n    const walletlink = new WalletLinkSigner({\n        metadata,\n        callback,\n    });\n    // send wallet link session to popup\n    communicator.postMessage({\n        event: 'WalletLinkUpdate',\n        data: { session: walletlink.getSession() },\n    });\n    // wait for handshake to complete\n    await walletlink.handshake();\n    // send connected status to popup\n    communicator.postMessage({\n        event: 'WalletLinkUpdate',\n        data: { connected: true },\n    });\n}\n//# sourceMappingURL=util.js.map","const COOP_ERROR_MESSAGE = `Coinbase Wallet SDK requires the Cross-Origin-Opener-Policy header to not be set to 'same-origin'. This is to ensure that the SDK can communicate with the Coinbase Smart Wallet app.\n\nPlease see https://www.smartwallet.dev/guides/tips/popup-tips#cross-origin-opener-policy for more information.`;\n/**\n * Creates a checker for the Cross-Origin-Opener-Policy (COOP).\n *\n * @returns An object with methods to get and check the Cross-Origin-Opener-Policy.\n *\n * @method getCrossOriginOpenerPolicy\n * Retrieves current Cross-Origin-Opener-Policy.\n * @throws Will throw an error if the policy has not been checked yet.\n *\n * @method checkCrossOriginOpenerPolicy\n * Checks the Cross-Origin-Opener-Policy of the current environment.\n * If in a non-browser environment, sets the policy to 'non-browser-env'.\n * If in a browser environment, fetches the policy from the current origin.\n * Logs an error if the policy is 'same-origin'.\n */\nconst createCoopChecker = () => {\n    let crossOriginOpenerPolicy;\n    return {\n        getCrossOriginOpenerPolicy: () => {\n            if (crossOriginOpenerPolicy === undefined) {\n                return 'undefined';\n            }\n            return crossOriginOpenerPolicy;\n        },\n        checkCrossOriginOpenerPolicy: async () => {\n            if (typeof window === 'undefined') {\n                // Non-browser environment\n                crossOriginOpenerPolicy = 'non-browser-env';\n                return;\n            }\n            try {\n                const url = `${window.location.origin}${window.location.pathname}`;\n                const response = await fetch(url, {\n                    method: 'HEAD',\n                });\n                if (!response.ok) {\n                    throw new Error(`HTTP error! status: ${response.status}`);\n                }\n                const result = response.headers.get('Cross-Origin-Opener-Policy');\n                crossOriginOpenerPolicy = result !== null && result !== void 0 ? result : 'null';\n                if (crossOriginOpenerPolicy === 'same-origin') {\n                    console.error(COOP_ERROR_MESSAGE);\n                }\n            }\n            catch (error) {\n                console.error('Error checking Cross-Origin-Opener-Policy:', error.message);\n                crossOriginOpenerPolicy = 'error';\n            }\n        },\n    };\n};\nexport const { checkCrossOriginOpenerPolicy, getCrossOriginOpenerPolicy } = createCoopChecker();\n//# sourceMappingURL=checkCrossOriginOpenerPolicy.js.map","import { NAME, VERSION } from '../sdk-info.js';\nimport { getCrossOriginOpenerPolicy } from './checkCrossOriginOpenerPolicy.js';\nimport { standardErrors } from '../core/error/errors.js';\nconst POPUP_WIDTH = 420;\nconst POPUP_HEIGHT = 540;\n// Window Management\nexport function openPopup(url) {\n    const left = (window.innerWidth - POPUP_WIDTH) / 2 + window.screenX;\n    const top = (window.innerHeight - POPUP_HEIGHT) / 2 + window.screenY;\n    appendAppInfoQueryParams(url);\n    const popup = window.open(url, 'Smart Wallet', `width=${POPUP_WIDTH}, height=${POPUP_HEIGHT}, left=${left}, top=${top}`);\n    popup === null || popup === void 0 ? void 0 : popup.focus();\n    if (!popup) {\n        throw standardErrors.rpc.internal('Pop up window failed to open');\n    }\n    return popup;\n}\nexport function closePopup(popup) {\n    if (popup && !popup.closed) {\n        popup.close();\n    }\n}\nfunction appendAppInfoQueryParams(url) {\n    const params = {\n        sdkName: NAME,\n        sdkVersion: VERSION,\n        origin: window.location.origin,\n        coop: getCrossOriginOpenerPolicy(),\n    };\n    for (const [key, value] of Object.entries(params)) {\n        url.searchParams.append(key, value.toString());\n    }\n}\n//# sourceMappingURL=web.js.map","import { VERSION } from '../../sdk-info.js';\nimport { CB_KEYS_URL } from '../constants.js';\nimport { standardErrors } from '../error/errors.js';\nimport { closePopup, openPopup } from '../../util/web.js';\n/**\n * Communicates with a popup window for Coinbase keys.coinbase.com (or another url)\n * to send and receive messages.\n *\n * This class is responsible for opening a popup window, posting messages to it,\n * and listening for responses.\n *\n * It also handles cleanup of event listeners and the popup window itself when necessary.\n */\nexport class Communicator {\n    constructor({ url = CB_KEYS_URL, metadata, preference }) {\n        this.popup = null;\n        this.listeners = new Map();\n        /**\n         * Posts a message to the popup window\n         */\n        this.postMessage = async (message) => {\n            const popup = await this.waitForPopupLoaded();\n            popup.postMessage(message, this.url.origin);\n        };\n        /**\n         * Posts a request to the popup window and waits for a response\n         */\n        this.postRequestAndWaitForResponse = async (request) => {\n            const responsePromise = this.onMessage(({ requestId }) => requestId === request.id);\n            this.postMessage(request);\n            return await responsePromise;\n        };\n        /**\n         * Listens for messages from the popup window that match a given predicate.\n         */\n        this.onMessage = async (predicate) => {\n            return new Promise((resolve, reject) => {\n                const listener = (event) => {\n                    if (event.origin !== this.url.origin)\n                        return; // origin validation\n                    const message = event.data;\n                    if (predicate(message)) {\n                        resolve(message);\n                        window.removeEventListener('message', listener);\n                        this.listeners.delete(listener);\n                    }\n                };\n                window.addEventListener('message', listener);\n                this.listeners.set(listener, { reject });\n            });\n        };\n        /**\n         * Closes the popup, rejects all requests and clears the listeners\n         */\n        this.disconnect = () => {\n            // Note: keys popup handles closing itself. this is a fallback.\n            closePopup(this.popup);\n            this.popup = null;\n            this.listeners.forEach(({ reject }, listener) => {\n                reject(standardErrors.provider.userRejectedRequest('Request rejected'));\n                window.removeEventListener('message', listener);\n            });\n            this.listeners.clear();\n        };\n        /**\n         * Waits for the popup window to fully load and then sends a version message.\n         */\n        this.waitForPopupLoaded = async () => {\n            if (this.popup && !this.popup.closed) {\n                // In case the user un-focused the popup between requests, focus it again\n                this.popup.focus();\n                return this.popup;\n            }\n            this.popup = openPopup(this.url);\n            this.onMessage(({ event }) => event === 'PopupUnload')\n                .then(this.disconnect)\n                .catch(() => { });\n            return this.onMessage(({ event }) => event === 'PopupLoaded')\n                .then((message) => {\n                this.postMessage({\n                    requestId: message.id,\n                    data: {\n                        version: VERSION,\n                        metadata: this.metadata,\n                        preference: this.preference,\n                        location: window.location.toString(),\n                    },\n                });\n            })\n                .then(() => {\n                if (!this.popup)\n                    throw standardErrors.rpc.internal();\n                return this.popup;\n            });\n        };\n        this.url = new URL(url);\n        this.metadata = metadata;\n        this.preference = preference;\n    }\n}\n//# sourceMappingURL=Communicator.js.map","// TODO: error should not depend on walletlink. revisit this.\nimport { VERSION } from '../../sdk-info.js';\nimport { isErrorResponse } from '../../sign/walletlink/relay/type/Web3Response.js';\nimport { standardErrorCodes } from './constants.js';\nimport { serialize } from './utils.js';\n/**\n * Serializes an error to a format that is compatible with the Ethereum JSON RPC error format.\n * See https://docs.cloud.coinbase.com/wallet-sdk/docs/errors\n * for more information.\n */\nexport function serializeError(error) {\n    const serialized = serialize(getErrorObject(error), {\n        shouldIncludeStack: true,\n    });\n    const docUrl = new URL('https://docs.cloud.coinbase.com/wallet-sdk/docs/errors');\n    docUrl.searchParams.set('version', VERSION);\n    docUrl.searchParams.set('code', serialized.code.toString());\n    docUrl.searchParams.set('message', serialized.message);\n    return Object.assign(Object.assign({}, serialized), { docUrl: docUrl.href });\n}\n/**\n * Converts an error to a serializable object.\n */\nfunction getErrorObject(error) {\n    var _a;\n    if (typeof error === 'string') {\n        return {\n            message: error,\n            code: standardErrorCodes.rpc.internal,\n        };\n    }\n    else if (isErrorResponse(error)) {\n        const message = error.errorMessage;\n        const code = (_a = error.errorCode) !== null && _a !== void 0 ? _a : (message.match(/(denied|rejected)/i)\n            ? standardErrorCodes.provider.userRejectedRequest\n            : undefined);\n        return Object.assign(Object.assign({}, error), { message,\n            code, data: { method: error.method } });\n    }\n    return error;\n}\n//# sourceMappingURL=serialize.js.map","import { EventEmitter } from 'eventemitter3';\nexport class ProviderEventEmitter extends EventEmitter {\n}\n//# sourceMappingURL=interface.js.map","var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { createSigner, fetchSignerType, loadSignerType, storeSignerType } from './sign/util.js';\nimport { Communicator } from './core/communicator/Communicator.js';\nimport { standardErrorCodes } from './core/error/constants.js';\nimport { standardErrors } from './core/error/errors.js';\nimport { serializeError } from './core/error/serialize.js';\nimport { ProviderEventEmitter, } from './core/provider/interface.js';\nimport { ScopedLocalStorage } from './core/storage/ScopedLocalStorage.js';\nimport { hexStringFromNumber } from './core/type/util.js';\nimport { checkErrorForInvalidRequestArgs } from './util/provider.js';\nexport class CoinbaseWalletProvider extends ProviderEventEmitter {\n    constructor(_a) {\n        var { metadata } = _a, _b = _a.preference, { keysUrl } = _b, preference = __rest(_b, [\"keysUrl\"]);\n        super();\n        this.signer = null;\n        this.isCoinbaseWallet = true;\n        this.metadata = metadata;\n        this.preference = preference;\n        this.communicator = new Communicator({\n            url: keysUrl,\n            metadata,\n            preference,\n        });\n        const signerType = loadSignerType();\n        if (signerType) {\n            this.signer = this.initSigner(signerType);\n        }\n    }\n    async request(args) {\n        try {\n            checkErrorForInvalidRequestArgs(args);\n            if (!this.signer) {\n                switch (args.method) {\n                    case 'eth_requestAccounts': {\n                        const signerType = await this.requestSignerSelection(args);\n                        const signer = this.initSigner(signerType);\n                        await signer.handshake(args);\n                        this.signer = signer;\n                        storeSignerType(signerType);\n                        break;\n                    }\n                    case 'net_version':\n                        return 1; // default value\n                    case 'eth_chainId':\n                        return hexStringFromNumber(1); // default value\n                    default: {\n                        throw standardErrors.provider.unauthorized(\"Must call 'eth_requestAccounts' before other methods\");\n                    }\n                }\n            }\n            return this.signer.request(args);\n        }\n        catch (error) {\n            const { code } = error;\n            if (code === standardErrorCodes.provider.unauthorized)\n                this.disconnect();\n            return Promise.reject(serializeError(error));\n        }\n    }\n    /** @deprecated Use `.request({ method: 'eth_requestAccounts' })` instead. */\n    async enable() {\n        console.warn(`.enable() has been deprecated. Please use .request({ method: \"eth_requestAccounts\" }) instead.`);\n        return await this.request({\n            method: 'eth_requestAccounts',\n        });\n    }\n    async disconnect() {\n        var _a;\n        await ((_a = this.signer) === null || _a === void 0 ? void 0 : _a.cleanup());\n        this.signer = null;\n        ScopedLocalStorage.clearAll();\n        this.emit('disconnect', standardErrors.provider.disconnected('User initiated disconnection'));\n    }\n    requestSignerSelection(handshakeRequest) {\n        return fetchSignerType({\n            communicator: this.communicator,\n            preference: this.preference,\n            metadata: this.metadata,\n            handshakeRequest,\n            callback: this.emit.bind(this),\n        });\n    }\n    initSigner(signerType) {\n        return createSigner({\n            signerType,\n            metadata: this.metadata,\n            communicator: this.communicator,\n            callback: this.emit.bind(this),\n        });\n    }\n}\n//# sourceMappingURL=CoinbaseWalletProvider.js.map","import { CoinbaseWalletProvider } from './CoinbaseWalletProvider.js';\nimport { getCoinbaseInjectedProvider } from './util/provider.js';\nexport function createCoinbaseWalletProvider(options) {\n    var _a;\n    const params = {\n        metadata: options.metadata,\n        preference: options.preference,\n    };\n    return (_a = getCoinbaseInjectedProvider(params)) !== null && _a !== void 0 ? _a : new CoinbaseWalletProvider(params);\n}\n//# sourceMappingURL=createCoinbaseWalletProvider.js.map","/**\n * Validates user supplied preferences. Throws if keys are not valid.\n * @param preference\n */\nexport function validatePreferences(preference) {\n    if (!preference) {\n        return;\n    }\n    if (!['all', 'smartWalletOnly', 'eoaOnly'].includes(preference.options)) {\n        throw new Error(`Invalid options: ${preference.options}`);\n    }\n    if (preference.attribution) {\n        if (preference.attribution.auto !== undefined &&\n            preference.attribution.dataSuffix !== undefined) {\n            throw new Error(`Attribution cannot contain both auto and dataSuffix properties`);\n        }\n    }\n}\n//# sourceMappingURL=validatePreferences.js.map","import { createCoinbaseWalletProvider } from './createCoinbaseWalletProvider.js';\nimport { VERSION } from './sdk-info.js';\nimport { ScopedLocalStorage } from './core/storage/ScopedLocalStorage.js';\nimport { checkCrossOriginOpenerPolicy } from './util/checkCrossOriginOpenerPolicy.js';\nimport { validatePreferences } from './util/validatePreferences.js';\nconst DEFAULT_PREFERENCE = {\n    options: 'all',\n};\n/**\n * Create a Coinbase Wallet SDK instance.\n * @param params - Options to create a Coinbase Wallet SDK instance.\n * @returns A Coinbase Wallet SDK object.\n */\nexport function createCoinbaseWalletSDK(params) {\n    var _a;\n    const versionStorage = new ScopedLocalStorage('CBWSDK');\n    versionStorage.setItem('VERSION', VERSION);\n    void checkCrossOriginOpenerPolicy();\n    const options = {\n        metadata: {\n            appName: params.appName || 'Dapp',\n            appLogoUrl: params.appLogoUrl || '',\n            appChainIds: params.appChainIds || [],\n        },\n        preference: Object.assign(DEFAULT_PREFERENCE, (_a = params.preference) !== null && _a !== void 0 ? _a : {}),\n    };\n    /**\n     * Validate user supplied preferences. Throws if key/values are not valid.\n     */\n    validatePreferences(options.preference);\n    let provider = null;\n    return {\n        getProvider: () => {\n            if (!provider) {\n                provider = createCoinbaseWalletProvider(options);\n            }\n            return provider;\n        },\n    };\n}\n//# sourceMappingURL=createCoinbaseWalletSDK.js.map","// Copyright (c) 2018-2024 Coinbase, Inc. <https://www.coinbase.com/>\nimport { CoinbaseWalletSDK } from './CoinbaseWalletSDK.js';\nexport default CoinbaseWalletSDK;\nexport { CoinbaseWalletSDK } from './CoinbaseWalletSDK.js';\nexport { createCoinbaseWalletSDK } from './createCoinbaseWalletSDK.js';\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":"","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52]}