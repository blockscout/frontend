{"version":3,"file":"static/chunks/9253.8b7755475fae5f7f.js","mappings":"6FAEA,gBACA,SACA,IACA,4BACA,UACA,cAEA,qBAA6C,KAAQ,IACrD,OAEA,kBAZA,0BAaA,EAZA,QAA4D,MAY5D,eAZ4D,gBAA2B,qGCDvF,4BACA,2BAA4D,kBAA2B,EAOvF,kBACA,uBACA,MACA,OAEA,4DACA,OACA,OACA,MAAY,iBAAmC,CAC/C,IAAU,qBACV,CACA,CAEA,uBACA,EAOA,IAJA,WACA,yBACA,OACA,IACA,6CACA,qIACA,gBARA,uBASA,CAEA,gBACA,kBACA,uBACA,CAEA,cACA,wCACA,CAEA,gBACA,aAKA,OAJA,oBACA,uBACA,0BAEA,CACA,CAEA,oBACA,EACA,EACA,SACA,WACA,WACA,QAAc,KAAc,IAC5B,SAEA,QAAc,KAAc,IAC5B,UAEA,QAAc,KAAc,IAC5B,QAAgB,KAAc,KAC9B,yBACA,yDACA,4CACA,yCAEA,CAEA,eAcA,kBACA,yDACA,SACA,SACA,yBACA,eAAmC,OAAQ,EAAG,GAE9C,uBACA,MACA,OAEA,mBACA,yCAEA,aADA,eACA,SACA,SAAgB,EAAK,KACrB,UACA,CAAK,GAEL,kDACA,SAEA,aADA,0CACA,SACA,SAAkB,OAAW,KAC7B,YACA,0BACA,CAAO,GAGP,uJACA,aAA2C,QAAY,gBACvD,gBAAkC,IAAsB,CACxD,eAAqC,OAAQ,EAAG,GAC1C,gBAAmC,IAAe,CAExD,aADA,cACA,SACA,SAAkB,OAAW,GAC7B,OACA,0BACA,CAAO,GACD,OAA4B,IAAc,CAChD,cACA,CAAU,iBAAoB,IAAc,0BAA6B,CACzE,CAAU,kBAAqB,IAAc,0BAC7C,CAEA,CACA,CAEA,gBACA,OACA,UACA,WACA,EAeA,MAdE,OAAY,OACd,uBACA,sBACM,yBACN,aAAuC,QAAe,eACtD,qBAA0C,IAAW,cACrD,EAAM,+BACN,aAAqC,QAAY,eACjD,uBAA0C,IAAsB,mBAChE,EAAM,+BACN,4CACA,8BAEA,CAAG,EACH,CACA,CAxIA,gBAaA,yBAKA,sBAIA,qBASA,oBAwBA,uBACA,GAAU,mDACV,oBACA,kBACA,WAMA,MALA,2CACA,OAAmB,GAAU,4BAC7B,KAAiB,GAAU,wBACvB,GAAU,kCAEd,CACA,CAAC,EAiDD,wBAsBA","sources":["webpack://_N_E/./node_modules/@graphiql/react/dist/forEachState.es.js","webpack://_N_E/./node_modules/@graphiql/react/dist/hint.es2.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nfunction forEachState(stack, fn) {\n  const reverseStateStack = [];\n  let state = stack;\n  while (state === null || state === void 0 ? void 0 : state.kind) {\n    reverseStateStack.push(state);\n    state = state.prevState;\n  }\n  for (let i = reverseStateStack.length - 1; i >= 0; i--) {\n    fn(reverseStateStack[i]);\n  }\n}\n__name(forEachState, \"forEachState\");\nexport { forEachState as f };\n","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { C as CodeMirror } from \"./codemirror.es.js\";\nimport { getNamedType, GraphQLInputObjectType, GraphQLEnumType, GraphQLBoolean, getNullableType, GraphQLList } from \"graphql\";\nimport { f as forEachState } from \"./forEachState.es.js\";\nimport \"./index.es.js\";\nimport \"react\";\nimport \"react-dom\";\nfunction hintList(cursor, token, list) {\n  const hints = filterAndSortList(list, normalizeText(token.string));\n  if (!hints) {\n    return;\n  }\n  const tokenStart = token.type !== null && /\"|\\w/.test(token.string[0]) ? token.start : token.end;\n  return {\n    list: hints,\n    from: { line: cursor.line, ch: tokenStart },\n    to: { line: cursor.line, ch: token.end }\n  };\n}\n__name(hintList, \"hintList\");\nfunction filterAndSortList(list, text) {\n  if (!text) {\n    return filterNonEmpty(list, (entry) => !entry.isDeprecated);\n  }\n  const byProximity = list.map((entry) => ({\n    proximity: getProximity(normalizeText(entry.text), text),\n    entry\n  }));\n  const conciseMatches = filterNonEmpty(filterNonEmpty(byProximity, (pair) => pair.proximity <= 2), (pair) => !pair.entry.isDeprecated);\n  const sortedMatches = conciseMatches.sort((a, b) => (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.text.length - b.entry.text.length);\n  return sortedMatches.map((pair) => pair.entry);\n}\n__name(filterAndSortList, \"filterAndSortList\");\nfunction filterNonEmpty(array, predicate) {\n  const filtered = array.filter(predicate);\n  return filtered.length === 0 ? array : filtered;\n}\n__name(filterNonEmpty, \"filterNonEmpty\");\nfunction normalizeText(text) {\n  return text.toLowerCase().replace(/\\W/g, \"\");\n}\n__name(normalizeText, \"normalizeText\");\nfunction getProximity(suggestion, text) {\n  let proximity = lexicalDistance(text, suggestion);\n  if (suggestion.length > text.length) {\n    proximity -= suggestion.length - text.length - 1;\n    proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;\n  }\n  return proximity;\n}\n__name(getProximity, \"getProximity\");\nfunction lexicalDistance(a, b) {\n  let i;\n  let j;\n  const d = [];\n  const aLength = a.length;\n  const bLength = b.length;\n  for (i = 0; i <= aLength; i++) {\n    d[i] = [i];\n  }\n  for (j = 1; j <= bLength; j++) {\n    d[0][j] = j;\n  }\n  for (i = 1; i <= aLength; i++) {\n    for (j = 1; j <= bLength; j++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n      }\n    }\n  }\n  return d[aLength][bLength];\n}\n__name(lexicalDistance, \"lexicalDistance\");\nCodeMirror.registerHelper(\"hint\", \"graphql-variables\", (editor, options) => {\n  const cur = editor.getCursor();\n  const token = editor.getTokenAt(cur);\n  const results = getVariablesHint(cur, token, options);\n  if ((results === null || results === void 0 ? void 0 : results.list) && results.list.length > 0) {\n    results.from = CodeMirror.Pos(results.from.line, results.from.ch);\n    results.to = CodeMirror.Pos(results.to.line, results.to.ch);\n    CodeMirror.signal(editor, \"hasCompletion\", editor, results, token);\n  }\n  return results;\n});\nfunction getVariablesHint(cur, token, options) {\n  const state = token.state.kind === \"Invalid\" ? token.state.prevState : token.state;\n  const kind = state.kind;\n  const step = state.step;\n  if (kind === \"Document\" && step === 0) {\n    return hintList(cur, token, [{ text: \"{\" }]);\n  }\n  const variableToType = options.variableToType;\n  if (!variableToType) {\n    return;\n  }\n  const typeInfo = getTypeInfo(variableToType, token.state);\n  if (kind === \"Document\" || kind === \"Variable\" && step === 0) {\n    const variableNames = Object.keys(variableToType);\n    return hintList(cur, token, variableNames.map((name) => ({\n      text: `\"${name}\": `,\n      type: variableToType[name]\n    })));\n  }\n  if (kind === \"ObjectValue\" || kind === \"ObjectField\" && step === 0) {\n    if (typeInfo.fields) {\n      const inputFields = Object.keys(typeInfo.fields).map((fieldName) => typeInfo.fields[fieldName]);\n      return hintList(cur, token, inputFields.map((field) => ({\n        text: `\"${field.name}\": `,\n        type: field.type,\n        description: field.description\n      })));\n    }\n  }\n  if (kind === \"StringValue\" || kind === \"NumberValue\" || kind === \"BooleanValue\" || kind === \"NullValue\" || kind === \"ListValue\" && step === 1 || kind === \"ObjectField\" && step === 2 || kind === \"Variable\" && step === 2) {\n    const namedInputType = typeInfo.type ? getNamedType(typeInfo.type) : void 0;\n    if (namedInputType instanceof GraphQLInputObjectType) {\n      return hintList(cur, token, [{ text: \"{\" }]);\n    } else if (namedInputType instanceof GraphQLEnumType) {\n      const values = namedInputType.getValues();\n      return hintList(cur, token, values.map((value) => ({\n        text: `\"${value.name}\"`,\n        type: namedInputType,\n        description: value.description\n      })));\n    } else if (namedInputType === GraphQLBoolean) {\n      return hintList(cur, token, [\n        { text: \"true\", type: GraphQLBoolean, description: \"Not false.\" },\n        { text: \"false\", type: GraphQLBoolean, description: \"Not true.\" }\n      ]);\n    }\n  }\n}\n__name(getVariablesHint, \"getVariablesHint\");\nfunction getTypeInfo(variableToType, tokenState) {\n  const info = {\n    type: null,\n    fields: null\n  };\n  forEachState(tokenState, (state) => {\n    if (state.kind === \"Variable\") {\n      info.type = variableToType[state.name];\n    } else if (state.kind === \"ListValue\") {\n      const nullableType = info.type ? getNullableType(info.type) : void 0;\n      info.type = nullableType instanceof GraphQLList ? nullableType.ofType : null;\n    } else if (state.kind === \"ObjectValue\") {\n      const objectType = info.type ? getNamedType(info.type) : void 0;\n      info.fields = objectType instanceof GraphQLInputObjectType ? objectType.getFields() : null;\n    } else if (state.kind === \"ObjectField\") {\n      const objectField = state.name && info.fields ? info.fields[state.name] : null;\n      info.type = objectField === null || objectField === void 0 ? void 0 : objectField.type;\n    }\n  });\n  return info;\n}\n__name(getTypeInfo, \"getTypeInfo\");\n"],"names":[],"sourceRoot":"","ignoreList":[0,1]}