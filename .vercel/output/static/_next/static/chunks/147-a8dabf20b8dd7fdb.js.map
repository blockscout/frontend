{"version":3,"file":"static/chunks/147-a8dabf20b8dd7fdb.js","mappings":"oNAmBA,EAAgB,OAAU,WAAuB,+BAAkC,IACnF,MAAiB,QAAmB,gBACpC,EAAmB,QAAgB,IACnC,WAAU,sBAAuC,QAAY,IAC7D,EAAc,aAAO,CACrB,MAAa,uBAA0C,CACvD,OAEA,MAAyB,SAAG,CAAC,IAA4B,EAAI,iBAA8C,SAAG,CAAC,IAAiB,EAAI,iBAAsC,SAAG,CAAC,IAAuB,EAAI,iBAAyC,SAAG,CACjP,GAAM,KACV,CACA,MACA,KACA,UAAiB,QAAE,iCACnB,aACA,UACA,EACA,CAAK,EAAG,EAAG,CACX,CAAC,EACD,8JC3BA,cACA,IACA,WACA,eACA,QACA,gBACA,cACA,KACA,CAAI,EACJ,CA+JA,YACA,8BACA,8CACE,QAAI,EACN,cACA,sGAA2G,SAAa,GACrH,EACH,EAtKA,GAwKE,QAAI,EACN,aAxKA,EAwKA,eAxKA,EAwKA,aACA,sLACA,CAAG,EAzKH,MAAsB,QAAuB,GAC7C,MAA0C,cAAQ,KAChD,eAAS,KACX,KACA,KACA,EACG,IACH,SAA4B,OAAoB,EAChD,QACA,iBACA,EACA,aACA,aAEA,UACA,CAAG,EAoBH,OACA,QACA,WACA,YACA,sBAvBA,IACA,gBACA,UACA,yCAcA,CAAa,kBAZb,IACA,WAEA,oBAEA,EADA,kCAEQ,EACR,KACQ,GACR,MAEA,CACa,CACb,EAMA,eACA,kBACA,aACA,CACA,CACA,SAA+C,OAAa,EAC5D,wBACA,+BACA,wBACA,CAAC,EACD,kBAgIA,EA/HA,IAAU,sCAA4C,EACtD,uBAAU,qBAAyC,IACnD,EAAoB,YAAM,OAC1B,EAAkB,WAAK,GACvB,cACA,sBAAuC,EAAI,EAC3C,qBAAqC,EAAI,EAmHvC,QAAI,EACN,aAnHA,EAmHA,4BACA;AACA,MACG,EArHH,aAAU,yBAA+B,CAAE,OAAsB,EACjE,cACA,CAAG,EACH,QAAU,cAAmB,EAC7B,eAmHA,EAjHA,QAA0B,eAAoB,CAkH5C,QAAI,EACN,mCACA,+CACA,CAAG,EA9GH,MAAkB,iBAAW,MAC7B,eACA,IACA,CAAG,YACH,EAAoB,iBAAW,CAC/B,IAmBA,OAjBA,eACA,sBACA,wBACA,CAAS,CACT,aACA,sBACA,wBACA,CAAS,CACT,UACA,sBACA,wBACA,CAAS,CACT,SACA,qBACA,wBACA,CACA,CACA,QACA,IACA,mBACA,KAEA,CAAK,CACL,OAEA,EAAkB,iBAAW,MAC7B,IACA,CAAG,QACH,EAAyB,iBAAW,CACpC,aAAwC,SACxC,OACA,KACA,cACA,IAAa,QAAS,QACtB,KACA,aACA,oBACA,kBACA,QAAiB,QAAe,cAChC,QAAiB,QAAe,cAChC,UAAmB,QAAe,eAClC,CACA,CAAK,CACL,CACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAEA,EAAwB,iBAAW,CACnC,aAAuC,SACvC,OACA,KACA,MACA,cACA,KACA,oBACA,SACA,CACA,CAAK,CACL,SAEA,OACA,SACA,aACA,cACA,OApFA,KACA,cACA,EAmFA,QAlFA,KACA,cACA,EAiFA,iBACA,gBACA,WACA,CACA,oHC/KA,MAAoD,OAAa,EACjE,8BACA,8BACA,4BACA,CAAC,EACD,MAAuD,OAAa,EACpE,4BACA,mCACA,gCACA,CAAC,EACD,CACA,EACA,EACA,EACA,EACA,CAAI,OAAuB,gGCV3B,cACA,MAAS,QAAa,CACtB,EACA,6BAAmD,EAAM,QAAQ,EAAM,EAEvE,CACA,MAAe,OAAU,eACzB,IACA,OACA,UACA,WACA,SACA,SACA,UACA,WACA,KACA,CAAI,EACJ,EAAiB,OAAO,EACxB,WACA,gBACA,aACA,kBACA,gBACA,eACA,YACA,CAAG,EACH,MAAyB,SAAG,CAAC,GAAM,MAAQ,mBAA6B,CACxE,CAAC,EACD,0EC/BA,cACA,eAAU,2BAAkC,EAC5C,IAAiB,OAAa,QAAe,EAAK,EAGlD,MADA,CADA,QACA,MAEA,yECFA,cACA,aAAU,SAAgB,EAC1B,EAAgB,OAAQ,IACxB,MAAyB,SAAG,CAAC,GAAU,EAAI,8BAAkC,CAC7E,CACA,qECZA,UACA,QACA,uEACA,EACA,cACA,eAAU,sBAAgC,EAC1C,EAAgB,OAAQ,GACxB,SACA,SACA,IAMA,OALA,EACA,iBAA2B,EAAQ,GAC/B,GACJ,kBAA2B,EAAQ,IAEnC,CACA,yECTA,cACA,aAAU,SAAgB,EAC1B,EAAgB,OAAQ,IACxB,MAAyB,SAAG,CAAC,GAAU,EAAI,sCAA8C,CACzF,CACA,iHCLA,GACA,WACA,wBACA,aACA,YACA,cACA,YACA,kBACA,oBACA,mBACA,EAKA,eAA4B,EAC5B,IACA,iBACA,YACA,cACA,aACA,aACA,aACA,WACA,YACA,OACA,QACA,KACA,oBACA,qBACA,KACA,CAAI,EACJ,WAAwB,WAAK,GAAG,EAChC,EAAsB,QAAqB,GAC3C,EAAgB,OAAoB,GAGpC,EADA,GACA,CAFA,OAEA,OACA,cACA,4CACA,wCACA,wCACA,uCACA,MAA8C,cAAQ,KACtD,MAAkC,cAAQ,KAC1C,MAAmC,cAAQ,KAC3C,MAAgC,cAAQ,KACxC,MAAuC,cAAQ,MAC/C,aACA,QACE,eAAS,KACA,QAAiB,IACzB,IACH,MAAuB,iBAAW,CAClC,IACA,SACA,mBACA,MACA,CACA,GACA,oBAEA,aACA,CAAK,CACL,WAEA,EAAoB,iBAAW,CAC/B,IACA,aACA,KAEA,CAAK,CACL,KAEA,EAAkB,iBAAW,CAC7B,IACA,aACA,KAEA,CAAK,CACL,KAEA,EAAwB,iBAAW,CACnC,KAAgB,YAChB,KACA,MACA,cAAqB,QAAQ,IAC7B,aAAoB,QAAQ,IAC5B,gBAAuB,QAAQ,IAC/B,eAAsB,QAAQ,IAC9B,eAAsB,QAAQ,IAC9B,aAAoB,QAAQ,IAC5B,qBAA4B,QAAQ,OACpC,gBAAuB,QAAQ,IAC/B,iBACA,YAAmB,QAAe,0BAClC,UAAiB,QAAe,wBAChC,aAAoB,QAAe,CACnC,eACA,WAEA,aAAoB,QAAe,CACnC,eACA,UAEA,EAAK,CACL,CACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAEA,CAAU,oBAAkB,aAC5B,EAAwB,iBAAW,CACnC,KAAgB,WAChB,YACA,OACA,KACA,KACA,MACA,aACA,OACA,QACA,SAAkB,QAAe,eACjC,OAAgB,QAAe,CAC/B,EACA,SACA,WAEA,QAAiB,QAAe,CAChC,EACA,UACA,WAEA,UAAmB,QAAe,gBAClC,QAAiB,QAAe,cAChC,UACA,WACA,WACA,WACA,eAAwB,QAAQ,IAChC,gBAAyB,QAAQ,IACjC,gBAAyB,QAAQ,IACjC,gBAAyB,QAAQ,IACjC,qBACA,OACA,CACA,CAAK,CACL,CACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EA2BA,OACA,MAXA,CACA,YACA,YACA,YACA,WACA,YACA,aACA,aACA,YACA,EAGA,mBACA,gBACA,gBACA,cA9BA,KAAoC,YACpC,KACA,MACA,YAAiB,QAAe,kBAChC,gBAAqB,QAAQ,IAC7B,eAAoB,QAAQ,IAC5B,eAAoB,QAAQ,GAC5B,EAAG,CAwBH,aAvBA,cACA,KACA,MACA,gBAAqB,QAAQ,IAC7B,eAAoB,QAAQ,IAC5B,eAAoB,QAAQ,GAC5B,GAkBA,WACA,CACA,CACA,cACA,mBACA,mBACA,6HC7MA,MAAiD,OAAa,EAC9D,yBACA,SACA,CAAC,EACD,EAAiB,OAAU,SAC3B,IACA,cACA,OACA,UACA,WACA,YACA,aACA,cACA,KACA,CAAI,EACJ,CAAU,sDAAiD,CAAE,MAAa,IAC1E,EAAgB,aAAO,CACvB,MACA,OACA,OACA,WACA,cACA,QACA,UACA,aACA,aACA,EAAK,CACL,CACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAEA,MAAyB,SAAG,IAAuB,iBAAwC,SAAG,CAC1F,GAAM,KACV,CACA,UACA,UAAiB,QAAE,yBACnB,UACA,EACA,CAAK,CACL,CAAC,EACD,kGCrDA,eAAiC,EACjC,IACA,WACA,QACA,eACA,OACA,aACA,cACA,WACA,KACA,CAAI,EACJ,MAAiC,cAAQ,QACzC,aACA,QACA,EAAc,YAAM,OACpB,EAAgB,iBAAW,MAC3B,gBACA,MACA,OACA,qCACA,kBACA,GAEA,MACA,UACA,MACA,CACA,yBACA,wBACA,mBACA,CAAG,KACH,EAAe,WAAK,GACpB,WAAgC,EAAK,EACrC,OACA,EAAmB,iBAAW,CAC9B,IACA,MAtCA,GAAkB,QAAQ,CAsC1B,IAtCqC,QAAQ,WAsC7C,iBACA,GACA,KAEA,qBACA,CAAK,CACL,OA0BA,OACA,aAzBuB,iBAAW,CAClC,KAAgB,YAChB,KACA,IAAW,QAAS,MACpB,iBACA,EAAK,CACL,IAoBA,cAlBwB,iBAAW,CACnC,KAAgB,WAChB,8BACA,OACA,KACA,MACA,OACA,+BACA,YACA,IACA,CAAS,CACT,oBACA,CACA,CAAK,CACL,WAKA,OACA,MACA,QACA,WACA,QACA,WACA,aACA,cACA,WACA,CACA,6HC9EA,MAA4C,OAAa,EACzD,0BACA,gHACA,CAAC,EACD,EAAY,OAAU,SACtB,MAAiB,QAAmB,YACpC,WAAU,iBAAmC,CAAE,OAAgB,IAC/D,MAAyB,SAAG,IAAwB,iBAAyC,SAAG,CAC5F,GAAM,OACV,CACA,MACA,OAAe,yBAAsC,CACrD,UAAiB,QAAE,mBACnB,MAEA,CAAK,CACL,CAAC,EACD,yGCpBA,EAAS,OAAU,CACnB,YAAK,OAAoB,MACzB,MAAmB,OAAc,GACjC,MAA2B,SAAG,CACxB,GAAM,IACZ,CACA,KACA,MACA,WACA,mBACA,EAEA,qFCZA,EAAY,OAAU,SACtB,MAAiB,OAAc,GAC/B,MAAyB,SAAG,CAAC,GAAM,QAAU,yBAAoC,CACjF,CAAC,oFCHD,EAAY,OAAU,SACtB,MAAiB,OAAc,GAC/B,MAAyB,SAAG,CAAC,GAAM,QAAU,yBAAoC,CACjF,CAAC,qFCHD,EAAS,OAAU,SACnB,MAAiB,OAAc,GAC/B,MAAyB,SAAG,CAAC,GAAM,KAAO,sBAAiC,CAC3E,CAAC,qFCHD,EAAS,OAAU,CACnB,YAAK,OAAoB,MACzB,MAAmB,OAAc,GACjC,MAA2B,SAAG,CACxB,GAAM,IACZ,CACA,KACA,MACA,WACA,mBACA,EAEA,kICcO,oBAAwC,2DAAmF,EAClI,QACA,OACA,YACA,kFACA,EAAmC,OAAuB,EAC1D,cACA,cACA,+BACA,CAAS,CACT,CACA,aAAoC,OAAS,GAAS,GAAY,kBAClE,UACA,KACA,CACA,SAA2B,aAAe,EAC1C,oBACA,UAA4B,eAAiB,EAAI,eAAiB,EAClE,uBACA,eACA,CAAa,CACb,CACA,4BACA,MAAe,QAAK,CAAC,OAAa,MAClC,cACA,UACA,CAAK,EACL,QACA,sCCvCO,oBACP,MAAuB,OAAwB,IAC/C,2BACA,CAAK,EACL,mBACA,2BACA,CAAK,EACL,UAAa,4BACb,0BC7BO,iBAA0C,GAAS,CAC1D,eACA,sBAA8B,EAAK,sBACnC,kCACA,CAAS,CACT,CACA,sECCA,yCACO,cACP,QAAY,sBAAuB,EACnC,OACA,MACA,MAAqB,QAAU,MAAG,SAAsB,EACxD,MACA,UAAsB,IAAqB,aAAc,EAAU,EACnE,GACA,CACA,oBACA,UAAkB,IAAqB,kBAAc,EAAU,EAC/D,MAAuB,OAAa,IACpC,EAAsB,OAAe,IACrC,KACA,oBACA,oDACA,mBACA,EACA,0BACA,yBACA,EACA,aACA,GACA,cACA,oBACA,yBAAkE,gBAA2B,GAC7F,QAAkD,mBAAwB,SACzD,GAEjB,CACA,eAEA,kBAAqB,UAAe,EACpC,uCACA,MAAe,OAAS,CAAC,QAAO,KAChC,sDACA,UAAkB,EAA2B,QAC7C,MAAW,OAAmB,IADe,CACf,IAC9B,CCtBO,sBACP,YAAY,2DAA4D,EACxE,EAAuB,OAAwB,IAC/C,sBACA,CAAK,EACL,IACU,EAAiB,CAC3B,MACA,OACA,CAH2B,SAG3B,CACA,CAAS,EACT,OACA,mBACA,uBACA,QACA,CACA,UACA,6BAA2D,QAAW,MACtE,2BAAuD,QAAW,MAClE,QACA,CAAa,CACb,CACK,EACL,OACA,MACA,OACA,YACA,KACA,aACA,WACA,YACA,CACA,CC/BO,4BAA2C,0DAAqE,EAAI,EAC3H,wBACA,EAAuB,OAAwB,IAC/C,sBACA,CAAK,EACL,KACA,IAOA,GANA,aAAkD,EAAiB,CACnE,QACA,MAFmE,IAEnE,OACA,MACA,CAAS,GAET,CACA,GACA,UAEA,uBACA,uBACA,QACA,CACA,UACA,6BAA2D,QAAW,MACtE,2BAAuD,QAAW,MAClE,oBAAsC,GAAS,EAAI,CACtC,CACb,CACK,EACL,OACA,MACA,OACA,0BACA,YACA,KACA,aACA,WACA,UACA,YACA,CACA,4DC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,GAAS,GAAQ,cACvE,0BACA,qBACA,CAAyB,cAAiB,EAC1C,IAEA,OACA,KACA,IACA,CAAqB,CACrB,WACA,MACA,CAAqB,CACJ,EACjB,IACA,GACA,GACA,CACA,SACA,MACA,CACA,EAAS,GACT,SAGA,EM3D0C,KAC1C,oBAAoC,QAAgB,MACpD,sBAAsC,CLtD/B,cACP,GKqDwD,KLrD5C,8HAAmJ,EA8L/J,MA5LA,YACA,EACA,oBAEA,gCAEA,gCACA,oDANA,EA2LA,CAjLA,KACA,YACA,EAA2B,QAAS,EACpC,qBACA,EACA,EACA,EACA,MACA,EACA,EACA,EACA,EACA,EACA,MAAe,SAAO,WAAe,YAAiB,SACtD,EAGA,CAFA,aACA,SAEA,SACA,EAA4B,QAAI,WAChC,OACA,IACA,QAAwC,OAAS,GAAS,EAAyB,8BACnF,MACA,UACA,OACA,YACA,SACA,WACA,CAAyB,CACzB,CACA,OACA,KACA,MACA,CACA,IACA,MACA,KACA,QAAqC,OAAS,GAAS,IAAgB,6BAAwB,EAAQ,MAEvG,CAIA,YAAkD,OAAS,GAAS,GAAc,qBAAsB,EAKxG,EADA,OACA,MAAyC,OAAS,GAAS,EAAiB,sBAC5E,MACA,UACA,OACA,YACA,eACA,UACA,QACA,CAA6B,EAG7B,GAEA,GACA,CACA,gBACA,OACA,KACA,iBAEA,eACA,aACA,CACA,SAGA,gBAAiD,KAAoB,EACrE,OACA,cACA,CACA,CAAa,EACb,eACA,UACA,CAAa,EACb,iBACA,GACA,MAA0B,OAAS,GAAS,IAAe,4BAAuB,EAAQ,EAC1F,GACA,CACA,CAAS,CACT,KAwFA,CAvFA,KAEA,MAA2B,QAAS,EACpC,qBACA,EACA,EACA,EACA,MACA,EACA,EARA,MAUA,EACA,KACA,WACA,MAAe,SAAO,WAAe,YAAiB,KAEtD,WACA,IACA,YACA,kCACA,yEACA,EAEA,QADA,YAGA,mBACA,CAAqB,GACrB,IAC0B,EAAiB,CAC3C,MACA,QAF2C,EAE3C,EACA,MACA,CAAyB,EACzB,GACA,CAA4B,eAA4B,mBACxD,wBAA2C,WAAiB,EAC5D,UACA,MACA,OACA,eACA,IACA,cAAwC,UAAkB,CAAE,OAAc,EAC1E,MACA,YACA,gBACA,QACA,CAAiC,EACjC,EAAkD,OAAS,IAC3D,OACA,WACA,CAAiC,EACjC,aACA,CACA,aACA,EACA,EACA,gBAAmD,IAAqB,EACxE,aAAmD,IAAuB,EAE1E,KACA,OACA,iBACA,kDACA,CAEA,MAAkD,OAAS,IAC3D,YAA6D,CAC7D,WACA,CAAiC,EACjC,aACA,CACA,CAAyB,CACzB,WACA,cACA,CAAyB,CACJ,EACrB,IACA,GACA,GACA,CACA,SACA,MACA,CACA,EAAa,GACb,SAEA,KAEA,EK1IwD,KACxD,cAA8B,CJrDvB,SIqDiC,CJrDjC,UAA8B,wHAAiJ,MAsGtL,EACA,EAtGA,MACA,WACA,EACA,oBAEA,gCAEA,gCACA,qDAIA,QAoKA,UAnKA,KACA,MAA2B,QAAS,EACpC,aACA,EACA,EACA,EACA,MACA,EACA,EACA,EACA,EACA,MAAe,SAAO,WAAe,YAAiB,SACtD,EAGA,CAFA,aACA,SAEA,SACA,EAA4B,QAAI,WAChC,OACA,IACA,QAAwC,OAAS,GAAS,EAAiB,sBAC3E,UACA,OACA,QACA,SACA,SACA,WACA,CAAyB,CACzB,CACA,OACA,KACA,MACA,CACA,IACA,MACA,KACA,QAAqC,OAAS,GAAS,IAAgB,6BAAwB,EAAQ,MAEvG,CAIA,YAAkD,OAAS,GAAS,GAAc,qBAAsB,EAKxG,EADA,SACA,MAAyC,OAAS,GAAS,EAAO,YAClE,UACA,OACA,QACA,SACA,eACA,SACA,CAA6B,EAG7B,GAEA,GACA,CACA,gBACA,OACA,KACA,iBAEA,eACA,aACA,CACA,SAGA,gBAAiD,KAAoB,EACrE,OACA,cACA,CACA,CAAa,EACb,eACA,UACA,CAAa,EACb,iBACA,GACA,MAA0B,OAAS,GAAS,IAAe,4BAAuB,EAAQ,EAC1F,GACA,CACA,CAAS,CACT,MAEA,KACA,WACA,WACA,IACA,YACA,kCACA,yEACA,EAEA,QADA,YAGA,kBACA,EAAiB,GACjB,oBACA,KACA,IAOA,GANA,aAA+D,EAAiB,CAChF,QACA,MAFgF,IAEhF,OACA,MACA,CAAqB,GAErB,CACA,GACA,UAEA,IAAwB,eAA4B,mBACpD,wBAAuC,WAAiB,EACxD,UACA,MACA,OACA,eACA,IACA,cAAoC,UAAoB,QAAc,EACtE,UACA,YACA,gBACA,QACA,CAA6B,EAC7B,EAA8C,OAAS,SAAQ,cAAiB,EAChF,MACA,CACA,aACA,EACA,EACA,gBAA+C,IAAqB,EACpE,aAA+C,IAAuB,EAEtE,KACA,OACA,iBACA,kDACA,CAEA,MAA8C,OAAS,IACvD,YAAyD,CACzD,WACA,CAA6B,EAC7B,MACA,CACA,CAAqB,CACrB,WACA,MACA,CAAqB,CACJ,EACjB,IACA,GACA,GACA,CACA,SACA,MACA,CACA,EAAS,GACT,QAGA,GI7HwC,KACxC,4BAA4C,QAAwB,KACpE,CACA,sGCpGO,iBAAiC,GAAS,CACjD,oBAAkB,EAAQ,EAC1B,yBAAiC,OAAS,IAAS,KACnD,gDACA,CAAS,CACT,CACA,CACO,gBAAsC,GAAS,CACtD,yBAAkB,UAAqB,EACvC,gCAAwC,EAAY,sBAAsB,+BAAmC,MAC7G,iEACA,kEACS,CACT,CACA,CACO,gBAAqC,GAAS,CACrD,aAAkB,OAAM,EACxB,sBAA8B,EAAK,gBACnC,0DACA,6BACA,CAAS,CACT,CACA,iDCfO,cACP,IAAY,0CAA0D,EACtE,UACA,OAAuB,MACvB,gBACA,SAAoB,UAAa,CACjC,gBACA,yBACA,CACA,QACA,EACA,EACA,gBAEA,EAEA,oBAHA,GAKA,QACA,sBAEA,gBACA,EAAK,GACL,MAAW,OAAS,SAAG,kCAAqC,CAC5D,CACO,cACP,WAAY,mCAAsC,EAClD,UACA,gBACA,SAAoB,UAAa,EACjC,OACA,UAA4C,IAAY,EACxD,MACA,0CACA,aAGgB,QAAW,IAC3B,iBACA,yBACA,CAAiB,CACjB,CACA,uCAAoE,OAAS,IAC7E,UAA0B,GAAmB,EAAG,UAAgB,EAChE,cAA0C,IAAU,EACpD,MACA,WACA,MAA6B,OAAI,yBACjC,UAA8B,IAAsB,EACpD,gCACA,UAAmC,OAAI,GACvC,CAAqB,CACrB,CACA,WACA,IACA,SA2CA,GAEA,kBACA,YACA,cACA,uBACA,sBACA,oBACA,UAAkB,EAAsB,MAAG,EAAM,CACjD,EApDA,GACA,MAkDwC,CAhDxC,CACA,EAEA,sBACA,sBACA,UAAsB,EAAkB,QAAG,EAAQ,EACnD,mBACA,CAEA,uBACA,QACA,eAEA,UAAsB,EAAuB,aAAG,QAAH,CAAG,CAAoB,EAEpE,CACO,mBAAmC,EAAS,EACnD,OACA,2BAA8C,0BAA8B,CAC5E,aAA6B,6BAAiC,CAC9D,8BACA,eACA,cACA,CAAS,CACT,uBACA,yBACA,cACA,CAAS,CACT,UAA0B,2BAA+B,CACzD,gBACA","sources":["webpack://_N_E/./node_modules/@chakra-ui/accordion/dist/chunk-3VH7AMBV.mjs","webpack://_N_E/./node_modules/@chakra-ui/accordion/dist/chunk-JDQBKIKM.mjs","webpack://_N_E/./node_modules/@chakra-ui/accordion/dist/chunk-JST25EWU.mjs","webpack://_N_E/./node_modules/@chakra-ui/layout/dist/chunk-IWVFML3N.mjs","webpack://_N_E/./node_modules/@chakra-ui/media-query/dist/chunk-DZU5YH7Z.mjs","webpack://_N_E/./node_modules/@chakra-ui/media-query/dist/chunk-OLSEFBIG.mjs","webpack://_N_E/./node_modules/@chakra-ui/media-query/dist/chunk-R3K6W4OF.mjs","webpack://_N_E/./node_modules/@chakra-ui/media-query/dist/chunk-VVU6AIWW.mjs","webpack://_N_E/./node_modules/@chakra-ui/radio/dist/chunk-5XCGGO7V.mjs","webpack://_N_E/./node_modules/@chakra-ui/radio/dist/chunk-QUJ23J4G.mjs","webpack://_N_E/./node_modules/@chakra-ui/radio/dist/chunk-ROBJ47HJ.mjs","webpack://_N_E/./node_modules/@chakra-ui/table/dist/chunk-B3MS3L3D.mjs","webpack://_N_E/./node_modules/@chakra-ui/table/dist/chunk-BLRPLYZO.mjs","webpack://_N_E/./node_modules/@chakra-ui/table/dist/chunk-D3HTYHQX.mjs","webpack://_N_E/./node_modules/@chakra-ui/table/dist/chunk-DJP6PLAX.mjs","webpack://_N_E/./node_modules/@chakra-ui/table/dist/chunk-L7UVV2ML.mjs","webpack://_N_E/./node_modules/@chakra-ui/table/dist/chunk-Z3IFIKNA.mjs","webpack://_N_E/./node_modules/viem/_esm/actions/ens/getEnsResolver.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/createBlockFilter.js","webpack://_N_E/./node_modules/viem/_esm/errors/log.js","webpack://_N_E/./node_modules/viem/_esm/utils/abi/encodeEventTopics.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/createContractEventFilter.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/createEventFilter.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/estimateContractGas.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/getBlobBaseFee.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/getBlockTransactionCount.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/getCode.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/getLogs.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/getContractEvents.js","webpack://_N_E/./node_modules/viem/_esm/errors/eip712.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/getEip712Domain.js","webpack://_N_E/./node_modules/viem/_esm/utils/formatters/feeHistory.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/getFeeHistory.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/getFilterLogs.js","webpack://_N_E/./node_modules/viem/_esm/utils/formatters/proof.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/getProof.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/getStorageAt.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/getTransactionConfirmations.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/simulateContract.js","webpack://_N_E/./node_modules/viem/_esm/constants/strings.js","webpack://_N_E/./node_modules/viem/_esm/utils/signature/toPrefixedMessage.js","webpack://_N_E/./node_modules/viem/_esm/utils/signature/hashMessage.js","webpack://_N_E/./node_modules/viem/_esm/constants/bytes.js","webpack://_N_E/./node_modules/viem/_esm/utils/signature/isErc6492Signature.js","webpack://_N_E/./node_modules/viem/_esm/utils/signature/serializeErc6492Signature.js","webpack://_N_E/./node_modules/viem/_esm/utils/signature/serializeSignature.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/verifyHash.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/verifyMessage.js","webpack://_N_E/./node_modules/viem/_esm/utils/signature/hashTypedData.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/verifyTypedData.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/watchBlocks.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/watchContractEvent.js","webpack://_N_E/./node_modules/viem/_esm/actions/public/watchEvent.js","webpack://_N_E/./node_modules/viem/_esm/utils/siwe/parseSiweMessage.js","webpack://_N_E/./node_modules/viem/_esm/utils/siwe/validateSiweMessage.js","webpack://_N_E/./node_modules/viem/_esm/actions/siwe/verifySiweMessage.js","webpack://_N_E/./node_modules/viem/_esm/clients/decorators/public.js","webpack://_N_E/./node_modules/viem/_esm/errors/typedData.js","webpack://_N_E/./node_modules/viem/_esm/utils/typedData.js"],"sourcesContent":["import {\n  AccordionProvider,\n  useAccordion\n} from \"./chunk-JDQBKIKM.mjs\";\nimport {\n  AccordionDescendantsProvider,\n  AccordionStylesProvider\n} from \"./chunk-JST25EWU.mjs\";\n\n// src/accordion.tsx\nimport {\n  chakra,\n  forwardRef,\n  omitThemingProps,\n  useMultiStyleConfig\n} from \"@chakra-ui/system\";\nimport { cx } from \"@chakra-ui/shared-utils\";\nimport { useMemo } from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar Accordion = forwardRef(function Accordion2({ children, reduceMotion, ...props }, ref) {\n  const styles = useMultiStyleConfig(\"Accordion\", props);\n  const ownProps = omitThemingProps(props);\n  const { htmlProps, descendants, ...context } = useAccordion(ownProps);\n  const ctx = useMemo(\n    () => ({ ...context, reduceMotion: !!reduceMotion }),\n    [context, reduceMotion]\n  );\n  return /* @__PURE__ */ jsx(AccordionDescendantsProvider, { value: descendants, children: /* @__PURE__ */ jsx(AccordionProvider, { value: ctx, children: /* @__PURE__ */ jsx(AccordionStylesProvider, { value: styles, children: /* @__PURE__ */ jsx(\n    chakra.div,\n    {\n      ref,\n      ...htmlProps,\n      className: cx(\"chakra-accordion\", props.className),\n      __css: styles.root,\n      children\n    }\n  ) }) }) });\n});\nAccordion.displayName = \"Accordion\";\n\nexport {\n  Accordion\n};\n","import {\n  useAccordionDescendant,\n  useAccordionDescendants\n} from \"./chunk-JST25EWU.mjs\";\n\n// src/use-accordion.ts\nimport { createContext } from \"@chakra-ui/react-context\";\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\";\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\";\nimport { callAllHandlers, warn } from \"@chakra-ui/shared-utils\";\nimport { useCallback, useEffect, useId, useRef, useState } from \"react\";\nfunction useAccordion(props) {\n  const {\n    onChange,\n    defaultIndex,\n    index: indexProp,\n    allowMultiple,\n    allowToggle,\n    ...htmlProps\n  } = props;\n  allowMultipleWarning(props);\n  allowMultipleAndAllowToggleWarning(props);\n  const descendants = useAccordionDescendants();\n  const [focusedIndex, setFocusedIndex] = useState(-1);\n  useEffect(() => {\n    return () => {\n      setFocusedIndex(-1);\n    };\n  }, []);\n  const [index, setIndex] = useControllableState({\n    value: indexProp,\n    defaultValue() {\n      if (allowMultiple)\n        return defaultIndex != null ? defaultIndex : [];\n      return defaultIndex != null ? defaultIndex : -1;\n    },\n    onChange\n  });\n  const getAccordionItemProps = (idx) => {\n    let isOpen = false;\n    if (idx !== null) {\n      isOpen = Array.isArray(index) ? index.includes(idx) : index === idx;\n    }\n    const onChange2 = (isOpen2) => {\n      if (idx === null)\n        return;\n      if (allowMultiple && Array.isArray(index)) {\n        const nextState = isOpen2 ? index.concat(idx) : index.filter((i) => i !== idx);\n        setIndex(nextState);\n      } else if (isOpen2) {\n        setIndex(idx);\n      } else if (allowToggle) {\n        setIndex(-1);\n      }\n    };\n    return { isOpen, onChange: onChange2 };\n  };\n  return {\n    index,\n    setIndex,\n    htmlProps,\n    getAccordionItemProps,\n    focusedIndex,\n    setFocusedIndex,\n    descendants\n  };\n}\nvar [AccordionProvider, useAccordionContext] = createContext({\n  name: \"AccordionContext\",\n  hookName: \"useAccordionContext\",\n  providerName: \"Accordion\"\n});\nfunction useAccordionItem(props) {\n  const { isDisabled, isFocusable, id, ...htmlProps } = props;\n  const { getAccordionItemProps, setFocusedIndex } = useAccordionContext();\n  const buttonRef = useRef(null);\n  const reactId = useId();\n  const uid = id != null ? id : reactId;\n  const buttonId = `accordion-button-${uid}`;\n  const panelId = `accordion-panel-${uid}`;\n  focusableNotDisabledWarning(props);\n  const { register, index, descendants } = useAccordionDescendant({\n    disabled: isDisabled && !isFocusable\n  });\n  const { isOpen, onChange } = getAccordionItemProps(\n    index === -1 ? null : index\n  );\n  warnIfOpenAndDisabled({ isOpen, isDisabled });\n  const onOpen = () => {\n    onChange == null ? void 0 : onChange(true);\n  };\n  const onClose = () => {\n    onChange == null ? void 0 : onChange(false);\n  };\n  const onClick = useCallback(() => {\n    onChange == null ? void 0 : onChange(!isOpen);\n    setFocusedIndex(index);\n  }, [index, setFocusedIndex, isOpen, onChange]);\n  const onKeyDown = useCallback(\n    (event) => {\n      const keyMap = {\n        ArrowDown: () => {\n          const next = descendants.nextEnabled(index);\n          next == null ? void 0 : next.node.focus();\n        },\n        ArrowUp: () => {\n          const prev = descendants.prevEnabled(index);\n          prev == null ? void 0 : prev.node.focus();\n        },\n        Home: () => {\n          const first = descendants.firstEnabled();\n          first == null ? void 0 : first.node.focus();\n        },\n        End: () => {\n          const last = descendants.lastEnabled();\n          last == null ? void 0 : last.node.focus();\n        }\n      };\n      const action = keyMap[event.key];\n      if (action) {\n        event.preventDefault();\n        action(event);\n      }\n    },\n    [descendants, index]\n  );\n  const onFocus = useCallback(() => {\n    setFocusedIndex(index);\n  }, [setFocusedIndex, index]);\n  const getButtonProps = useCallback(\n    function getButtonProps2(props2 = {}, ref = null) {\n      return {\n        ...props2,\n        type: \"button\",\n        ref: mergeRefs(register, buttonRef, ref),\n        id: buttonId,\n        disabled: !!isDisabled,\n        \"aria-expanded\": !!isOpen,\n        \"aria-controls\": panelId,\n        onClick: callAllHandlers(props2.onClick, onClick),\n        onFocus: callAllHandlers(props2.onFocus, onFocus),\n        onKeyDown: callAllHandlers(props2.onKeyDown, onKeyDown)\n      };\n    },\n    [\n      buttonId,\n      isDisabled,\n      isOpen,\n      onClick,\n      onFocus,\n      onKeyDown,\n      panelId,\n      register\n    ]\n  );\n  const getPanelProps = useCallback(\n    function getPanelProps2(props2 = {}, ref = null) {\n      return {\n        ...props2,\n        ref,\n        role: \"region\",\n        id: panelId,\n        \"aria-labelledby\": buttonId,\n        hidden: !isOpen\n      };\n    },\n    [buttonId, isOpen, panelId]\n  );\n  return {\n    isOpen,\n    isDisabled,\n    isFocusable,\n    onOpen,\n    onClose,\n    getButtonProps,\n    getPanelProps,\n    htmlProps\n  };\n}\nfunction allowMultipleWarning(props) {\n  const index = props.index || props.defaultIndex;\n  const condition = index != null && !Array.isArray(index) && props.allowMultiple;\n  warn({\n    condition: !!condition,\n    message: `If 'allowMultiple' is passed, then 'index' or 'defaultIndex' must be an array. You passed: ${typeof index},`\n  });\n}\nfunction allowMultipleAndAllowToggleWarning(props) {\n  warn({\n    condition: !!(props.allowMultiple && props.allowToggle),\n    message: `If 'allowMultiple' is passed, 'allowToggle' will be ignored. Either remove 'allowToggle' or 'allowMultiple' depending on whether you want multiple accordions visible or not`\n  });\n}\nfunction focusableNotDisabledWarning(props) {\n  warn({\n    condition: !!(props.isFocusable && !props.isDisabled),\n    message: `Using only 'isFocusable', this prop is reserved for situations where you pass 'isDisabled' but you still want the element to receive focus (A11y). Either remove it or pass 'isDisabled' as well.\n    `\n  });\n}\nfunction warnIfOpenAndDisabled(props) {\n  warn({\n    condition: props.isOpen && !!props.isDisabled,\n    message: \"Cannot open a disabled accordion item\"\n  });\n}\n\nexport {\n  useAccordion,\n  AccordionProvider,\n  useAccordionContext,\n  useAccordionItem\n};\n","// src/accordion-context.ts\nimport { createDescendantContext } from \"@chakra-ui/descendant\";\nimport { createContext } from \"@chakra-ui/react-context\";\nvar [AccordionStylesProvider, useAccordionStyles] = createContext({\n  name: \"AccordionStylesContext\",\n  hookName: \"useAccordionStyles\",\n  providerName: \"<Accordion />\"\n});\nvar [AccordionItemProvider, useAccordionItemContext] = createContext({\n  name: \"AccordionItemContext\",\n  hookName: \"useAccordionItemContext\",\n  providerName: \"<AccordionItem />\"\n});\nvar [\n  AccordionDescendantsProvider,\n  useAccordionDescendantsContext,\n  useAccordionDescendants,\n  useAccordionDescendant\n] = createDescendantContext();\n\nexport {\n  AccordionStylesProvider,\n  useAccordionStyles,\n  AccordionItemProvider,\n  useAccordionItemContext,\n  AccordionDescendantsProvider,\n  useAccordionDescendantsContext,\n  useAccordionDescendants,\n  useAccordionDescendant\n};\n","// src/grid-item.tsx\nimport {\n  forwardRef,\n  chakra\n} from \"@chakra-ui/system\";\nimport { compact } from \"@chakra-ui/object-utils\";\nimport { mapResponsive } from \"@chakra-ui/breakpoint-utils\";\nimport { jsx } from \"react/jsx-runtime\";\nfunction spanFn(span) {\n  return mapResponsive(\n    span,\n    (value) => value === \"auto\" ? \"auto\" : `span ${value}/span ${value}`\n  );\n}\nvar GridItem = forwardRef(function GridItem2(props, ref) {\n  const {\n    area,\n    colSpan,\n    colStart,\n    colEnd,\n    rowEnd,\n    rowSpan,\n    rowStart,\n    ...rest\n  } = props;\n  const styles = compact({\n    gridArea: area,\n    gridColumn: spanFn(colSpan),\n    gridRow: spanFn(rowSpan),\n    gridColumnStart: colStart,\n    gridColumnEnd: colEnd,\n    gridRowStart: rowStart,\n    gridRowEnd: rowEnd\n  });\n  return /* @__PURE__ */ jsx(chakra.div, { ref, __css: styles, ...rest });\n});\nGridItem.displayName = \"GridItem\";\n\nexport {\n  GridItem\n};\n","import {\n  useMediaQuery\n} from \"./chunk-MG6WC47T.mjs\";\n\n// src/visibility.tsx\nfunction Visibility(props) {\n  const { breakpoint, hide, children, ssr } = props;\n  const [show] = useMediaQuery(breakpoint, { ssr });\n  const isVisible = hide ? !show : show;\n  const rendered = isVisible ? children : null;\n  return rendered;\n}\n\nexport {\n  Visibility\n};\n","import {\n  Visibility\n} from \"./chunk-DZU5YH7Z.mjs\";\nimport {\n  useQuery\n} from \"./chunk-R3K6W4OF.mjs\";\n\n// src/show.tsx\nimport { jsx } from \"react/jsx-runtime\";\nfunction Show(props) {\n  const { children, ssr } = props;\n  const query = useQuery(props);\n  return /* @__PURE__ */ jsx(Visibility, { breakpoint: query, ssr, children });\n}\nShow.displayName = \"Show\";\n\nexport {\n  Show\n};\n","// src/media-query.tsx\nimport { useTheme } from \"@chakra-ui/system\";\nvar getBreakpoint = (theme, value) => {\n  var _a, _b;\n  return (_b = (_a = theme == null ? void 0 : theme.breakpoints) == null ? void 0 : _a[value]) != null ? _b : value;\n};\nfunction useQuery(props) {\n  const { breakpoint = \"\", below, above } = props;\n  const theme = useTheme();\n  const bpBelow = getBreakpoint(theme, below);\n  const bpAbove = getBreakpoint(theme, above);\n  let query = breakpoint;\n  if (bpBelow) {\n    query = `(max-width: ${bpBelow})`;\n  } else if (bpAbove) {\n    query = `(min-width: ${bpAbove})`;\n  }\n  return query;\n}\n\nexport {\n  useQuery\n};\n","import {\n  Visibility\n} from \"./chunk-DZU5YH7Z.mjs\";\nimport {\n  useQuery\n} from \"./chunk-R3K6W4OF.mjs\";\n\n// src/hide.tsx\nimport { jsx } from \"react/jsx-runtime\";\nfunction Hide(props) {\n  const { children, ssr } = props;\n  const query = useQuery(props);\n  return /* @__PURE__ */ jsx(Visibility, { breakpoint: query, hide: true, ssr, children });\n}\nHide.displayName = \"Hide\";\n\nexport {\n  Hide\n};\n","import {\n  useRadioGroupContext\n} from \"./chunk-QUJ23J4G.mjs\";\n\n// src/use-radio.ts\nimport { useFormControlContext } from \"@chakra-ui/form-control\";\nimport { ariaAttr, callAllHandlers, dataAttr } from \"@chakra-ui/shared-utils\";\n\n// ../visually-hidden/src/visually-hidden.style.ts\nvar visuallyHiddenStyle = {\n  border: \"0\",\n  clip: \"rect(0, 0, 0, 0)\",\n  height: \"1px\",\n  width: \"1px\",\n  margin: \"-1px\",\n  padding: \"0\",\n  overflow: \"hidden\",\n  whiteSpace: \"nowrap\",\n  position: \"absolute\"\n};\n\n// src/use-radio.ts\nimport { trackFocusVisible } from \"@zag-js/focus-visible\";\nimport { useCallback, useEffect, useState, useId } from \"react\";\nfunction useRadio(props = {}) {\n  const {\n    defaultChecked,\n    isChecked: isCheckedProp,\n    isFocusable,\n    isDisabled: isDisabledProp,\n    isReadOnly: isReadOnlyProp,\n    isRequired: isRequiredProp,\n    onChange,\n    isInvalid: isInvalidProp,\n    name,\n    value,\n    id: idProp,\n    \"data-radiogroup\": dataRadioGroup,\n    \"aria-describedby\": ariaDescribedBy,\n    ...htmlProps\n  } = props;\n  const uuid = `radio-${useId()}`;\n  const formControl = useFormControlContext();\n  const group = useRadioGroupContext();\n  const isWithinRadioGroup = !!group || !!dataRadioGroup;\n  const isWithinFormControl = !!formControl;\n  let id = isWithinFormControl && !isWithinRadioGroup ? formControl.id : uuid;\n  id = idProp != null ? idProp : id;\n  const isDisabled = isDisabledProp != null ? isDisabledProp : formControl == null ? void 0 : formControl.isDisabled;\n  const isReadOnly = isReadOnlyProp != null ? isReadOnlyProp : formControl == null ? void 0 : formControl.isReadOnly;\n  const isRequired = isRequiredProp != null ? isRequiredProp : formControl == null ? void 0 : formControl.isRequired;\n  const isInvalid = isInvalidProp != null ? isInvalidProp : formControl == null ? void 0 : formControl.isInvalid;\n  const [isFocusVisible, setIsFocusVisible] = useState(false);\n  const [isFocused, setFocused] = useState(false);\n  const [isHovered, setHovering] = useState(false);\n  const [isActive, setActive] = useState(false);\n  const [isCheckedState, setChecked] = useState(Boolean(defaultChecked));\n  const isControlled = typeof isCheckedProp !== \"undefined\";\n  const isChecked = isControlled ? isCheckedProp : isCheckedState;\n  useEffect(() => {\n    return trackFocusVisible(setIsFocusVisible);\n  }, []);\n  const handleChange = useCallback(\n    (event) => {\n      if (isReadOnly || isDisabled) {\n        event.preventDefault();\n        return;\n      }\n      if (!isControlled) {\n        setChecked(event.target.checked);\n      }\n      onChange == null ? void 0 : onChange(event);\n    },\n    [isControlled, isDisabled, isReadOnly, onChange]\n  );\n  const onKeyDown = useCallback(\n    (event) => {\n      if (event.key === \" \") {\n        setActive(true);\n      }\n    },\n    [setActive]\n  );\n  const onKeyUp = useCallback(\n    (event) => {\n      if (event.key === \" \") {\n        setActive(false);\n      }\n    },\n    [setActive]\n  );\n  const getRadioProps = useCallback(\n    (props2 = {}, ref = null) => ({\n      ...props2,\n      ref,\n      \"data-active\": dataAttr(isActive),\n      \"data-hover\": dataAttr(isHovered),\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(isInvalid),\n      \"data-checked\": dataAttr(isChecked),\n      \"data-focus\": dataAttr(isFocused),\n      \"data-focus-visible\": dataAttr(isFocused && isFocusVisible),\n      \"data-readonly\": dataAttr(isReadOnly),\n      \"aria-hidden\": true,\n      onMouseDown: callAllHandlers(props2.onMouseDown, () => setActive(true)),\n      onMouseUp: callAllHandlers(props2.onMouseUp, () => setActive(false)),\n      onMouseEnter: callAllHandlers(\n        props2.onMouseEnter,\n        () => setHovering(true)\n      ),\n      onMouseLeave: callAllHandlers(\n        props2.onMouseLeave,\n        () => setHovering(false)\n      )\n    }),\n    [\n      isActive,\n      isHovered,\n      isDisabled,\n      isInvalid,\n      isChecked,\n      isFocused,\n      isReadOnly,\n      isFocusVisible\n    ]\n  );\n  const { onFocus, onBlur } = formControl != null ? formControl : {};\n  const getInputProps = useCallback(\n    (props2 = {}, ref = null) => {\n      const trulyDisabled = isDisabled && !isFocusable;\n      return {\n        ...props2,\n        id,\n        ref,\n        type: \"radio\",\n        name,\n        value,\n        onChange: callAllHandlers(props2.onChange, handleChange),\n        onBlur: callAllHandlers(\n          onBlur,\n          props2.onBlur,\n          () => setFocused(false)\n        ),\n        onFocus: callAllHandlers(\n          onFocus,\n          props2.onFocus,\n          () => setFocused(true)\n        ),\n        onKeyDown: callAllHandlers(props2.onKeyDown, onKeyDown),\n        onKeyUp: callAllHandlers(props2.onKeyUp, onKeyUp),\n        checked: isChecked,\n        disabled: trulyDisabled,\n        readOnly: isReadOnly,\n        required: isRequired,\n        \"aria-invalid\": ariaAttr(isInvalid),\n        \"aria-disabled\": ariaAttr(trulyDisabled),\n        \"aria-required\": ariaAttr(isRequired),\n        \"data-readonly\": dataAttr(isReadOnly),\n        \"aria-describedby\": ariaDescribedBy,\n        style: visuallyHiddenStyle\n      };\n    },\n    [\n      isDisabled,\n      isFocusable,\n      id,\n      name,\n      value,\n      handleChange,\n      onBlur,\n      onFocus,\n      onKeyDown,\n      onKeyUp,\n      isChecked,\n      isReadOnly,\n      isRequired,\n      isInvalid,\n      ariaDescribedBy\n    ]\n  );\n  const getLabelProps = (props2 = {}, ref = null) => ({\n    ...props2,\n    ref,\n    onMouseDown: callAllHandlers(props2.onMouseDown, stopEvent),\n    \"data-disabled\": dataAttr(isDisabled),\n    \"data-checked\": dataAttr(isChecked),\n    \"data-invalid\": dataAttr(isInvalid)\n  });\n  const getRootProps = (props2, ref = null) => ({\n    ...props2,\n    ref,\n    \"data-disabled\": dataAttr(isDisabled),\n    \"data-checked\": dataAttr(isChecked),\n    \"data-invalid\": dataAttr(isInvalid)\n  });\n  const state = {\n    isInvalid,\n    isFocused,\n    isChecked,\n    isActive,\n    isHovered,\n    isDisabled,\n    isReadOnly,\n    isRequired\n  };\n  return {\n    state,\n    getCheckboxProps: getRadioProps,\n    getRadioProps,\n    getInputProps,\n    getLabelProps,\n    getRootProps,\n    htmlProps\n  };\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\n\nexport {\n  useRadio\n};\n","import {\n  useRadioGroup\n} from \"./chunk-ROBJ47HJ.mjs\";\n\n// src/radio-group.tsx\nimport {\n  chakra,\n  forwardRef\n} from \"@chakra-ui/system\";\nimport { cx } from \"@chakra-ui/shared-utils\";\nimport { createContext } from \"@chakra-ui/react-context\";\nimport { useMemo } from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar [RadioGroupProvider, useRadioGroupContext] = createContext({\n  name: \"RadioGroupContext\",\n  strict: false\n});\nvar RadioGroup = forwardRef((props, ref) => {\n  const {\n    colorScheme,\n    size,\n    variant,\n    children,\n    className,\n    isDisabled,\n    isFocusable,\n    ...rest\n  } = props;\n  const { value, onChange, getRootProps, name, htmlProps } = useRadioGroup(rest);\n  const group = useMemo(\n    () => ({\n      name,\n      size,\n      onChange,\n      colorScheme,\n      value,\n      variant,\n      isDisabled,\n      isFocusable\n    }),\n    [\n      name,\n      size,\n      onChange,\n      colorScheme,\n      value,\n      variant,\n      isDisabled,\n      isFocusable\n    ]\n  );\n  return /* @__PURE__ */ jsx(RadioGroupProvider, { value: group, children: /* @__PURE__ */ jsx(\n    chakra.div,\n    {\n      ...getRootProps(htmlProps, ref),\n      className: cx(\"chakra-radio-group\", className),\n      children\n    }\n  ) });\n});\nRadioGroup.displayName = \"RadioGroup\";\n\nexport {\n  useRadioGroupContext,\n  RadioGroup\n};\n","// src/use-radio-group.ts\nimport { isObject } from \"@chakra-ui/shared-utils\";\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\";\nimport { useCallback, useRef, useState, useId } from \"react\";\nfunction isInputEvent(value) {\n  return value && isObject(value) && isObject(value.target);\n}\nfunction useRadioGroup(props = {}) {\n  const {\n    onChange: onChangeProp,\n    value: valueProp,\n    defaultValue,\n    name: nameProp,\n    isDisabled,\n    isFocusable,\n    isNative,\n    ...htmlProps\n  } = props;\n  const [valueState, setValue] = useState(defaultValue || \"\");\n  const isControlled = typeof valueProp !== \"undefined\";\n  const value = isControlled ? valueProp : valueState;\n  const ref = useRef(null);\n  const focus = useCallback(() => {\n    const rootNode = ref.current;\n    if (!rootNode)\n      return;\n    let query = `input:not(:disabled):checked`;\n    const firstEnabledAndCheckedInput = rootNode.querySelector(\n      query\n    );\n    if (firstEnabledAndCheckedInput) {\n      firstEnabledAndCheckedInput.focus();\n      return;\n    }\n    query = `input:not(:disabled)`;\n    const firstEnabledInput = rootNode.querySelector(query);\n    firstEnabledInput == null ? void 0 : firstEnabledInput.focus();\n  }, []);\n  const uuid = useId();\n  const fallbackName = `radio-${uuid}`;\n  const name = nameProp || fallbackName;\n  const onChange = useCallback(\n    (eventOrValue) => {\n      const nextValue = isInputEvent(eventOrValue) ? eventOrValue.target.value : eventOrValue;\n      if (!isControlled) {\n        setValue(nextValue);\n      }\n      onChangeProp == null ? void 0 : onChangeProp(String(nextValue));\n    },\n    [onChangeProp, isControlled]\n  );\n  const getRootProps = useCallback(\n    (props2 = {}, forwardedRef = null) => ({\n      ...props2,\n      ref: mergeRefs(forwardedRef, ref),\n      role: \"radiogroup\"\n    }),\n    []\n  );\n  const getRadioProps = useCallback(\n    (props2 = {}, ref2 = null) => {\n      const checkedKey = isNative ? \"checked\" : \"isChecked\";\n      return {\n        ...props2,\n        ref: ref2,\n        name,\n        [checkedKey]: value != null ? props2.value === value : void 0,\n        onChange(event) {\n          onChange(event);\n        },\n        \"data-radiogroup\": true\n      };\n    },\n    [isNative, name, onChange, value]\n  );\n  return {\n    getRootProps,\n    getRadioProps,\n    name,\n    ref,\n    focus,\n    setValue,\n    value,\n    onChange,\n    isDisabled,\n    isFocusable,\n    htmlProps\n  };\n}\n\nexport {\n  useRadioGroup\n};\n","// src/table.tsx\nimport {\n  chakra,\n  forwardRef,\n  omitThemingProps,\n  useMultiStyleConfig\n} from \"@chakra-ui/system\";\nimport { cx } from \"@chakra-ui/shared-utils\";\nimport { createContext } from \"@chakra-ui/react-context\";\nimport { jsx } from \"react/jsx-runtime\";\nvar [TableStylesProvider, useTableStyles] = createContext({\n  name: `TableStylesContext`,\n  errorMessage: `useTableStyles returned is 'undefined'. Seems you forgot to wrap the components in \"<Table />\" `\n});\nvar Table = forwardRef((props, ref) => {\n  const styles = useMultiStyleConfig(\"Table\", props);\n  const { className, layout, ...tableProps } = omitThemingProps(props);\n  return /* @__PURE__ */ jsx(TableStylesProvider, { value: styles, children: /* @__PURE__ */ jsx(\n    chakra.table,\n    {\n      ref,\n      __css: { tableLayout: layout, ...styles.table },\n      className: cx(\"chakra-table\", className),\n      ...tableProps\n    }\n  ) });\n});\nTable.displayName = \"Table\";\n\nexport {\n  useTableStyles,\n  Table\n};\n","import {\n  useTableStyles\n} from \"./chunk-B3MS3L3D.mjs\";\n\n// src/td.tsx\nimport { chakra, forwardRef } from \"@chakra-ui/system\";\nimport { jsx } from \"react/jsx-runtime\";\nvar Td = forwardRef(\n  ({ isNumeric, ...rest }, ref) => {\n    const styles = useTableStyles();\n    return /* @__PURE__ */ jsx(\n      chakra.td,\n      {\n        ...rest,\n        ref,\n        __css: styles.td,\n        \"data-is-numeric\": isNumeric\n      }\n    );\n  }\n);\n\nexport {\n  Td\n};\n","import {\n  useTableStyles\n} from \"./chunk-B3MS3L3D.mjs\";\n\n// src/tbody.tsx\nimport { chakra, forwardRef } from \"@chakra-ui/system\";\nimport { jsx } from \"react/jsx-runtime\";\nvar Tbody = forwardRef((props, ref) => {\n  const styles = useTableStyles();\n  return /* @__PURE__ */ jsx(chakra.tbody, { ...props, ref, __css: styles.tbody });\n});\n\nexport {\n  Tbody\n};\n","import {\n  useTableStyles\n} from \"./chunk-B3MS3L3D.mjs\";\n\n// src/thead.tsx\nimport { chakra, forwardRef } from \"@chakra-ui/system\";\nimport { jsx } from \"react/jsx-runtime\";\nvar Thead = forwardRef((props, ref) => {\n  const styles = useTableStyles();\n  return /* @__PURE__ */ jsx(chakra.thead, { ...props, ref, __css: styles.thead });\n});\n\nexport {\n  Thead\n};\n","import {\n  useTableStyles\n} from \"./chunk-B3MS3L3D.mjs\";\n\n// src/tr.tsx\nimport { chakra, forwardRef } from \"@chakra-ui/system\";\nimport { jsx } from \"react/jsx-runtime\";\nvar Tr = forwardRef((props, ref) => {\n  const styles = useTableStyles();\n  return /* @__PURE__ */ jsx(chakra.tr, { ...props, ref, __css: styles.tr });\n});\n\nexport {\n  Tr\n};\n","import {\n  useTableStyles\n} from \"./chunk-B3MS3L3D.mjs\";\n\n// src/th.tsx\nimport { chakra, forwardRef } from \"@chakra-ui/system\";\nimport { jsx } from \"react/jsx-runtime\";\nvar Th = forwardRef(\n  ({ isNumeric, ...rest }, ref) => {\n    const styles = useTableStyles();\n    return /* @__PURE__ */ jsx(\n      chakra.th,\n      {\n        ...rest,\n        ref,\n        __css: styles.th,\n        \"data-is-numeric\": isNumeric\n      }\n    );\n  }\n);\n\nexport {\n  Th\n};\n","import { getChainContractAddress, } from '../../utils/chain/getChainContractAddress.js';\nimport { toHex } from '../../utils/encoding/toHex.js';\nimport { packetToBytes, } from '../../utils/ens/packetToBytes.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { readContract, } from '../public/readContract.js';\n/**\n * Gets resolver for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsResolverParameters}\n * @returns Address for ENS resolver. {@link GetEnsResolverReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsResolver, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const resolverAddress = await getEnsResolver(client, {\n *   name: normalize('wevm.eth'),\n * })\n * // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41'\n */\nexport async function getEnsResolver(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_, }) {\n    let universalResolverAddress = universalResolverAddress_;\n    if (!universalResolverAddress) {\n        if (!client.chain)\n            throw new Error('client chain not configured. universalResolverAddress is required.');\n        universalResolverAddress = getChainContractAddress({\n            blockNumber,\n            chain: client.chain,\n            contract: 'ensUniversalResolver',\n        });\n    }\n    const [resolverAddress] = await getAction(client, readContract, 'readContract')({\n        address: universalResolverAddress,\n        abi: [\n            {\n                inputs: [{ type: 'bytes' }],\n                name: 'findResolver',\n                outputs: [{ type: 'address' }, { type: 'bytes32' }],\n                stateMutability: 'view',\n                type: 'function',\n            },\n        ],\n        functionName: 'findResolver',\n        args: [toHex(packetToBytes(name))],\n        blockNumber,\n        blockTag,\n    });\n    return resolverAddress;\n}\n//# sourceMappingURL=getEnsResolver.js.map","import { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js';\n/**\n * Creates a [`Filter`](https://viem.sh/docs/glossary/types#filter) to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).\n *\n * - Docs: https://viem.sh/docs/actions/public/createBlockFilter\n * - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter)\n *\n * @param client - Client to use\n * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateBlockFilterReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createBlockFilter } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createBlockFilter(client)\n * // { id: \"0x345a6572337856574a76364e457a4366\", type: 'block' }\n */\nexport async function createBlockFilter(client) {\n    const getRequest = createFilterRequestScope(client, {\n        method: 'eth_newBlockFilter',\n    });\n    const id = await client.request({\n        method: 'eth_newBlockFilter',\n    });\n    return { id, request: getRequest(id), type: 'block' };\n}\n//# sourceMappingURL=createBlockFilter.js.map","import { BaseError } from './base.js';\nexport class FilterTypeNotSupportedError extends BaseError {\n    constructor(type) {\n        super(`Filter type \"${type}\" is not supported.`, {\n            name: 'FilterTypeNotSupportedError',\n        });\n    }\n}\n//# sourceMappingURL=log.js.map","import { AbiEventNotFoundError, } from '../../errors/abi.js';\nimport { FilterTypeNotSupportedError, } from '../../errors/log.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { toEventSelector, } from '../hash/toEventSelector.js';\nimport { encodeAbiParameters, } from './encodeAbiParameters.js';\nimport { formatAbiItem } from './formatAbiItem.js';\nimport { getAbiItem } from './getAbiItem.js';\nconst docsPath = '/docs/contract/encodeEventTopics';\nexport function encodeEventTopics(parameters) {\n    const { abi, eventName, args } = parameters;\n    let abiItem = abi[0];\n    if (eventName) {\n        const item = getAbiItem({ abi, name: eventName });\n        if (!item)\n            throw new AbiEventNotFoundError(eventName, { docsPath });\n        abiItem = item;\n    }\n    if (abiItem.type !== 'event')\n        throw new AbiEventNotFoundError(undefined, { docsPath });\n    const definition = formatAbiItem(abiItem);\n    const signature = toEventSelector(definition);\n    let topics = [];\n    if (args && 'inputs' in abiItem) {\n        const indexedInputs = abiItem.inputs?.filter((param) => 'indexed' in param && param.indexed);\n        const args_ = Array.isArray(args)\n            ? args\n            : Object.values(args).length > 0\n                ? (indexedInputs?.map((x) => args[x.name]) ?? [])\n                : [];\n        if (args_.length > 0) {\n            topics =\n                indexedInputs?.map((param, i) => {\n                    if (Array.isArray(args_[i]))\n                        return args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] }));\n                    return args_[i] ? encodeArg({ param, value: args_[i] }) : null;\n                }) ?? [];\n        }\n    }\n    return [signature, ...topics];\n}\nfunction encodeArg({ param, value, }) {\n    if (param.type === 'string' || param.type === 'bytes')\n        return keccak256(toBytes(value));\n    if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n        throw new FilterTypeNotSupportedError(param.type);\n    return encodeAbiParameters([param], [value]);\n}\n//# sourceMappingURL=encodeEventTopics.js.map","import { encodeEventTopics, } from '../../utils/abi/encodeEventTopics.js';\nimport { numberToHex, } from '../../utils/encoding/toHex.js';\nimport { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js';\n/**\n * Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs).\n *\n * - Docs: https://viem.sh/docs/contract/createContractEventFilter\n *\n * @param client - Client to use\n * @param parameters - {@link CreateContractEventFilterParameters}\n * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateContractEventFilterReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createContractEventFilter } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createContractEventFilter(client, {\n *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),\n * })\n */\nexport async function createContractEventFilter(client, parameters) {\n    const { address, abi, args, eventName, fromBlock, strict, toBlock } = parameters;\n    const getRequest = createFilterRequestScope(client, {\n        method: 'eth_newFilter',\n    });\n    const topics = eventName\n        ? encodeEventTopics({\n            abi,\n            args,\n            eventName,\n        })\n        : undefined;\n    const id = await client.request({\n        method: 'eth_newFilter',\n        params: [\n            {\n                address,\n                fromBlock: typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n                toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n                topics,\n            },\n        ],\n    });\n    return {\n        abi,\n        args,\n        eventName,\n        id,\n        request: getRequest(id),\n        strict: Boolean(strict),\n        type: 'event',\n    };\n}\n//# sourceMappingURL=createContractEventFilter.js.map","import { encodeEventTopics, } from '../../utils/abi/encodeEventTopics.js';\nimport { numberToHex, } from '../../utils/encoding/toHex.js';\nimport { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js';\n/**\n * Creates a [`Filter`](https://viem.sh/docs/glossary/types#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).\n *\n * - Docs: https://viem.sh/docs/actions/public/createEventFilter\n * - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter)\n *\n * @param client - Client to use\n * @param parameters - {@link CreateEventFilterParameters}\n * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateEventFilterReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createEventFilter } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createEventFilter(client, {\n *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * })\n */\nexport async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock, } = {}) {\n    const events = events_ ?? (event ? [event] : undefined);\n    const getRequest = createFilterRequestScope(client, {\n        method: 'eth_newFilter',\n    });\n    let topics = [];\n    if (events) {\n        const encoded = events.flatMap((event) => encodeEventTopics({\n            abi: [event],\n            eventName: event.name,\n            args,\n        }));\n        // TODO: Clean up type casting\n        topics = [encoded];\n        if (event)\n            topics = topics[0];\n    }\n    const id = await client.request({\n        method: 'eth_newFilter',\n        params: [\n            {\n                address,\n                fromBlock: typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n                toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n                ...(topics.length ? { topics } : {}),\n            },\n        ],\n    });\n    return {\n        abi: events,\n        args,\n        eventName: event ? event.name : undefined,\n        fromBlock,\n        id,\n        request: getRequest(id),\n        strict: Boolean(strict),\n        toBlock,\n        type: 'event',\n    };\n}\n//# sourceMappingURL=createEventFilter.js.map","import { parseAccount, } from '../../accounts/utils/parseAccount.js';\nimport { encodeFunctionData, } from '../../utils/abi/encodeFunctionData.js';\nimport { getContractError, } from '../../utils/errors/getContractError.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { estimateGas, } from './estimateGas.js';\n/**\n * Estimates the gas required to successfully execute a contract write function call.\n *\n * - Docs: https://viem.sh/docs/contract/estimateContractGas\n *\n * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateContractGasParameters}\n * @returns The gas estimate (in wei). {@link EstimateContractGasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { estimateContractGas } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const gas = await estimateContractGas(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint() public']),\n *   functionName: 'mint',\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n * })\n */\nexport async function estimateContractGas(client, parameters) {\n    const { abi, address, args, functionName, ...request } = parameters;\n    const data = encodeFunctionData({\n        abi,\n        args,\n        functionName,\n    });\n    try {\n        const gas = await getAction(client, estimateGas, 'estimateGas')({\n            data,\n            to: address,\n            ...request,\n        });\n        return gas;\n    }\n    catch (error) {\n        const account = request.account ? parseAccount(request.account) : undefined;\n        throw getContractError(error, {\n            abi,\n            address,\n            args,\n            docsPath: '/docs/contract/estimateContractGas',\n            functionName,\n            sender: account?.address,\n        });\n    }\n}\n//# sourceMappingURL=estimateContractGas.js.map","/**\n * Returns the base fee per blob gas in wei.\n *\n * - Docs: https://viem.sh/docs/actions/public/getBlobBaseFee\n * - JSON-RPC Methods: [`eth_blobBaseFee`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blobBaseFee)\n *\n * @param client - Client to use\n * @returns The blob base fee (in wei). {@link GetBlobBaseFeeReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBlobBaseFee } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const blobBaseFee = await getBlobBaseFee(client)\n */\nexport async function getBlobBaseFee(client) {\n    const baseFee = await client.request({\n        method: 'eth_blobBaseFee',\n    });\n    return BigInt(baseFee);\n}\n//# sourceMappingURL=getBlobBaseFee.js.map","import { hexToNumber, } from '../../utils/encoding/fromHex.js';\nimport { numberToHex, } from '../../utils/encoding/toHex.js';\n/**\n * Returns the number of Transactions at a block number, hash, or tag.\n *\n * - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount\n * - JSON-RPC Methods:\n *   - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`.\n *   - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`.\n *\n * @param client - Client to use\n * @param parameters - {@link GetBlockTransactionCountParameters}\n * @returns The block transaction count. {@link GetBlockTransactionCountReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBlockTransactionCount } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const count = await getBlockTransactionCount(client)\n */\nexport async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = 'latest', } = {}) {\n    const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;\n    let count;\n    if (blockHash) {\n        count = await client.request({\n            method: 'eth_getBlockTransactionCountByHash',\n            params: [blockHash],\n        }, { dedupe: true });\n    }\n    else {\n        count = await client.request({\n            method: 'eth_getBlockTransactionCountByNumber',\n            params: [blockNumberHex || blockTag],\n        }, { dedupe: Boolean(blockNumberHex) });\n    }\n    return hexToNumber(count);\n}\n//# sourceMappingURL=getBlockTransactionCount.js.map","import { numberToHex, } from '../../utils/encoding/toHex.js';\n/**\n * Retrieves the bytecode at an address.\n *\n * - Docs: https://viem.sh/docs/contract/getCode\n * - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode)\n *\n * @param client - Client to use\n * @param parameters - {@link GetCodeParameters}\n * @returns The contract's bytecode. {@link GetCodeReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getCode } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const code = await getCode(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n * })\n */\nexport async function getCode(client, { address, blockNumber, blockTag = 'latest' }) {\n    const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;\n    const hex = await client.request({\n        method: 'eth_getCode',\n        params: [address, blockNumberHex || blockTag],\n    }, { dedupe: Boolean(blockNumberHex) });\n    if (hex === '0x')\n        return undefined;\n    return hex;\n}\n//# sourceMappingURL=getCode.js.map","import { encodeEventTopics, } from '../../utils/abi/encodeEventTopics.js';\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js';\nimport { numberToHex, } from '../../utils/encoding/toHex.js';\nimport { formatLog, } from '../../utils/formatters/log.js';\n/**\n * Returns a list of event logs matching the provided parameters.\n *\n * - Docs: https://viem.sh/docs/actions/public/getLogs\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/logs_event-logs\n * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)\n *\n * @param client - Client to use\n * @param parameters - {@link GetLogsParameters}\n * @returns A list of event logs. {@link GetLogsReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbiItem } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getLogs } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const logs = await getLogs(client)\n */\nexport async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_, } = {}) {\n    const strict = strict_ ?? false;\n    const events = events_ ?? (event ? [event] : undefined);\n    let topics = [];\n    if (events) {\n        const encoded = events.flatMap((event) => encodeEventTopics({\n            abi: [event],\n            eventName: event.name,\n            args: events_ ? undefined : args,\n        }));\n        // TODO: Clean up type casting\n        topics = [encoded];\n        if (event)\n            topics = topics[0];\n    }\n    let logs;\n    if (blockHash) {\n        logs = await client.request({\n            method: 'eth_getLogs',\n            params: [{ address, topics, blockHash }],\n        });\n    }\n    else {\n        logs = await client.request({\n            method: 'eth_getLogs',\n            params: [\n                {\n                    address,\n                    topics,\n                    fromBlock: typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n                    toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n                },\n            ],\n        });\n    }\n    const formattedLogs = logs.map((log) => formatLog(log));\n    if (!events)\n        return formattedLogs;\n    return parseEventLogs({\n        abi: events,\n        args: args,\n        logs: formattedLogs,\n        strict,\n    });\n}\n//# sourceMappingURL=getLogs.js.map","import { getAbiItem, } from '../../utils/abi/getAbiItem.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { getLogs, } from './getLogs.js';\n/**\n * Returns a list of event logs emitted by a contract.\n *\n * - Docs: https://viem.sh/docs/actions/public/getContractEvents\n * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)\n *\n * @param client - Client to use\n * @param parameters - {@link GetContractEventsParameters}\n * @returns A list of event logs. {@link GetContractEventsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getContractEvents } from 'viem/public'\n * import { wagmiAbi } from './abi'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const logs = await getContractEvents(client, {\n *  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *  abi: wagmiAbi,\n *  eventName: 'Transfer'\n * })\n */\nexport async function getContractEvents(client, parameters) {\n    const { abi, address, args, blockHash, eventName, fromBlock, toBlock, strict, } = parameters;\n    const event = eventName\n        ? getAbiItem({ abi, name: eventName })\n        : undefined;\n    const events = !event\n        ? abi.filter((x) => x.type === 'event')\n        : undefined;\n    return getAction(client, getLogs, 'getLogs')({\n        address,\n        args,\n        blockHash,\n        event,\n        events,\n        fromBlock,\n        toBlock,\n        strict,\n    });\n}\n//# sourceMappingURL=getContractEvents.js.map","import { BaseError } from './base.js';\nexport class Eip712DomainNotFoundError extends BaseError {\n    constructor({ address }) {\n        super(`No EIP-712 domain found on contract \"${address}\".`, {\n            metaMessages: [\n                'Ensure that:',\n                `- The contract is deployed at the address \"${address}\".`,\n                '- `eip712Domain()` function exists on the contract.',\n                '- `eip712Domain()` function matches signature to ERC-5267 specification.',\n            ],\n            name: 'Eip712DomainNotFoundError',\n        });\n    }\n}\n//# sourceMappingURL=eip712.js.map","import { Eip712DomainNotFoundError, } from '../../errors/eip712.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { readContract, } from './readContract.js';\n/**\n * Reads the EIP-712 domain from a contract, based on the ERC-5267 specification.\n *\n * @param client - A {@link Client} instance.\n * @param parameters - The parameters of the action. {@link GetEip712DomainParameters}\n * @returns The EIP-712 domain, fields, and extensions. {@link GetEip712DomainReturnType}\n *\n * @example\n * ```ts\n * import { createPublicClient, http, getEip712Domain } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const domain = await getEip712Domain(client, {\n *   address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\n * })\n * // {\n * //   domain: {\n * //     name: 'ExampleContract',\n * //     version: '1',\n * //     chainId: 1,\n * //     verifyingContract: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\n * //   },\n * //   fields: '0x0f',\n * //   extensions: [],\n * // }\n * ```\n */\nexport async function getEip712Domain(client, parameters) {\n    const { address, factory, factoryData } = parameters;\n    try {\n        const [fields, name, version, chainId, verifyingContract, salt, extensions,] = await getAction(client, readContract, 'readContract')({\n            abi,\n            address,\n            functionName: 'eip712Domain',\n            factory,\n            factoryData,\n        });\n        return {\n            domain: {\n                name,\n                version,\n                chainId: Number(chainId),\n                verifyingContract,\n                salt,\n            },\n            extensions,\n            fields,\n        };\n    }\n    catch (e) {\n        const error = e;\n        if (error.name === 'ContractFunctionExecutionError' &&\n            error.cause.name === 'ContractFunctionZeroDataError') {\n            throw new Eip712DomainNotFoundError({ address });\n        }\n        throw error;\n    }\n}\nconst abi = [\n    {\n        inputs: [],\n        name: 'eip712Domain',\n        outputs: [\n            { name: 'fields', type: 'bytes1' },\n            { name: 'name', type: 'string' },\n            { name: 'version', type: 'string' },\n            { name: 'chainId', type: 'uint256' },\n            { name: 'verifyingContract', type: 'address' },\n            { name: 'salt', type: 'bytes32' },\n            { name: 'extensions', type: 'uint256[]' },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n];\n//# sourceMappingURL=getEip712Domain.js.map","export function formatFeeHistory(feeHistory) {\n    return {\n        baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),\n        gasUsedRatio: feeHistory.gasUsedRatio,\n        oldestBlock: BigInt(feeHistory.oldestBlock),\n        reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value))),\n    };\n}\n//# sourceMappingURL=feeHistory.js.map","import { numberToHex, } from '../../utils/encoding/toHex.js';\nimport { formatFeeHistory, } from '../../utils/formatters/feeHistory.js';\n/**\n * Returns a collection of historical gas information.\n *\n * - Docs: https://viem.sh/docs/actions/public/getFeeHistory\n * - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory)\n *\n * @param client - Client to use\n * @param parameters - {@link GetFeeHistoryParameters}\n * @returns The gas estimate (in wei). {@link GetFeeHistoryReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getFeeHistory } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const feeHistory = await getFeeHistory(client, {\n *   blockCount: 4,\n *   rewardPercentiles: [25, 75],\n * })\n */\nexport async function getFeeHistory(client, { blockCount, blockNumber, blockTag = 'latest', rewardPercentiles, }) {\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n    const feeHistory = await client.request({\n        method: 'eth_feeHistory',\n        params: [\n            numberToHex(blockCount),\n            blockNumberHex || blockTag,\n            rewardPercentiles,\n        ],\n    }, { dedupe: Boolean(blockNumberHex) });\n    return formatFeeHistory(feeHistory);\n}\n//# sourceMappingURL=getFeeHistory.js.map","import { parseEventLogs } from '../../utils/abi/parseEventLogs.js';\nimport { formatLog, } from '../../utils/formatters/log.js';\n/**\n * Returns a list of event logs since the filter was created.\n *\n * - Docs: https://viem.sh/docs/actions/public/getFilterLogs\n * - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs)\n *\n * `getFilterLogs` is only compatible with **event filters**.\n *\n * @param client - Client to use\n * @param parameters - {@link GetFilterLogsParameters}\n * @returns A list of event logs. {@link GetFilterLogsReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbiItem } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createEventFilter, getFilterLogs } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createEventFilter(client, {\n *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),\n * })\n * const logs = await getFilterLogs(client, { filter })\n */\nexport async function getFilterLogs(_client, { filter, }) {\n    const strict = filter.strict ?? false;\n    const logs = await filter.request({\n        method: 'eth_getFilterLogs',\n        params: [filter.id],\n    });\n    const formattedLogs = logs.map((log) => formatLog(log));\n    if (!filter.abi)\n        return formattedLogs;\n    return parseEventLogs({\n        abi: filter.abi,\n        logs: formattedLogs,\n        strict,\n    });\n}\n//# sourceMappingURL=getFilterLogs.js.map","import { hexToNumber } from '../index.js';\nfunction formatStorageProof(storageProof) {\n    return storageProof.map((proof) => ({\n        ...proof,\n        value: BigInt(proof.value),\n    }));\n}\nexport function formatProof(proof) {\n    return {\n        ...proof,\n        balance: proof.balance ? BigInt(proof.balance) : undefined,\n        nonce: proof.nonce ? hexToNumber(proof.nonce) : undefined,\n        storageProof: proof.storageProof\n            ? formatStorageProof(proof.storageProof)\n            : undefined,\n    };\n}\n//# sourceMappingURL=proof.js.map","import { numberToHex, } from '../../utils/encoding/toHex.js';\nimport { formatProof, } from '../../utils/formatters/proof.js';\n/**\n * Returns the account and storage values of the specified account including the Merkle-proof.\n *\n * - Docs: https://viem.sh/docs/actions/public/getProof\n * - JSON-RPC Methods:\n *   - Calls [`eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186)\n *\n * @param client - Client to use\n * @param parameters - {@link GetProofParameters}\n * @returns Proof data. {@link GetProofReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getProof } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const block = await getProof(client, {\n *  address: '0x...',\n *  storageKeys: ['0x...'],\n * })\n */\nexport async function getProof(client, { address, blockNumber, blockTag: blockTag_, storageKeys, }) {\n    const blockTag = blockTag_ ?? 'latest';\n    const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;\n    const proof = await client.request({\n        method: 'eth_getProof',\n        params: [address, storageKeys, blockNumberHex || blockTag],\n    });\n    return formatProof(proof);\n}\n//# sourceMappingURL=getProof.js.map","import { numberToHex, } from '../../utils/encoding/toHex.js';\n/**\n * Returns the value from a storage slot at a given address.\n *\n * - Docs: https://viem.sh/docs/contract/getStorageAt\n * - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat)\n *\n * @param client - Client to use\n * @param parameters - {@link GetStorageAtParameters}\n * @returns The value of the storage slot. {@link GetStorageAtReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getStorageAt } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const code = await getStorageAt(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   slot: toHex(0),\n * })\n */\nexport async function getStorageAt(client, { address, blockNumber, blockTag = 'latest', slot }) {\n    const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;\n    const data = await client.request({\n        method: 'eth_getStorageAt',\n        params: [address, slot, blockNumberHex || blockTag],\n    });\n    return data;\n}\n//# sourceMappingURL=getStorageAt.js.map","import { getAction } from '../../utils/getAction.js';\nimport { getBlockNumber, } from './getBlockNumber.js';\nimport { getTransaction, } from './getTransaction.js';\n/**\n * Returns the number of blocks passed (confirmations) since the transaction was processed on a block.\n *\n * - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions\n * - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations)\n *\n * @param client - Client to use\n * @param parameters - {@link GetTransactionConfirmationsParameters}\n * @returns The number of blocks passed since the transaction was processed. If confirmations is 0, then the Transaction has not been confirmed & processed yet. {@link GetTransactionConfirmationsReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getTransactionConfirmations } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const confirmations = await getTransactionConfirmations(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function getTransactionConfirmations(client, { hash, transactionReceipt }) {\n    const [blockNumber, transaction] = await Promise.all([\n        getAction(client, getBlockNumber, 'getBlockNumber')({}),\n        hash\n            ? getAction(client, getTransaction, 'getTransaction')({ hash })\n            : undefined,\n    ]);\n    const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;\n    if (!transactionBlockNumber)\n        return 0n;\n    return blockNumber - transactionBlockNumber + 1n;\n}\n//# sourceMappingURL=getTransactionConfirmations.js.map","import { parseAccount, } from '../../accounts/utils/parseAccount.js';\nimport { decodeFunctionResult, } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeFunctionData, } from '../../utils/abi/encodeFunctionData.js';\nimport { getContractError, } from '../../utils/errors/getContractError.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { call } from './call.js';\n/**\n * Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions.\n *\n * - Docs: https://viem.sh/docs/contract/simulateContract\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts\n *\n * This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract), but also supports contract write functions.\n *\n * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * @param client - Client to use\n * @param parameters - {@link SimulateContractParameters}\n * @returns The simulation result and write request. {@link SimulateContractReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateContract } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const result = await simulateContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32) view returns (uint32)']),\n *   functionName: 'mint',\n *   args: ['69420'],\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function simulateContract(client, parameters) {\n    const { abi, address, args, dataSuffix, functionName, ...callRequest } = parameters;\n    const account = callRequest.account\n        ? parseAccount(callRequest.account)\n        : client.account;\n    const calldata = encodeFunctionData({ abi, args, functionName });\n    try {\n        const { data } = await getAction(client, call, 'call')({\n            batch: false,\n            data: `${calldata}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n            to: address,\n            ...callRequest,\n            account,\n        });\n        const result = decodeFunctionResult({\n            abi,\n            args,\n            functionName,\n            data: data || '0x',\n        });\n        const minimizedAbi = abi.filter((abiItem) => 'name' in abiItem && abiItem.name === parameters.functionName);\n        return {\n            result,\n            request: {\n                abi: minimizedAbi,\n                address,\n                args,\n                dataSuffix,\n                functionName,\n                ...callRequest,\n                account,\n            },\n        };\n    }\n    catch (error) {\n        throw getContractError(error, {\n            abi,\n            address,\n            args,\n            docsPath: '/docs/contract/simulateContract',\n            functionName,\n            sender: account?.address,\n        });\n    }\n}\n//# sourceMappingURL=simulateContract.js.map","export const presignMessagePrefix = '\\x19Ethereum Signed Message:\\n';\n//# sourceMappingURL=strings.js.map","import { presignMessagePrefix } from '../../constants/strings.js';\nimport { concat } from '../data/concat.js';\nimport { size } from '../data/size.js';\nimport { bytesToHex, stringToHex, } from '../encoding/toHex.js';\nexport function toPrefixedMessage(message_) {\n    const message = (() => {\n        if (typeof message_ === 'string')\n            return stringToHex(message_);\n        if (typeof message_.raw === 'string')\n            return message_.raw;\n        return bytesToHex(message_.raw);\n    })();\n    const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`);\n    return concat([prefix, message]);\n}\n//# sourceMappingURL=toPrefixedMessage.js.map","import { keccak256 } from '../hash/keccak256.js';\nimport { toPrefixedMessage } from './toPrefixedMessage.js';\nexport function hashMessage(message, to_) {\n    return keccak256(toPrefixedMessage(message), to_);\n}\n//# sourceMappingURL=hashMessage.js.map","export const erc6492MagicBytes = '0x6492649264926492649264926492649264926492649264926492649264926492';\nexport const zeroHash = '0x0000000000000000000000000000000000000000000000000000000000000000';\n//# sourceMappingURL=bytes.js.map","import { erc6492MagicBytes } from '../../constants/bytes.js';\nimport { sliceHex } from '../data/slice.js';\n/** Whether or not the signature is an ERC-6492 formatted signature. */\nexport function isErc6492Signature(signature) {\n    return sliceHex(signature, -32) === erc6492MagicBytes;\n}\n//# sourceMappingURL=isErc6492Signature.js.map","import { erc6492MagicBytes } from '../../constants/bytes.js';\nimport { encodeAbiParameters } from '../abi/encodeAbiParameters.js';\nimport { concatHex } from '../data/concat.js';\nimport { hexToBytes } from '../encoding/toBytes.js';\n/**\n * @description Serializes a ERC-6492 flavoured signature into hex format.\n *\n * @param signature ERC-6492 signature in object format.\n * @returns ERC-6492 signature in hex format.\n *\n * @example\n * serializeSignature({ address: '0x...', data: '0x...', signature: '0x...' })\n * // '0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492'\n */\nexport function serializeErc6492Signature(parameters) {\n    const { address, data, signature, to = 'hex' } = parameters;\n    const signature_ = concatHex([\n        encodeAbiParameters([{ type: 'address' }, { type: 'bytes' }, { type: 'bytes' }], [address, data, signature]),\n        erc6492MagicBytes,\n    ]);\n    if (to === 'hex')\n        return signature_;\n    return hexToBytes(signature_);\n}\n//# sourceMappingURL=serializeErc6492Signature.js.map","import { secp256k1 } from '@noble/curves/secp256k1';\nimport { hexToBigInt } from '../encoding/fromHex.js';\nimport { hexToBytes } from '../encoding/toBytes.js';\n/**\n * @description Converts a signature into hex format.\n *\n * @param signature The signature to convert.\n * @returns The signature in hex format.\n *\n * @example\n * serializeSignature({\n *   r: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf',\n *   s: '0x4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8',\n *   yParity: 1\n * })\n * // \"0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c\"\n */\nexport function serializeSignature({ r, s, to = 'hex', v, yParity, }) {\n    const yParity_ = (() => {\n        if (yParity === 0 || yParity === 1)\n            return yParity;\n        if (v && (v === 27n || v === 28n || v >= 35n))\n            return v % 2n === 0n ? 1 : 0;\n        throw new Error('Invalid `v` or `yParity` value');\n    })();\n    const signature = `0x${new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).toCompactHex()}${yParity_ === 0 ? '1b' : '1c'}`;\n    if (to === 'hex')\n        return signature;\n    return hexToBytes(signature);\n}\n//# sourceMappingURL=serializeSignature.js.map","import { universalSignatureValidatorAbi } from '../../constants/abis.js';\nimport { universalSignatureValidatorByteCode } from '../../constants/contracts.js';\nimport { CallExecutionError } from '../../errors/contract.js';\nimport { encodeDeployData, } from '../../utils/abi/encodeDeployData.js';\nimport { getAddress } from '../../utils/address/getAddress.js';\nimport { isAddressEqual } from '../../utils/address/isAddressEqual.js';\nimport { isHex } from '../../utils/data/isHex.js';\nimport { bytesToHex } from '../../utils/encoding/toHex.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { encodeFunctionData, hexToBool } from '../../utils/index.js';\nimport { isErc6492Signature } from '../../utils/signature/isErc6492Signature.js';\nimport { recoverAddress } from '../../utils/signature/recoverAddress.js';\nimport { serializeErc6492Signature } from '../../utils/signature/serializeErc6492Signature.js';\nimport { serializeSignature } from '../../utils/signature/serializeSignature.js';\nimport { call } from './call.js';\n/**\n * Verifies a message hash onchain using ERC-6492.\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyHashParameters}\n * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}\n */\nexport async function verifyHash(client, parameters) {\n    const { address, factory, factoryData, hash, signature, universalSignatureVerifierAddress = client.chain?.contracts\n        ?.universalSignatureVerifier?.address, ...rest } = parameters;\n    const signatureHex = (() => {\n        if (isHex(signature))\n            return signature;\n        if (typeof signature === 'object' && 'r' in signature && 's' in signature)\n            return serializeSignature(signature);\n        return bytesToHex(signature);\n    })();\n    const wrappedSignature = await (async () => {\n        // If no `factory` or `factoryData` is provided, it is assumed that the\n        // address is not a Smart Account, or the Smart Account is already deployed.\n        if (!factory && !factoryData)\n            return signatureHex;\n        // If the signature is already wrapped, return the signature.\n        if (isErc6492Signature(signatureHex))\n            return signatureHex;\n        // If the Smart Account is not deployed, wrap the signature with a 6492 wrapper\n        // to perform counterfactual validation.\n        return serializeErc6492Signature({\n            address: factory,\n            data: factoryData,\n            signature: signatureHex,\n        });\n    })();\n    try {\n        const args = universalSignatureVerifierAddress\n            ? {\n                to: universalSignatureVerifierAddress,\n                data: encodeFunctionData({\n                    abi: universalSignatureValidatorAbi,\n                    functionName: 'isValidSig',\n                    args: [address, hash, wrappedSignature],\n                }),\n                ...rest,\n            }\n            : {\n                data: encodeDeployData({\n                    abi: universalSignatureValidatorAbi,\n                    args: [address, hash, wrappedSignature],\n                    bytecode: universalSignatureValidatorByteCode,\n                }),\n                ...rest,\n            };\n        const { data } = await getAction(client, call, 'call')(args);\n        return hexToBool(data ?? '0x0');\n    }\n    catch (error) {\n        // Fallback attempt to verify the signature via ECDSA recovery.\n        try {\n            const verified = isAddressEqual(getAddress(address), await recoverAddress({ hash, signature }));\n            if (verified)\n                return true;\n        }\n        catch { }\n        if (error instanceof CallExecutionError) {\n            // if the execution fails, the signature was not valid and an internal method inside of the validator reverted\n            // this can happen for many reasons, for example if signer can not be recovered from the signature\n            // or if the signature has no valid format\n            return false;\n        }\n        throw error;\n    }\n}\n//# sourceMappingURL=verifyHash.js.map","import { hashMessage } from '../../utils/signature/hashMessage.js';\nimport { verifyHash, } from './verifyHash.js';\n/**\n * Verify that a message was signed by the provided address.\n *\n * Compatible with Smart Contract Accounts & Externally Owned Accounts via [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492).\n *\n * - Docs {@link https://viem.sh/docs/actions/public/verifyMessage}\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyMessageParameters}\n * @returns Whether or not the signature is valid. {@link VerifyMessageReturnType}\n */\nexport async function verifyMessage(client, { address, message, factory, factoryData, signature, ...callRequest }) {\n    const hash = hashMessage(message);\n    return verifyHash(client, {\n        address,\n        factory: factory,\n        factoryData: factoryData,\n        hash,\n        signature,\n        ...callRequest,\n    });\n}\n//# sourceMappingURL=verifyMessage.js.map","// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\nimport { encodeAbiParameters, } from '../abi/encodeAbiParameters.js';\nimport { concat } from '../data/concat.js';\nimport { toHex } from '../encoding/toHex.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { getTypesForEIP712Domain, validateTypedData, } from '../typedData.js';\nexport function hashTypedData(parameters) {\n    const { domain = {}, message, primaryType, } = parameters;\n    const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain }),\n        ...parameters.types,\n    };\n    // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n    // as we can't statically check this with TypeScript.\n    validateTypedData({\n        domain,\n        message,\n        primaryType,\n        types,\n    });\n    const parts = ['0x1901'];\n    if (domain)\n        parts.push(hashDomain({\n            domain,\n            types: types,\n        }));\n    if (primaryType !== 'EIP712Domain')\n        parts.push(hashStruct({\n            data: message,\n            primaryType,\n            types: types,\n        }));\n    return keccak256(concat(parts));\n}\nexport function hashDomain({ domain, types, }) {\n    return hashStruct({\n        data: domain,\n        primaryType: 'EIP712Domain',\n        types,\n    });\n}\nexport function hashStruct({ data, primaryType, types, }) {\n    const encoded = encodeData({\n        data,\n        primaryType,\n        types,\n    });\n    return keccak256(encoded);\n}\nfunction encodeData({ data, primaryType, types, }) {\n    const encodedTypes = [{ type: 'bytes32' }];\n    const encodedValues = [hashType({ primaryType, types })];\n    for (const field of types[primaryType]) {\n        const [type, value] = encodeField({\n            types,\n            name: field.name,\n            type: field.type,\n            value: data[field.name],\n        });\n        encodedTypes.push(type);\n        encodedValues.push(value);\n    }\n    return encodeAbiParameters(encodedTypes, encodedValues);\n}\nfunction hashType({ primaryType, types, }) {\n    const encodedHashType = toHex(encodeType({ primaryType, types }));\n    return keccak256(encodedHashType);\n}\nexport function encodeType({ primaryType, types, }) {\n    let result = '';\n    const unsortedDeps = findTypeDependencies({ primaryType, types });\n    unsortedDeps.delete(primaryType);\n    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n    for (const type of deps) {\n        result += `${type}(${types[type]\n            .map(({ name, type: t }) => `${t} ${name}`)\n            .join(',')})`;\n    }\n    return result;\n}\nfunction findTypeDependencies({ primaryType: primaryType_, types, }, results = new Set()) {\n    const match = primaryType_.match(/^\\w*/u);\n    const primaryType = match?.[0];\n    if (results.has(primaryType) || types[primaryType] === undefined) {\n        return results;\n    }\n    results.add(primaryType);\n    for (const field of types[primaryType]) {\n        findTypeDependencies({ primaryType: field.type, types }, results);\n    }\n    return results;\n}\nfunction encodeField({ types, name, type, value, }) {\n    if (types[type] !== undefined) {\n        return [\n            { type: 'bytes32' },\n            keccak256(encodeData({ data: value, primaryType: type, types })),\n        ];\n    }\n    if (type === 'bytes') {\n        const prepend = value.length % 2 ? '0' : '';\n        value = `0x${prepend + value.slice(2)}`;\n        return [{ type: 'bytes32' }, keccak256(value)];\n    }\n    if (type === 'string')\n        return [{ type: 'bytes32' }, keccak256(toHex(value))];\n    if (type.lastIndexOf(']') === type.length - 1) {\n        const parsedType = type.slice(0, type.lastIndexOf('['));\n        const typeValuePairs = value.map((item) => encodeField({\n            name,\n            type: parsedType,\n            types,\n            value: item,\n        }));\n        return [\n            { type: 'bytes32' },\n            keccak256(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))),\n        ];\n    }\n    return [{ type }, value];\n}\n//# sourceMappingURL=hashTypedData.js.map","import { hashTypedData, } from '../../utils/signature/hashTypedData.js';\nimport { verifyHash, } from './verifyHash.js';\n/**\n * Verify that typed data was signed by the provided address.\n *\n * - Docs {@link https://viem.sh/docs/actions/public/verifyTypedData}\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyTypedDataParameters}\n * @returns Whether or not the signature is valid. {@link VerifyTypedDataReturnType}\n */\nexport async function verifyTypedData(client, parameters) {\n    const { address, factory, factoryData, signature, message, primaryType, types, domain, ...callRequest } = parameters;\n    const hash = hashTypedData({ message, primaryType, types, domain });\n    return verifyHash(client, {\n        address,\n        factory: factory,\n        factoryData: factoryData,\n        hash,\n        signature,\n        ...callRequest,\n    });\n}\n//# sourceMappingURL=verifyTypedData.js.map","import { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getBlock } from './getBlock.js';\n/**\n * Watches and returns information for incoming blocks.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchBlocks\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks\n * - JSON-RPC Methods:\n *   - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchBlocksParameters}\n * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlocksReturnType}\n *\n * @example\n * import { createPublicClient, watchBlocks, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchBlocks(client, {\n *   onBlock: (block) => console.log(block),\n * })\n */\nexport function watchBlocks(client, { blockTag = 'latest', emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval, }) {\n    const enablePolling = (() => {\n        if (typeof poll_ !== 'undefined')\n            return poll_;\n        if (client.transport.type === 'webSocket')\n            return false;\n        if (client.transport.type === 'fallback' &&\n            client.transport.transports[0].config.type === 'webSocket')\n            return false;\n        return true;\n    })();\n    const includeTransactions = includeTransactions_ ?? false;\n    let prevBlock;\n    const pollBlocks = () => {\n        const observerId = stringify([\n            'watchBlocks',\n            client.uid,\n            blockTag,\n            emitMissed,\n            emitOnBegin,\n            includeTransactions,\n            pollingInterval,\n        ]);\n        return observe(observerId, { onBlock, onError }, (emit) => poll(async () => {\n            try {\n                const block = await getAction(client, getBlock, 'getBlock')({\n                    blockTag,\n                    includeTransactions,\n                });\n                if (block.number && prevBlock?.number) {\n                    // If the current block number is the same as the previous,\n                    // we can skip.\n                    if (block.number === prevBlock.number)\n                        return;\n                    // If we have missed out on some previous blocks, and the\n                    // `emitMissed` flag is truthy, let's emit those blocks.\n                    if (block.number - prevBlock.number > 1 && emitMissed) {\n                        for (let i = prevBlock?.number + 1n; i < block.number; i++) {\n                            const block = (await getAction(client, getBlock, 'getBlock')({\n                                blockNumber: i,\n                                includeTransactions,\n                            }));\n                            emit.onBlock(block, prevBlock);\n                            prevBlock = block;\n                        }\n                    }\n                }\n                if (\n                // If no previous block exists, emit.\n                !prevBlock?.number ||\n                    // If the block tag is \"pending\" with no block number, emit.\n                    (blockTag === 'pending' && !block?.number) ||\n                    // If the next block number is greater than the previous block number, emit.\n                    // We don't want to emit blocks in the past.\n                    (block.number && block.number > prevBlock.number)) {\n                    emit.onBlock(block, prevBlock);\n                    prevBlock = block;\n                }\n            }\n            catch (err) {\n                emit.onError?.(err);\n            }\n        }, {\n            emitOnBegin,\n            interval: pollingInterval,\n        }));\n    };\n    const subscribeBlocks = () => {\n        let active = true;\n        let emitFetched = true;\n        let unsubscribe = () => (active = false);\n        (async () => {\n            try {\n                if (emitOnBegin) {\n                    getAction(client, getBlock, 'getBlock')({\n                        blockTag,\n                        includeTransactions,\n                    }).then((block) => {\n                        if (!active)\n                            return;\n                        if (!emitFetched)\n                            return;\n                        onBlock(block, undefined);\n                        emitFetched = false;\n                    });\n                }\n                const transport = (() => {\n                    if (client.transport.type === 'fallback') {\n                        const transport = client.transport.transports.find((transport) => transport.config.type === 'webSocket');\n                        if (!transport)\n                            return client.transport;\n                        return transport.value;\n                    }\n                    return client.transport;\n                })();\n                const { unsubscribe: unsubscribe_ } = await transport.subscribe({\n                    params: ['newHeads'],\n                    async onData(data) {\n                        if (!active)\n                            return;\n                        const block = (await getAction(client, getBlock, 'getBlock')({\n                            blockNumber: data.blockNumber,\n                            includeTransactions,\n                        }).catch(() => { }));\n                        if (!active)\n                            return;\n                        onBlock(block, prevBlock);\n                        emitFetched = false;\n                        prevBlock = block;\n                    },\n                    onError(error) {\n                        onError?.(error);\n                    },\n                });\n                unsubscribe = unsubscribe_;\n                if (!active)\n                    unsubscribe();\n            }\n            catch (err) {\n                onError?.(err);\n            }\n        })();\n        return () => unsubscribe();\n    };\n    return enablePolling ? pollBlocks() : subscribeBlocks();\n}\n//# sourceMappingURL=watchBlocks.js.map","import { DecodeLogDataMismatch, DecodeLogTopicsMismatch, } from '../../errors/abi.js';\nimport { InvalidInputRpcError } from '../../errors/rpc.js';\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js';\nimport { encodeEventTopics, } from '../../utils/abi/encodeEventTopics.js';\nimport { formatLog } from '../../utils/formatters/log.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { createContractEventFilter } from './createContractEventFilter.js';\nimport { getBlockNumber } from './getBlockNumber.js';\nimport { getContractEvents, } from './getContractEvents.js';\nimport { getFilterChanges } from './getFilterChanges.js';\nimport { uninstallFilter } from './uninstallFilter.js';\n/**\n * Watches and returns emitted contract event logs.\n *\n * - Docs: https://viem.sh/docs/contract/watchContractEvent\n *\n * This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent#onLogs).\n *\n * `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchContractEventParameters}\n * @returns A function that can be invoked to stop watching for new event logs. {@link WatchContractEventReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchContractEvent } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchContractEvent(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']),\n *   eventName: 'Transfer',\n *   args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },\n *   onLogs: (logs) => console.log(logs),\n * })\n */\nexport function watchContractEvent(client, parameters) {\n    const { abi, address, args, batch = true, eventName, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_, } = parameters;\n    const enablePolling = (() => {\n        if (typeof poll_ !== 'undefined')\n            return poll_;\n        if (typeof fromBlock === 'bigint')\n            return true;\n        if (client.transport.type === 'webSocket')\n            return false;\n        if (client.transport.type === 'fallback' &&\n            client.transport.transports[0].config.type === 'webSocket')\n            return false;\n        return true;\n    })();\n    const pollContractEvent = () => {\n        const strict = strict_ ?? false;\n        const observerId = stringify([\n            'watchContractEvent',\n            address,\n            args,\n            batch,\n            client.uid,\n            eventName,\n            pollingInterval,\n            strict,\n            fromBlock,\n        ]);\n        return observe(observerId, { onLogs, onError }, (emit) => {\n            let previousBlockNumber;\n            if (fromBlock !== undefined)\n                previousBlockNumber = fromBlock - 1n;\n            let filter;\n            let initialized = false;\n            const unwatch = poll(async () => {\n                if (!initialized) {\n                    try {\n                        filter = (await getAction(client, createContractEventFilter, 'createContractEventFilter')({\n                            abi,\n                            address,\n                            args: args,\n                            eventName: eventName,\n                            strict: strict,\n                            fromBlock,\n                        }));\n                    }\n                    catch { }\n                    initialized = true;\n                    return;\n                }\n                try {\n                    let logs;\n                    if (filter) {\n                        logs = await getAction(client, getFilterChanges, 'getFilterChanges')({ filter });\n                    }\n                    else {\n                        // If the filter doesn't exist, we will fall back to use `getLogs`.\n                        // The fall back exists because some RPC Providers do not support filters.\n                        // Fetch the block number to use for `getLogs`.\n                        const blockNumber = await getAction(client, getBlockNumber, 'getBlockNumber')({});\n                        // If the block number has changed, we will need to fetch the logs.\n                        // If the block number doesn't exist, we are yet to reach the first poll interval,\n                        // so do not emit any logs.\n                        if (previousBlockNumber && previousBlockNumber < blockNumber) {\n                            logs = await getAction(client, getContractEvents, 'getContractEvents')({\n                                abi,\n                                address,\n                                args,\n                                eventName,\n                                fromBlock: previousBlockNumber + 1n,\n                                toBlock: blockNumber,\n                                strict,\n                            });\n                        }\n                        else {\n                            logs = [];\n                        }\n                        previousBlockNumber = blockNumber;\n                    }\n                    if (logs.length === 0)\n                        return;\n                    if (batch)\n                        emit.onLogs(logs);\n                    else\n                        for (const log of logs)\n                            emit.onLogs([log]);\n                }\n                catch (err) {\n                    // If a filter has been set and gets uninstalled, providers will throw an InvalidInput error.\n                    // Reinitialize the filter when this occurs\n                    if (filter && err instanceof InvalidInputRpcError)\n                        initialized = false;\n                    emit.onError?.(err);\n                }\n            }, {\n                emitOnBegin: true,\n                interval: pollingInterval,\n            });\n            return async () => {\n                if (filter)\n                    await getAction(client, uninstallFilter, 'uninstallFilter')({ filter });\n                unwatch();\n            };\n        });\n    };\n    const subscribeContractEvent = () => {\n        const strict = strict_ ?? false;\n        const observerId = stringify([\n            'watchContractEvent',\n            address,\n            args,\n            batch,\n            client.uid,\n            eventName,\n            pollingInterval,\n            strict,\n        ]);\n        let active = true;\n        let unsubscribe = () => (active = false);\n        return observe(observerId, { onLogs, onError }, (emit) => {\n            ;\n            (async () => {\n                try {\n                    const transport = (() => {\n                        if (client.transport.type === 'fallback') {\n                            const transport = client.transport.transports.find((transport) => transport.config.type === 'webSocket');\n                            if (!transport)\n                                return client.transport;\n                            return transport.value;\n                        }\n                        return client.transport;\n                    })();\n                    const topics = eventName\n                        ? encodeEventTopics({\n                            abi: abi,\n                            eventName: eventName,\n                            args,\n                        })\n                        : [];\n                    const { unsubscribe: unsubscribe_ } = await transport.subscribe({\n                        params: ['logs', { address, topics }],\n                        onData(data) {\n                            if (!active)\n                                return;\n                            const log = data.result;\n                            try {\n                                const { eventName, args } = decodeEventLog({\n                                    abi: abi,\n                                    data: log.data,\n                                    topics: log.topics,\n                                    strict: strict_,\n                                });\n                                const formatted = formatLog(log, {\n                                    args,\n                                    eventName: eventName,\n                                });\n                                emit.onLogs([formatted]);\n                            }\n                            catch (err) {\n                                let eventName;\n                                let isUnnamed;\n                                if (err instanceof DecodeLogDataMismatch ||\n                                    err instanceof DecodeLogTopicsMismatch) {\n                                    // If strict mode is on, and log data/topics do not match event definition, skip.\n                                    if (strict_)\n                                        return;\n                                    eventName = err.abiItem.name;\n                                    isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));\n                                }\n                                // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n                                const formatted = formatLog(log, {\n                                    args: isUnnamed ? [] : {},\n                                    eventName,\n                                });\n                                emit.onLogs([formatted]);\n                            }\n                        },\n                        onError(error) {\n                            emit.onError?.(error);\n                        },\n                    });\n                    unsubscribe = unsubscribe_;\n                    if (!active)\n                        unsubscribe();\n                }\n                catch (err) {\n                    onError?.(err);\n                }\n            })();\n            return () => unsubscribe();\n        });\n    };\n    return enablePolling ? pollContractEvent() : subscribeContractEvent();\n}\n//# sourceMappingURL=watchContractEvent.js.map","import { encodeEventTopics, } from '../../utils/abi/encodeEventTopics.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { DecodeLogDataMismatch, DecodeLogTopicsMismatch, } from '../../errors/abi.js';\nimport { InvalidInputRpcError } from '../../errors/rpc.js';\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js';\nimport { formatLog } from '../../utils/formatters/log.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { createEventFilter, } from './createEventFilter.js';\nimport { getBlockNumber } from './getBlockNumber.js';\nimport { getFilterChanges } from './getFilterChanges.js';\nimport { getLogs } from './getLogs.js';\nimport { uninstallFilter } from './uninstallFilter.js';\n/**\n * Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms#event-log).\n *\n * - Docs: https://viem.sh/docs/actions/public/watchEvent\n * - JSON-RPC Methods:\n *   - **RPC Provider supports `eth_newFilter`:**\n *     - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize).\n *     - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).\n *   - **RPC Provider does not support `eth_newFilter`:**\n *     - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval.\n *\n * This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent#onLogs).\n *\n * `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchEventParameters}\n * @returns A function that can be invoked to stop watching for new Event Logs. {@link WatchEventReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchEvent } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchEvent(client, {\n *   onLogs: (logs) => console.log(logs),\n * })\n */\nexport function watchEvent(client, { address, args, batch = true, event, events, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_, }) {\n    const enablePolling = (() => {\n        if (typeof poll_ !== 'undefined')\n            return poll_;\n        if (typeof fromBlock === 'bigint')\n            return true;\n        if (client.transport.type === 'webSocket')\n            return false;\n        if (client.transport.type === 'fallback' &&\n            client.transport.transports[0].config.type === 'webSocket')\n            return false;\n        return true;\n    })();\n    const strict = strict_ ?? false;\n    const pollEvent = () => {\n        const observerId = stringify([\n            'watchEvent',\n            address,\n            args,\n            batch,\n            client.uid,\n            event,\n            pollingInterval,\n            fromBlock,\n        ]);\n        return observe(observerId, { onLogs, onError }, (emit) => {\n            let previousBlockNumber;\n            if (fromBlock !== undefined)\n                previousBlockNumber = fromBlock - 1n;\n            let filter;\n            let initialized = false;\n            const unwatch = poll(async () => {\n                if (!initialized) {\n                    try {\n                        filter = (await getAction(client, createEventFilter, 'createEventFilter')({\n                            address,\n                            args,\n                            event: event,\n                            events,\n                            strict,\n                            fromBlock,\n                        }));\n                    }\n                    catch { }\n                    initialized = true;\n                    return;\n                }\n                try {\n                    let logs;\n                    if (filter) {\n                        logs = await getAction(client, getFilterChanges, 'getFilterChanges')({ filter });\n                    }\n                    else {\n                        // If the filter doesn't exist, we will fall back to use `getLogs`.\n                        // The fall back exists because some RPC Providers do not support filters.\n                        // Fetch the block number to use for `getLogs`.\n                        const blockNumber = await getAction(client, getBlockNumber, 'getBlockNumber')({});\n                        // If the block number has changed, we will need to fetch the logs.\n                        // If the block number doesn't exist, we are yet to reach the first poll interval,\n                        // so do not emit any logs.\n                        if (previousBlockNumber && previousBlockNumber !== blockNumber) {\n                            logs = await getAction(client, getLogs, 'getLogs')({\n                                address,\n                                args,\n                                event: event,\n                                events,\n                                fromBlock: previousBlockNumber + 1n,\n                                toBlock: blockNumber,\n                            });\n                        }\n                        else {\n                            logs = [];\n                        }\n                        previousBlockNumber = blockNumber;\n                    }\n                    if (logs.length === 0)\n                        return;\n                    if (batch)\n                        emit.onLogs(logs);\n                    else\n                        for (const log of logs)\n                            emit.onLogs([log]);\n                }\n                catch (err) {\n                    // If a filter has been set and gets uninstalled, providers will throw an InvalidInput error.\n                    // Reinitialize the filter when this occurs\n                    if (filter && err instanceof InvalidInputRpcError)\n                        initialized = false;\n                    emit.onError?.(err);\n                }\n            }, {\n                emitOnBegin: true,\n                interval: pollingInterval,\n            });\n            return async () => {\n                if (filter)\n                    await getAction(client, uninstallFilter, 'uninstallFilter')({ filter });\n                unwatch();\n            };\n        });\n    };\n    const subscribeEvent = () => {\n        let active = true;\n        let unsubscribe = () => (active = false);\n        (async () => {\n            try {\n                const transport = (() => {\n                    if (client.transport.type === 'fallback') {\n                        const transport = client.transport.transports.find((transport) => transport.config.type === 'webSocket');\n                        if (!transport)\n                            return client.transport;\n                        return transport.value;\n                    }\n                    return client.transport;\n                })();\n                const events_ = events ?? (event ? [event] : undefined);\n                let topics = [];\n                if (events_) {\n                    const encoded = events_.flatMap((event) => encodeEventTopics({\n                        abi: [event],\n                        eventName: event.name,\n                        args,\n                    }));\n                    // TODO: Clean up type casting\n                    topics = [encoded];\n                    if (event)\n                        topics = topics[0];\n                }\n                const { unsubscribe: unsubscribe_ } = await transport.subscribe({\n                    params: ['logs', { address, topics }],\n                    onData(data) {\n                        if (!active)\n                            return;\n                        const log = data.result;\n                        try {\n                            const { eventName, args } = decodeEventLog({\n                                abi: events_ ?? [],\n                                data: log.data,\n                                topics: log.topics,\n                                strict,\n                            });\n                            const formatted = formatLog(log, { args, eventName });\n                            onLogs([formatted]);\n                        }\n                        catch (err) {\n                            let eventName;\n                            let isUnnamed;\n                            if (err instanceof DecodeLogDataMismatch ||\n                                err instanceof DecodeLogTopicsMismatch) {\n                                // If strict mode is on, and log data/topics do not match event definition, skip.\n                                if (strict_)\n                                    return;\n                                eventName = err.abiItem.name;\n                                isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));\n                            }\n                            // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n                            const formatted = formatLog(log, {\n                                args: isUnnamed ? [] : {},\n                                eventName,\n                            });\n                            onLogs([formatted]);\n                        }\n                    },\n                    onError(error) {\n                        onError?.(error);\n                    },\n                });\n                unsubscribe = unsubscribe_;\n                if (!active)\n                    unsubscribe();\n            }\n            catch (err) {\n                onError?.(err);\n            }\n        })();\n        return () => unsubscribe();\n    };\n    return enablePolling ? pollEvent() : subscribeEvent();\n}\n//# sourceMappingURL=watchEvent.js.map","/**\n * @description Parses EIP-4361 formatted message into message fields object.\n *\n * @see https://eips.ethereum.org/EIPS/eip-4361\n *\n * @returns EIP-4361 fields object\n */\nexport function parseSiweMessage(message) {\n    const { scheme, statement, ...prefix } = (message.match(prefixRegex)\n        ?.groups ?? {});\n    const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = (message.match(suffixRegex)?.groups ?? {});\n    const resources = message.split('Resources:')[1]?.split('\\n- ').slice(1);\n    return {\n        ...prefix,\n        ...suffix,\n        ...(chainId ? { chainId: Number(chainId) } : {}),\n        ...(expirationTime ? { expirationTime: new Date(expirationTime) } : {}),\n        ...(issuedAt ? { issuedAt: new Date(issuedAt) } : {}),\n        ...(notBefore ? { notBefore: new Date(notBefore) } : {}),\n        ...(requestId ? { requestId } : {}),\n        ...(resources ? { resources } : {}),\n        ...(scheme ? { scheme } : {}),\n        ...(statement ? { statement } : {}),\n    };\n}\n// https://regexr.com/80gdj\nconst prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\\/\\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\\n)(?<address>0x[a-fA-F0-9]{40})\\n\\n(?:(?<statement>.*)\\n\\n)?/;\n// https://regexr.com/80gf9\nconst suffixRegex = /(?:URI: (?<uri>.+))\\n(?:Version: (?<version>.+))\\n(?:Chain ID: (?<chainId>\\d+))\\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\\n(?:Issued At: (?<issuedAt>.+))(?:\\nExpiration Time: (?<expirationTime>.+))?(?:\\nNot Before: (?<notBefore>.+))?(?:\\nRequest ID: (?<requestId>.+))?/;\n//# sourceMappingURL=parseSiweMessage.js.map","import { isAddressEqual } from '../address/isAddressEqual.js';\n/**\n * @description Validates EIP-4361 message.\n *\n * @see https://eips.ethereum.org/EIPS/eip-4361\n */\nexport function validateSiweMessage(parameters) {\n    const { address, domain, message, nonce, scheme, time = new Date(), } = parameters;\n    if (domain && message.domain !== domain)\n        return false;\n    if (nonce && message.nonce !== nonce)\n        return false;\n    if (scheme && message.scheme !== scheme)\n        return false;\n    if (message.expirationTime && time >= message.expirationTime)\n        return false;\n    if (message.notBefore && time < message.notBefore)\n        return false;\n    try {\n        if (!message.address)\n            return false;\n        if (address && !isAddressEqual(message.address, address))\n            return false;\n    }\n    catch {\n        return false;\n    }\n    return true;\n}\n//# sourceMappingURL=validateSiweMessage.js.map","import { hashMessage } from '../../utils/signature/hashMessage.js';\nimport { parseSiweMessage } from '../../utils/siwe/parseSiweMessage.js';\nimport { validateSiweMessage, } from '../../utils/siwe/validateSiweMessage.js';\nimport { verifyHash, } from '../public/verifyHash.js';\n/**\n * Verifies [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message was signed.\n *\n * Compatible with Smart Contract Accounts & Externally Owned Accounts via [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492).\n *\n * - Docs {@link https://viem.sh/docs/siwe/actions/verifySiweMessage}\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifySiweMessageParameters}\n * @returns Whether or not the signature is valid. {@link VerifySiweMessageReturnType}\n */\nexport async function verifySiweMessage(client, parameters) {\n    const { address, domain, message, nonce, scheme, signature, time = new Date(), ...callRequest } = parameters;\n    const parsed = parseSiweMessage(message);\n    if (!parsed.address)\n        return false;\n    const isValid = validateSiweMessage({\n        address,\n        domain,\n        message: parsed,\n        nonce,\n        scheme,\n        time,\n    });\n    if (!isValid)\n        return false;\n    const hash = hashMessage(message);\n    return verifyHash(client, {\n        address: parsed.address,\n        hash,\n        signature,\n        ...callRequest,\n    });\n}\n//# sourceMappingURL=verifySiweMessage.js.map","import { getEnsAddress, } from '../../actions/ens/getEnsAddress.js';\nimport { getEnsAvatar, } from '../../actions/ens/getEnsAvatar.js';\nimport { getEnsName, } from '../../actions/ens/getEnsName.js';\nimport { getEnsResolver, } from '../../actions/ens/getEnsResolver.js';\nimport { getEnsText, } from '../../actions/ens/getEnsText.js';\nimport { call, } from '../../actions/public/call.js';\nimport { createBlockFilter, } from '../../actions/public/createBlockFilter.js';\nimport { createContractEventFilter, } from '../../actions/public/createContractEventFilter.js';\nimport { createEventFilter, } from '../../actions/public/createEventFilter.js';\nimport { createPendingTransactionFilter, } from '../../actions/public/createPendingTransactionFilter.js';\nimport { estimateContractGas, } from '../../actions/public/estimateContractGas.js';\nimport { estimateFeesPerGas, } from '../../actions/public/estimateFeesPerGas.js';\nimport { estimateGas, } from '../../actions/public/estimateGas.js';\nimport { estimateMaxPriorityFeePerGas, } from '../../actions/public/estimateMaxPriorityFeePerGas.js';\nimport { getBalance, } from '../../actions/public/getBalance.js';\nimport { getBlobBaseFee, } from '../../actions/public/getBlobBaseFee.js';\nimport { getBlock, } from '../../actions/public/getBlock.js';\nimport { getBlockNumber, } from '../../actions/public/getBlockNumber.js';\nimport { getBlockTransactionCount, } from '../../actions/public/getBlockTransactionCount.js';\nimport { getChainId, } from '../../actions/public/getChainId.js';\nimport { getCode, } from '../../actions/public/getCode.js';\nimport { getContractEvents, } from '../../actions/public/getContractEvents.js';\nimport { getEip712Domain, } from '../../actions/public/getEip712Domain.js';\nimport { getFeeHistory, } from '../../actions/public/getFeeHistory.js';\nimport { getFilterChanges, } from '../../actions/public/getFilterChanges.js';\nimport { getFilterLogs, } from '../../actions/public/getFilterLogs.js';\nimport { getGasPrice, } from '../../actions/public/getGasPrice.js';\nimport { getLogs, } from '../../actions/public/getLogs.js';\nimport { getProof, } from '../../actions/public/getProof.js';\nimport { getStorageAt, } from '../../actions/public/getStorageAt.js';\nimport { getTransaction, } from '../../actions/public/getTransaction.js';\nimport { getTransactionConfirmations, } from '../../actions/public/getTransactionConfirmations.js';\nimport { getTransactionCount, } from '../../actions/public/getTransactionCount.js';\nimport { getTransactionReceipt, } from '../../actions/public/getTransactionReceipt.js';\nimport { multicall, } from '../../actions/public/multicall.js';\nimport { readContract, } from '../../actions/public/readContract.js';\nimport { simulateContract, } from '../../actions/public/simulateContract.js';\nimport { uninstallFilter, } from '../../actions/public/uninstallFilter.js';\nimport { verifyMessage, } from '../../actions/public/verifyMessage.js';\nimport { verifyTypedData, } from '../../actions/public/verifyTypedData.js';\nimport { waitForTransactionReceipt, } from '../../actions/public/waitForTransactionReceipt.js';\nimport { watchBlockNumber, } from '../../actions/public/watchBlockNumber.js';\nimport { watchBlocks, } from '../../actions/public/watchBlocks.js';\nimport { watchContractEvent, } from '../../actions/public/watchContractEvent.js';\nimport { watchEvent, } from '../../actions/public/watchEvent.js';\nimport { watchPendingTransactions, } from '../../actions/public/watchPendingTransactions.js';\nimport { verifySiweMessage, } from '../../actions/siwe/verifySiweMessage.js';\nimport { prepareTransactionRequest, } from '../../actions/wallet/prepareTransactionRequest.js';\nimport { sendRawTransaction, } from '../../actions/wallet/sendRawTransaction.js';\nexport function publicActions(client) {\n    return {\n        call: (args) => call(client, args),\n        createBlockFilter: () => createBlockFilter(client),\n        createContractEventFilter: (args) => createContractEventFilter(client, args),\n        createEventFilter: (args) => createEventFilter(client, args),\n        createPendingTransactionFilter: () => createPendingTransactionFilter(client),\n        estimateContractGas: (args) => estimateContractGas(client, args),\n        estimateGas: (args) => estimateGas(client, args),\n        getBalance: (args) => getBalance(client, args),\n        getBlobBaseFee: () => getBlobBaseFee(client),\n        getBlock: (args) => getBlock(client, args),\n        getBlockNumber: (args) => getBlockNumber(client, args),\n        getBlockTransactionCount: (args) => getBlockTransactionCount(client, args),\n        getBytecode: (args) => getCode(client, args),\n        getChainId: () => getChainId(client),\n        getCode: (args) => getCode(client, args),\n        getContractEvents: (args) => getContractEvents(client, args),\n        getEip712Domain: (args) => getEip712Domain(client, args),\n        getEnsAddress: (args) => getEnsAddress(client, args),\n        getEnsAvatar: (args) => getEnsAvatar(client, args),\n        getEnsName: (args) => getEnsName(client, args),\n        getEnsResolver: (args) => getEnsResolver(client, args),\n        getEnsText: (args) => getEnsText(client, args),\n        getFeeHistory: (args) => getFeeHistory(client, args),\n        estimateFeesPerGas: (args) => estimateFeesPerGas(client, args),\n        getFilterChanges: (args) => getFilterChanges(client, args),\n        getFilterLogs: (args) => getFilterLogs(client, args),\n        getGasPrice: () => getGasPrice(client),\n        getLogs: (args) => getLogs(client, args),\n        getProof: (args) => getProof(client, args),\n        estimateMaxPriorityFeePerGas: (args) => estimateMaxPriorityFeePerGas(client, args),\n        getStorageAt: (args) => getStorageAt(client, args),\n        getTransaction: (args) => getTransaction(client, args),\n        getTransactionConfirmations: (args) => getTransactionConfirmations(client, args),\n        getTransactionCount: (args) => getTransactionCount(client, args),\n        getTransactionReceipt: (args) => getTransactionReceipt(client, args),\n        multicall: (args) => multicall(client, args),\n        prepareTransactionRequest: (args) => prepareTransactionRequest(client, args),\n        readContract: (args) => readContract(client, args),\n        sendRawTransaction: (args) => sendRawTransaction(client, args),\n        simulateContract: (args) => simulateContract(client, args),\n        verifyMessage: (args) => verifyMessage(client, args),\n        verifySiweMessage: (args) => verifySiweMessage(client, args),\n        verifyTypedData: (args) => verifyTypedData(client, args),\n        uninstallFilter: (args) => uninstallFilter(client, args),\n        waitForTransactionReceipt: (args) => waitForTransactionReceipt(client, args),\n        watchBlocks: (args) => watchBlocks(client, args),\n        watchBlockNumber: (args) => watchBlockNumber(client, args),\n        watchContractEvent: (args) => watchContractEvent(client, args),\n        watchEvent: (args) => watchEvent(client, args),\n        watchPendingTransactions: (args) => watchPendingTransactions(client, args),\n    };\n}\n//# sourceMappingURL=public.js.map","import { stringify } from '../utils/stringify.js';\nimport { BaseError } from './base.js';\nexport class InvalidDomainError extends BaseError {\n    constructor({ domain }) {\n        super(`Invalid domain \"${stringify(domain)}\".`, {\n            metaMessages: ['Must be a valid EIP-712 domain.'],\n        });\n    }\n}\nexport class InvalidPrimaryTypeError extends BaseError {\n    constructor({ primaryType, types, }) {\n        super(`Invalid primary type \\`${primaryType}\\` must be one of \\`${JSON.stringify(Object.keys(types))}\\`.`, {\n            docsPath: '/api/glossary/Errors#typeddatainvalidprimarytypeerror',\n            metaMessages: ['Check that the primary type is a key in `types`.'],\n        });\n    }\n}\nexport class InvalidStructTypeError extends BaseError {\n    constructor({ type }) {\n        super(`Struct type \"${type}\" is invalid.`, {\n            metaMessages: ['Struct type must not be a Solidity type.'],\n            name: 'InvalidStructTypeError',\n        });\n    }\n}\n//# sourceMappingURL=typedData.js.map","import { BytesSizeMismatchError } from '../errors/abi.js';\nimport { InvalidAddressError } from '../errors/address.js';\nimport { InvalidDomainError, InvalidPrimaryTypeError, InvalidStructTypeError, } from '../errors/typedData.js';\nimport { isAddress } from './address/isAddress.js';\nimport { size } from './data/size.js';\nimport { numberToHex } from './encoding/toHex.js';\nimport { bytesRegex, integerRegex } from './regex.js';\nimport { hashDomain, } from './signature/hashTypedData.js';\nimport { stringify } from './stringify.js';\nexport function serializeTypedData(parameters) {\n    const { domain: domain_, message: message_, primaryType, types, } = parameters;\n    const normalizeData = (struct, data_) => {\n        const data = { ...data_ };\n        for (const param of struct) {\n            const { name, type } = param;\n            if (type === 'address')\n                data[name] = data[name].toLowerCase();\n        }\n        return data;\n    };\n    const domain = (() => {\n        if (!types.EIP712Domain)\n            return {};\n        if (!domain_)\n            return {};\n        return normalizeData(types.EIP712Domain, domain_);\n    })();\n    const message = (() => {\n        if (primaryType === 'EIP712Domain')\n            return undefined;\n        return normalizeData(types[primaryType], message_);\n    })();\n    return stringify({ domain, message, primaryType, types });\n}\nexport function validateTypedData(parameters) {\n    const { domain, message, primaryType, types } = parameters;\n    const validateData = (struct, data) => {\n        for (const param of struct) {\n            const { name, type } = param;\n            const value = data[name];\n            const integerMatch = type.match(integerRegex);\n            if (integerMatch &&\n                (typeof value === 'number' || typeof value === 'bigint')) {\n                const [_type, base, size_] = integerMatch;\n                // If number cannot be cast to a sized hex value, it is out of range\n                // and will throw.\n                numberToHex(value, {\n                    signed: base === 'int',\n                    size: Number.parseInt(size_) / 8,\n                });\n            }\n            if (type === 'address' && typeof value === 'string' && !isAddress(value))\n                throw new InvalidAddressError({ address: value });\n            const bytesMatch = type.match(bytesRegex);\n            if (bytesMatch) {\n                const [_type, size_] = bytesMatch;\n                if (size_ && size(value) !== Number.parseInt(size_))\n                    throw new BytesSizeMismatchError({\n                        expectedSize: Number.parseInt(size_),\n                        givenSize: size(value),\n                    });\n            }\n            const struct = types[type];\n            if (struct) {\n                validateReference(type);\n                validateData(struct, value);\n            }\n        }\n    };\n    // Validate domain types.\n    if (types.EIP712Domain && domain) {\n        if (typeof domain !== 'object')\n            throw new InvalidDomainError({ domain });\n        validateData(types.EIP712Domain, domain);\n    }\n    // Validate message types.\n    if (primaryType !== 'EIP712Domain') {\n        if (types[primaryType])\n            validateData(types[primaryType], message);\n        else\n            throw new InvalidPrimaryTypeError({ primaryType, types });\n    }\n}\nexport function getTypesForEIP712Domain({ domain, }) {\n    return [\n        typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n        domain?.version && { name: 'version', type: 'string' },\n        typeof domain?.chainId === 'number' && {\n            name: 'chainId',\n            type: 'uint256',\n        },\n        domain?.verifyingContract && {\n            name: 'verifyingContract',\n            type: 'address',\n        },\n        domain?.salt && { name: 'salt', type: 'bytes32' },\n    ].filter(Boolean);\n}\nexport function domainSeparator({ domain }) {\n    return hashDomain({\n        domain,\n        types: {\n            EIP712Domain: getTypesForEIP712Domain({ domain }),\n        },\n    });\n}\n/** @internal */\nfunction validateReference(type) {\n    // Struct type must not be a Solidity type.\n    if (type === 'address' ||\n        type === 'bool' ||\n        type === 'string' ||\n        type.startsWith('bytes') ||\n        type.startsWith('uint') ||\n        type.startsWith('int'))\n        throw new InvalidStructTypeError({ type });\n}\n//# sourceMappingURL=typedData.js.map"],"names":[],"sourceRoot":"","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58]}