{"version":3,"file":"static/chunks/2627.379bbe847cb36b15.js","mappings":"6HAAA,4BACA,2BAA4D,kBAA2B,CACvF,SACA,eACA,qCACA,sCACA,iDACA,2BACA,cACA,2EAEA,eACA,yCAEA,OADA,YACA,CACA,EACA,aAEA,GADA,2BAIA,OAFA,sBACA,YACA,oCAGA,EACA,kBACA,iCACA,KAKA,IAJA,IACA,IACA,uBAEA,GACA,YACA,6BACA,KAEA,QACA,EACA,8CACA,oBACA,mCAEA,gBACA,WACA,EACA,2BACA,WACA,aACA,oBAEA,EADA,wBACA,kDACA,KACQ,qBAER,SADA,+CACA,eAEA,UACA,qFADA,IAEA,IACA,sBACA,aACA,uBAGA,EAIA,EACA,gBACA,YACA,EACA,0BACA,sBACA,oCACA,IACA,oBACA,WACA,IACA,iBACA,oBACA,KAEA,IAEA,GAEA,CACA,QACA,EACA,+DACA,cACA,YACA,kBACA,CACA,sBACA,yCAOA,MALA,mBACA,MAEA,kCAGA,CACA,CACA,sBACA,SACA,iBACA,yBACA,yBACA,kCACQ,uBACR,gCAEA,+CAGA,aACA,UACA,CACA,cACA,qBACA,CACA,YACA,mBACA,CACA,CACA,YACA,SACA,iBACA,4FACA,YACA,gBACA,CACA,WACA,WACA,CACA,gBACA,gBACA,CACA,CACA,qNC/IA,4BACA,2BAA4D,kBAA2B,EAUvF,cACA,MAYA,OAXA,QACA,eACA,YACA,iBACA,eACA,mBACA,yBACA,GAEA,CACA,CAAG,EACH,CACA,CAEA,yBACA,IAAoB,GAAkB,4BAC3B,GAAkB,CAE7B,IAAoB,GAAgB,4BACzB,GAAgB,CAE3B,IAAoB,GAAoB,OAAS,QAAe,IACrD,GAAoB,CAE/B,gBACA,iBAEA,IACA,CAEA,gBACA,SACA,IACA,4BACA,UACA,cAEA,qBAA6C,KAAQ,IACrD,OAEA,CAEA,cACA,qBACA,WACA,WACA,YAAkB,IAAS,IAC3B,aAEA,QACA,CAEA,gBACA,uBACA,CAEA,uBACA,EAOA,IAJA,WACA,0BACA,OACA,EAAG,EACH,oMANA,uBAOA,CAEA,gBACA,kBACA,uBACA,CAEA,cACA,wCACA,CAEA,gBACA,aAKA,OAJA,oBACA,uBACA,0BAEA,CACA,CAEA,oBACA,EACA,EACA,SACA,WACA,WACA,QAAc,KAAc,IAC5B,SAEA,QAAc,KAAc,IAC5B,UAEA,QAAc,KAAc,IAC5B,QAAgB,KAAc,KAC9B,yBACA,yDACA,4CACA,yCAEA,CAEA,eA7FA,0BAgBA,mBAYA,oBAUA,oBAIA,gBAWA,yBAKA,sBAIA,qBASA,oBAwBA,uBACA,OACA,uCACA,mBACA,EACA,QACA,SACA,KACA,IACM,QAAK,CAAC,QAAK,KACjB,sBACA,SACA,CACA,CAAO,CACP,CAAM,SACN,SAGA,QACA,CAAC,wBACD,wBACA,MACA,oCAA6C,KAAc,SAAQ,EACnE,YACA,qDACA,MACA,SAEA,aACA,SACA,eACA,OAAe,GAAS,UACxB,YACA,CAAQ,mBAAsB,GAAkB,UAAW,CAC3D,CAAQ,sBAAyB,GAAkB,UAAW,CAC9D,CAAQ,0BAA6B,GAAkB,UAAW,CAClE,CAAQ,sBAAyB,GAAkB,UAAW,CAC9D,CAAQ,QAAS,OAAS,GAAkB,cAC5C,EAEA,OAAe,GAAS,iBAAwB,GAAS,kEAAyF,GAAS,YAC3J,oBAEA,OAAe,GAAS,oBAA2B,GAAS,YAAmB,GAAS,eACxF,gBAEA,OAAe,GAAS,gBAAuB,GAAS,kBACxD,gBACA,KACA,qBACA,MACA,OACA,aACA,uBACA,UACA,sBACA,4DACA,KAAgB,GAAkB,UAClC,YAEA,CAAO,EAEP,CACA,QAAe,GAAS,mBAA0B,GAAS,uBAC3D,mBACA,2BACA,MAAsC,GAAS,cAAgB,GAAkB,OAAS,GAAkB,OAC5G,qBACA,MACA,OACA,aACA,sBACA,4DACA,OACA,YAEA,CAAO,EACP,CAEA,OAAe,GAAS,iBAAwB,GAAS,wBAAsC,GAAS,0BAAwC,GAAS,iBACzJ,kBAEA,OAAe,GAAS,kBACxB,MAA2B,QAAY,cACvC,WACA,2DACA,QACA,IAAe,GAAS,4BAA0C,GAAS,mDAAmE,GAAS,gBACvJ,SAEA,IAAe,GAAS,wBACxB,mCAEA,IAAe,GAAS,iCAA+C,GAAS,uBAAqC,GAAS,8CAA4D,GAAS,yCAAiD,GAAS,+BAAuC,GAAS,gBAC7S,OAEA,IAAe,GAAS,WACxB,SAEA,GAEA,kCACA;AACA;AACA,CAAC,EACD,QACA,mBACA,CAAM,OAAe,KAGf,QAAU,KAAU,QAAe,YAGnC,QAAa,MACX,QAAe,YAGf,QAAU,YAAiB,QAAe,mBATlD,EAaA,IACA,CAAC,kBACD,kBACA,MACA,iBACA,mBACA,KAUA,MATA,iBACA,qBAEQ,QAAe,KACvB,OAAkB,IAAsB,EAExC,8EACA,OAAkB,IAAoB,CAAE,IAAkB,EAE1D,kBACA,MACA,OACA,0BACA,aACA,sBACA,4DACA,iCACA,mCACA,sCACA,KAAc,GAAkB,OAChC,aAEA,OAMA,OALA,IACA,sBACA,mBAAsC,GAAgB,SACtD,aAEA,CACA,CAAK,EACL,CACA,SAGA,oBACA,MAAyB,QAAY,cACrC,+CACA,aAAgC,IAAe,CAE/C,MADA,YACA,QACA,MACA,OACA,aACA,iBACA,4DACA,iCACA,mCACA,sCACA,KAAc,GAAkB,YAChC,MACA,CACA,CAAK,aACD,IAA4B,IAAc,CAC9C,cACA,CACA,aACA,cAAuB,IAAc,EACrC,2BACA,KAAc,GAAkB,UAChC,KAAc,IAAc,CACrB,CACP,CACA,cACA,cAAuB,IAAc,EACrC,0BACA,KAAc,GAAkB,UAChC,KAAc,IAAc,EAE5B,GAEA,CACA,CAEA,sBACA,oBACA,SAGA,QADA,gBACA,OAAwD,IAAe,EACvE,eAAuD,EAAM,MAC7D,UACA,YACA,cACA,YACA,SAAyB,GAAS,oCAClC,cAEA,SAAyB,GAAS,kEAAyF,GAAS,cACpI,mBAEA,GADA,2EAA4H,EAAM,eAElI,OAEA,wBACA,2DACA,oBAAsC,IAAoB,+BAA+B,KAAsB,eAC/G,aACA,OAAwB,IAAoB,EAAG,sBAA8B,EAC7E,CAAa,EACb,EAAU,wBAEV,GADA,4EAA6H,EAAM,eAEnI,OAEA,wBACA,4DACA,qBAAuC,IAAiB,+BAA+B,KAAuB,eAC9G,aACA,OAAwB,IAAoB,EAAG,sBAA8B,EAC7E,CAAa,EACb,EAGA,CAAG,EACH,sCAEA,EADA,yCACA,WAAyD,EAAM,MAE/D,WADA,8BAA4F,GAAM,iBAAc,EAAM,gDACtH,QACA,OACA,aACA,KAAY,GAAkB,WAC9B,MACA,EAIA,MAHA,gCACA,gCAEA,CACA,CAAG,EACH,CAEA,oBACA,MACA,iBACA,GAAQ,QAAc,gBACtB,MAA2B,QAAkB,eAC7C,wBACA,sBACA,cACA,8BACA,WACA,CAAS,CACT,CAAO,EACP,gBACA,EAAM,IACN,sBAIA,IADA,gBACA,OAAiD,IAAe,EAEhE,qBACA,MAAsB,QAAY,IAClC,OACA,gBACA,iDACA,KAAY,GAAkB,OAE9B,CAAG,EACH,CAEA,sBACA,MACA,SAEA,qBACA,aACA,OAKA,OAJA,eACA,aAGA,IADA,yDAA6H,GAAS,8CAA8D,QAAe,gBAAyB,QAAe,iCAA4C,QAAc,gDACrT,SACA,mBACA,6CACA,0BAA+B,cAAiB,KAAK,2BAA8B,EACnF,KAAU,GAAkB,OAC5B,mCACA,CAAG,EACH,CAlJA,mCAuCA,oCA0DA,mCA8BA,+CAoBA,uCACA,gBACA,8BACA,uDACA,YAEA,iGACA,sBAEA,2IACA,gCAEA,qLACA,gDAEA,CAAC,wBACD,kBACA,IACA,EADA,OAEA,kBAAsD,EAyBtD,OAxBA,YAIA,GAHA,0BAAuE,GAAS,mBAChF,WAEA,0BAAuE,GAAS,gBAChF,UAA0D,GAAS,OACnE,yBACA,oCAEA,CACA,MACA,QACA,MACA,oBACA,kCACA,QACA,OACA,KAAgB,GAAkB,WAElC,OACA,OAGA,CAAG,EACH,IACA,CAEA,cACA,SAuBA,OAtBA,YACA,SAAuB,GAAS,sCAChC,QACA,KAAc,GAAS,qBACvB,MACA,KAAgB,GAAI,MACpB,aACS,CACT,cACA,KAAgB,GAAS,eACzB,cACS,CACT,eACA,KAAgB,GAAS,YACzB,MACA,KAAkB,GAAI,MACtB,aAEA,CACA,CAAO,CAEP,CAAG,EACH,CACA,CAEA,kBAGA,WADA,EADA,gBACA,OAAuD,IAAW,EAClE,SACA,aACA,4BACA,KAAU,GAAkB,UAC5B,CAAG,EACH,CAEA,oBACA,YACA,mDAEA,IADA,8CACA,SACA,aACA,gCACA,KAAY,GAAkB,UAC9B,IAEA,GAGA,gBACA,WACA,OACA,OACA,kBACA,eACA,oCAIA,OAHA,IACA,kBAAwC,IACxC,cACA,OAGA,CAAG,EACH,OACA,cACA,UACA,mBACA,iBACA,iBAEA,CAEA,gBACA,oBACA,EAAiB,OAAY,GAC7B,iBACA,KACA,MAAmB,GAAe,KAClC,YAAkB,WAAkB,KAEpC,IADA,MAAiB,GAAe,OAChC,WACA,eAEA,UADA,cAKA,WACA,QACA,kBAEA,CACA,OACA,0BACA,2BACA,mBACA,QACA,OACA,CACA,CAEA,gBACA,MACA,eACA,SAEA,aACA,cACA,UACA,KAAS,GAAS,OAClB,sBAA+B,GAAiB,OAChD,MAAS,GAAS,UAClB,OAAgD,KAAhD,UAA+B,GAAiB,UAChD,MAAS,GAAS,cAClB,sBAA+B,GAAiB,cAChD,MAAS,GAAS,OAClB,KAAS,GAAS,eAClB,sBAA+B,GAAiB,OAChD,MAAS,GAAS,qBAClB,sBAA+B,GAAiB,qBAChD,MAAS,GAAS,iBAClB,sBAA+B,GAAiB,iBAChD,MAAS,GAAS,iBAClB,sBAA+B,GAAiB,iBAChD,MAAS,GAAS,YAClB,OAAgD,KAAhD,UAA+B,GAAiB,QAChD,MAAS,GAAS,YAClB,sBAA+B,GAAiB,QAChD,MAAS,GAAS,iBAClB,sBAA+B,GAAiB,QAChD,MAAS,GAAS,WAClB,sBAA+B,GAAiB,kBAChD,MAAS,GAAS,eAClB,OAAgD,KAAhD,UAA+B,GAAiB,WAChD,MAAS,GAAS,WAClB,sBAA+B,GAAiB,OAChD,MAAS,GAAS,UAClB,sBAA+B,GAAiB,MAChD,MAAS,GAAS,YAClB,sBAA+B,GAAiB,YAChD,MAAS,GAAS,WAClB,sBAA+B,GAAiB,cAChD,MAAS,GAAS,iBAElB,OADA,kDAEA,KAAa,GAAS,eACtB,sBAAmC,GAAiB,qBACpD,MAAa,GAAS,WACtB,sBAAmC,GAAiB,wBACpD,CACA,CACA,QACA,CAEA,gBACA,MACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EA0HA,OAzHA,QACA,MACA,eACA,KAAW,GAAS,OACpB,iBACA,mBACA,KACA,MAAW,GAAS,UACpB,sBACA,KACA,MAAW,GAAS,cACpB,0BACA,KACA,MAAW,GAAS,iBACpB,KAAW,GAAS,qBACpB,QACA,sBAEA,KACA,MAAW,GAAS,OACpB,KAAW,GAAS,eACpB,UAIA,GADA,wBACA,YAHA,OAKA,KAEA,MAAW,GAAS,eACpB,EAAqB,QAAY,IACjC,KACA,MAAW,GAAS,WACpB,qCACA,KACA,MAAW,GAAS,eACpB,SACA,OACA,MAA6B,IAAoB,EACjD,YACA,cACA,SACA,CAAW,GAEX,KACA,MAAW,GAAS,iBACpB,SACA,OACA,MAA8B,IAAiB,EAC/C,YACA,cACA,SACA,CAAW,GAEX,KACA,MAAW,GAAS,WACpB,eAGA,yBACA,KAAiB,GAAS,OAC1B,YACA,KACA,MAAiB,GAAS,WAC1B,YACA,KACA,MAAiB,GAAS,gBAC1B,uDACA,OACA,OACA,KACA,CACA,sBACA,OACA,OACA,KACA,CACA,SACA,KACA,CACA,QACA,MAEA,MA1BA,OA4BA,KAEA,MAAW,GAAS,UACpB,KACA,aAA0B,WAAoB,IAC9C,uBACA,OACA,KACA,CACA,CAEA,wBACA,KACA,MAAW,GAAS,YACpB,MAAyB,QAAY,IACrC,eAAwC,IAAe,8CACvD,KACA,MAAW,GAAS,YACpB,MAA6B,QAAe,IAC5C,eAA4C,IAAW,eACvD,KACA,MAAW,GAAS,cACpB,MAA2B,QAAY,IACvC,eAAgD,IAAsB,oBACtE,KACA,MAAW,GAAS,cACpB,+BACA,wBACA,KACA,MAAW,GAAS,YACpB,QACA,qBAGA,CACA,CAAG,EACH,CACA,SACA,UACA,eACA,YACA,WACA,YACA,kBACA,aACA,OACA,eACA,eACA,CACA,CA9SA,8BA2BA,8BAUA,2CAaA,kCAuBA,0BA6BA,uBAqDA,uBAoJA,mBACA,GAAU,yCACV,eACA,MACA,OAEA,oBACA,kBACA,wDACA,MAAuB,GAAQ,WAE/B,GACA,KAFA,0CAEA,SACA,aACA,YACA,4BACA,4BACA,sCACA,CAAK,EACL,MAAY,iBAAgC,CAC5C,IAAU,qBACV,EAMA,MALA,2CACA,OAAmB,GAAU,4BAC7B,KAAiB,GAAU,wBACvB,GAAU,kCAEd,CACA,CAAC","sources":["webpack://_N_E/./node_modules/@graphiql/react/dist/Range.es.js","webpack://_N_E/./node_modules/@graphiql/react/dist/hint.es.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nclass CharacterStream {\n  constructor(sourceText) {\n    this.getStartOfToken = () => this._start;\n    this.getCurrentPosition = () => this._pos;\n    this.eol = () => this._sourceText.length === this._pos;\n    this.sol = () => this._pos === 0;\n    this.peek = () => {\n      return this._sourceText.charAt(this._pos) ? this._sourceText.charAt(this._pos) : null;\n    };\n    this.next = () => {\n      const char = this._sourceText.charAt(this._pos);\n      this._pos++;\n      return char;\n    };\n    this.eat = (pattern) => {\n      const isMatched = this._testNextCharacter(pattern);\n      if (isMatched) {\n        this._start = this._pos;\n        this._pos++;\n        return this._sourceText.charAt(this._pos - 1);\n      }\n      return void 0;\n    };\n    this.eatWhile = (match) => {\n      let isMatched = this._testNextCharacter(match);\n      let didEat = false;\n      if (isMatched) {\n        didEat = isMatched;\n        this._start = this._pos;\n      }\n      while (isMatched) {\n        this._pos++;\n        isMatched = this._testNextCharacter(match);\n        didEat = true;\n      }\n      return didEat;\n    };\n    this.eatSpace = () => this.eatWhile(/[\\s\\u00a0]/);\n    this.skipToEnd = () => {\n      this._pos = this._sourceText.length;\n    };\n    this.skipTo = (position) => {\n      this._pos = position;\n    };\n    this.match = (pattern, consume = true, caseFold = false) => {\n      let token = null;\n      let match = null;\n      if (typeof pattern === \"string\") {\n        const regex = new RegExp(pattern, caseFold ? \"i\" : \"g\");\n        match = regex.test(this._sourceText.substr(this._pos, pattern.length));\n        token = pattern;\n      } else if (pattern instanceof RegExp) {\n        match = this._sourceText.slice(this._pos).match(pattern);\n        token = match === null || match === void 0 ? void 0 : match[0];\n      }\n      if (match != null) {\n        if (typeof pattern === \"string\" || match instanceof Array && this._sourceText.startsWith(match[0], this._pos)) {\n          if (consume) {\n            this._start = this._pos;\n            if (token && token.length) {\n              this._pos += token.length;\n            }\n          }\n          return match;\n        }\n      }\n      return false;\n    };\n    this.backUp = (num) => {\n      this._pos -= num;\n    };\n    this.column = () => this._pos;\n    this.indentation = () => {\n      const match = this._sourceText.match(/\\s*/);\n      let indent = 0;\n      if (match && match.length !== 0) {\n        const whitespaces = match[0];\n        let pos = 0;\n        while (whitespaces.length > pos) {\n          if (whitespaces.charCodeAt(pos) === 9) {\n            indent += 2;\n          } else {\n            indent++;\n          }\n          pos++;\n        }\n      }\n      return indent;\n    };\n    this.current = () => this._sourceText.slice(this._start, this._pos);\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n  _testNextCharacter(pattern) {\n    const character = this._sourceText.charAt(this._pos);\n    let isMatched = false;\n    if (typeof pattern === \"string\") {\n      isMatched = character === pattern;\n    } else {\n      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n    }\n    return isMatched;\n  }\n}\n__name(CharacterStream, \"CharacterStream\");\nclass Range {\n  constructor(start, end) {\n    this.containsPosition = (position) => {\n      if (this.start.line === position.line) {\n        return this.start.character <= position.character;\n      } else if (this.end.line === position.line) {\n        return this.end.character >= position.character;\n      } else {\n        return this.start.line <= position.line && this.end.line >= position.line;\n      }\n    };\n    this.start = start;\n    this.end = end;\n  }\n  setStart(line, character) {\n    this.start = new Position(line, character);\n  }\n  setEnd(line, character) {\n    this.end = new Position(line, character);\n  }\n}\n__name(Range, \"Range\");\nclass Position {\n  constructor(line, character) {\n    this.lessThanOrEqualTo = (position) => this.line < position.line || this.line === position.line && this.character <= position.character;\n    this.line = line;\n    this.character = character;\n  }\n  setLine(line) {\n    this.line = line;\n  }\n  setCharacter(character) {\n    this.character = character;\n  }\n}\n__name(Position, \"Position\");\nexport { CharacterStream as C, Position as P, Range as R };\n","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { C as CodeMirror } from \"./codemirror.es.js\";\nimport \"./show-hint.es.js\";\nimport { isCompositeType, getNamedType, TypeNameMetaFieldDef as TypeNameMetaFieldDef$1, SchemaMetaFieldDef as SchemaMetaFieldDef$1, TypeMetaFieldDef as TypeMetaFieldDef$1, GraphQLEnumType, GraphQLBoolean, isInterfaceType, isAbstractType, assertAbstractType, doTypesOverlap, isInputType, DirectiveLocation, visit, parse, isListType, isNonNullType, GraphQLInterfaceType, GraphQLObjectType, Kind, GraphQLInputObjectType, getNullableType, GraphQLList } from \"graphql\";\nimport { R as RuleKinds, C as CompletionItemKind, I as InsertTextFormat, o as onlineParser } from \"./types.es.js\";\nimport { C as CharacterStream, P as Position } from \"./Range.es.js\";\nimport { S as SchemaMetaFieldDef, T as TypeMetaFieldDef, a as TypeNameMetaFieldDef } from \"./introspection.es.js\";\nimport \"./index.es.js\";\nimport \"react\";\nimport \"react-dom\";\nfunction getDefinitionState(tokenState) {\n  let definitionState;\n  forEachState(tokenState, (state) => {\n    switch (state.kind) {\n      case \"Query\":\n      case \"ShortQuery\":\n      case \"Mutation\":\n      case \"Subscription\":\n      case \"FragmentDefinition\":\n        definitionState = state;\n        break;\n    }\n  });\n  return definitionState;\n}\n__name(getDefinitionState, \"getDefinitionState\");\nfunction getFieldDef(schema, type, fieldName) {\n  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === type) {\n    return SchemaMetaFieldDef;\n  }\n  if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === type) {\n    return TypeMetaFieldDef;\n  }\n  if (fieldName === TypeNameMetaFieldDef.name && isCompositeType(type)) {\n    return TypeNameMetaFieldDef;\n  }\n  if (\"getFields\" in type) {\n    return type.getFields()[fieldName];\n  }\n  return null;\n}\n__name(getFieldDef, \"getFieldDef\");\nfunction forEachState(stack, fn) {\n  const reverseStateStack = [];\n  let state = stack;\n  while (state === null || state === void 0 ? void 0 : state.kind) {\n    reverseStateStack.push(state);\n    state = state.prevState;\n  }\n  for (let i = reverseStateStack.length - 1; i >= 0; i--) {\n    fn(reverseStateStack[i]);\n  }\n}\n__name(forEachState, \"forEachState\");\nfunction objectValues(object) {\n  const keys = Object.keys(object);\n  const len = keys.length;\n  const values = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    values[i] = object[keys[i]];\n  }\n  return values;\n}\n__name(objectValues, \"objectValues\");\nfunction hintList(token, list) {\n  return filterAndSortList(list, normalizeText(token.string));\n}\n__name(hintList, \"hintList\");\nfunction filterAndSortList(list, text) {\n  if (!text) {\n    return filterNonEmpty(list, (entry) => !entry.isDeprecated);\n  }\n  const byProximity = list.map((entry) => ({\n    proximity: getProximity(normalizeText(entry.label), text),\n    entry\n  }));\n  return filterNonEmpty(filterNonEmpty(byProximity, (pair) => pair.proximity <= 2), (pair) => !pair.entry.isDeprecated).sort((a, b) => (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.label.length - b.entry.label.length).map((pair) => pair.entry);\n}\n__name(filterAndSortList, \"filterAndSortList\");\nfunction filterNonEmpty(array, predicate) {\n  const filtered = array.filter(predicate);\n  return filtered.length === 0 ? array : filtered;\n}\n__name(filterNonEmpty, \"filterNonEmpty\");\nfunction normalizeText(text) {\n  return text.toLowerCase().replace(/\\W/g, \"\");\n}\n__name(normalizeText, \"normalizeText\");\nfunction getProximity(suggestion, text) {\n  let proximity = lexicalDistance(text, suggestion);\n  if (suggestion.length > text.length) {\n    proximity -= suggestion.length - text.length - 1;\n    proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;\n  }\n  return proximity;\n}\n__name(getProximity, \"getProximity\");\nfunction lexicalDistance(a, b) {\n  let i;\n  let j;\n  const d = [];\n  const aLength = a.length;\n  const bLength = b.length;\n  for (i = 0; i <= aLength; i++) {\n    d[i] = [i];\n  }\n  for (j = 1; j <= bLength; j++) {\n    d[0][j] = j;\n  }\n  for (i = 1; i <= aLength; i++) {\n    for (j = 1; j <= bLength; j++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n      }\n    }\n  }\n  return d[aLength][bLength];\n}\n__name(lexicalDistance, \"lexicalDistance\");\nconst SuggestionCommand = {\n  command: \"editor.action.triggerSuggest\",\n  title: \"Suggestions\"\n};\nconst collectFragmentDefs = /* @__PURE__ */ __name((op) => {\n  const externalFragments = [];\n  if (op) {\n    try {\n      visit(parse(op), {\n        FragmentDefinition(def) {\n          externalFragments.push(def);\n        }\n      });\n    } catch (_a) {\n      return [];\n    }\n  }\n  return externalFragments;\n}, \"collectFragmentDefs\");\nfunction getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs, options) {\n  var _a;\n  const opts = Object.assign(Object.assign({}, options), { schema });\n  const token = contextToken || getTokenAtPosition(queryText, cursor);\n  const state = token.state.kind === \"Invalid\" ? token.state.prevState : token.state;\n  if (!state) {\n    return [];\n  }\n  const kind = state.kind;\n  const step = state.step;\n  const typeInfo = getTypeInfo(schema, token.state);\n  if (kind === RuleKinds.DOCUMENT) {\n    return hintList(token, [\n      { label: \"query\", kind: CompletionItemKind.Function },\n      { label: \"mutation\", kind: CompletionItemKind.Function },\n      { label: \"subscription\", kind: CompletionItemKind.Function },\n      { label: \"fragment\", kind: CompletionItemKind.Function },\n      { label: \"{\", kind: CompletionItemKind.Constructor }\n    ]);\n  }\n  if (kind === RuleKinds.IMPLEMENTS || kind === RuleKinds.NAMED_TYPE && ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {\n    return getSuggestionsForImplements(token, state, schema, queryText, typeInfo);\n  }\n  if (kind === RuleKinds.SELECTION_SET || kind === RuleKinds.FIELD || kind === RuleKinds.ALIASED_FIELD) {\n    return getSuggestionsForFieldNames(token, typeInfo, opts);\n  }\n  if (kind === RuleKinds.ARGUMENTS || kind === RuleKinds.ARGUMENT && step === 0) {\n    const argDefs = typeInfo.argDefs;\n    if (argDefs) {\n      return hintList(token, argDefs.map((argDef) => {\n        var _a2;\n        return {\n          label: argDef.name,\n          insertText: argDef.name + \": \",\n          command: SuggestionCommand,\n          detail: String(argDef.type),\n          documentation: (_a2 = argDef.description) !== null && _a2 !== void 0 ? _a2 : void 0,\n          kind: CompletionItemKind.Variable,\n          type: argDef.type\n        };\n      }));\n    }\n  }\n  if (kind === RuleKinds.OBJECT_VALUE || kind === RuleKinds.OBJECT_FIELD && step === 0) {\n    if (typeInfo.objectFieldDefs) {\n      const objectFields = objectValues(typeInfo.objectFieldDefs);\n      const completionKind = kind === RuleKinds.OBJECT_VALUE ? CompletionItemKind.Value : CompletionItemKind.Field;\n      return hintList(token, objectFields.map((field) => {\n        var _a2;\n        return {\n          label: field.name,\n          detail: String(field.type),\n          documentation: (_a2 = field.description) !== null && _a2 !== void 0 ? _a2 : void 0,\n          kind: completionKind,\n          type: field.type\n        };\n      }));\n    }\n  }\n  if (kind === RuleKinds.ENUM_VALUE || kind === RuleKinds.LIST_VALUE && step === 1 || kind === RuleKinds.OBJECT_FIELD && step === 2 || kind === RuleKinds.ARGUMENT && step === 2) {\n    return getSuggestionsForInputValues(token, typeInfo, queryText, schema);\n  }\n  if (kind === RuleKinds.VARIABLE && step === 1) {\n    const namedInputType = getNamedType(typeInfo.inputType);\n    const variableDefinitions = getVariableCompletions(queryText, schema, token);\n    return hintList(token, variableDefinitions.filter((v) => v.detail === (namedInputType === null || namedInputType === void 0 ? void 0 : namedInputType.name)));\n  }\n  if (kind === RuleKinds.TYPE_CONDITION && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState != null && state.prevState.kind === RuleKinds.TYPE_CONDITION) {\n    return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema);\n  }\n  if (kind === RuleKinds.FRAGMENT_SPREAD && step === 1) {\n    return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, Array.isArray(fragmentDefs) ? fragmentDefs : collectFragmentDefs(fragmentDefs));\n  }\n  if (kind === RuleKinds.VARIABLE_DEFINITION && step === 2 || kind === RuleKinds.LIST_TYPE && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState && (state.prevState.kind === RuleKinds.VARIABLE_DEFINITION || state.prevState.kind === RuleKinds.LIST_TYPE || state.prevState.kind === RuleKinds.NON_NULL_TYPE)) {\n    return getSuggestionsForVariableDefinition(token, schema);\n  }\n  if (kind === RuleKinds.DIRECTIVE) {\n    return getSuggestionsForDirective(token, state, schema);\n  }\n  return [];\n}\n__name(getAutocompleteSuggestions, \"getAutocompleteSuggestions\");\nconst insertSuffix = ` {\n  $1\n}`;\nconst getInsertText = /* @__PURE__ */ __name((field) => {\n  const type = field.type;\n  if (isCompositeType(type)) {\n    return insertSuffix;\n  }\n  if (isListType(type) && isCompositeType(type.ofType)) {\n    return insertSuffix;\n  }\n  if (isNonNullType(type)) {\n    if (isCompositeType(type.ofType)) {\n      return insertSuffix;\n    }\n    if (isListType(type.ofType) && isCompositeType(type.ofType.ofType)) {\n      return insertSuffix;\n    }\n  }\n  return null;\n}, \"getInsertText\");\nfunction getSuggestionsForFieldNames(token, typeInfo, options) {\n  var _a;\n  if (typeInfo.parentType) {\n    const parentType = typeInfo.parentType;\n    let fields = [];\n    if (\"getFields\" in parentType) {\n      fields = objectValues(parentType.getFields());\n    }\n    if (isCompositeType(parentType)) {\n      fields.push(TypeNameMetaFieldDef$1);\n    }\n    if (parentType === ((_a = options === null || options === void 0 ? void 0 : options.schema) === null || _a === void 0 ? void 0 : _a.getQueryType())) {\n      fields.push(SchemaMetaFieldDef$1, TypeMetaFieldDef$1);\n    }\n    return hintList(token, fields.map((field, index) => {\n      var _a2;\n      const suggestion = {\n        sortText: String(index) + field.name,\n        label: field.name,\n        detail: String(field.type),\n        documentation: (_a2 = field.description) !== null && _a2 !== void 0 ? _a2 : void 0,\n        deprecated: Boolean(field.deprecationReason),\n        isDeprecated: Boolean(field.deprecationReason),\n        deprecationReason: field.deprecationReason,\n        kind: CompletionItemKind.Field,\n        type: field.type\n      };\n      const insertText = getInsertText(field);\n      if (insertText) {\n        suggestion.insertText = field.name + insertText;\n        suggestion.insertTextFormat = InsertTextFormat.Snippet;\n        suggestion.command = SuggestionCommand;\n      }\n      return suggestion;\n    }));\n  }\n  return [];\n}\n__name(getSuggestionsForFieldNames, \"getSuggestionsForFieldNames\");\nfunction getSuggestionsForInputValues(token, typeInfo, queryText, schema) {\n  const namedInputType = getNamedType(typeInfo.inputType);\n  const queryVariables = getVariableCompletions(queryText, schema, token).filter((v) => v.detail === namedInputType.name);\n  if (namedInputType instanceof GraphQLEnumType) {\n    const values = namedInputType.getValues();\n    return hintList(token, values.map((value) => {\n      var _a;\n      return {\n        label: value.name,\n        detail: String(namedInputType),\n        documentation: (_a = value.description) !== null && _a !== void 0 ? _a : void 0,\n        deprecated: Boolean(value.deprecationReason),\n        isDeprecated: Boolean(value.deprecationReason),\n        deprecationReason: value.deprecationReason,\n        kind: CompletionItemKind.EnumMember,\n        type: namedInputType\n      };\n    }).concat(queryVariables));\n  } else if (namedInputType === GraphQLBoolean) {\n    return hintList(token, queryVariables.concat([\n      {\n        label: \"true\",\n        detail: String(GraphQLBoolean),\n        documentation: \"Not false.\",\n        kind: CompletionItemKind.Variable,\n        type: GraphQLBoolean\n      },\n      {\n        label: \"false\",\n        detail: String(GraphQLBoolean),\n        documentation: \"Not true.\",\n        kind: CompletionItemKind.Variable,\n        type: GraphQLBoolean\n      }\n    ]));\n  }\n  return queryVariables;\n}\n__name(getSuggestionsForInputValues, \"getSuggestionsForInputValues\");\nfunction getSuggestionsForImplements(token, tokenState, schema, documentText, typeInfo) {\n  if (tokenState.needsSeperator) {\n    return [];\n  }\n  const typeMap = schema.getTypeMap();\n  const schemaInterfaces = objectValues(typeMap).filter(isInterfaceType);\n  const schemaInterfaceNames = schemaInterfaces.map(({ name }) => name);\n  const inlineInterfaces = /* @__PURE__ */ new Set();\n  runOnlineParser(documentText, (_, state) => {\n    var _a, _b, _c, _d, _e;\n    if (state.name) {\n      if (state.kind === RuleKinds.INTERFACE_DEF && !schemaInterfaceNames.includes(state.name)) {\n        inlineInterfaces.add(state.name);\n      }\n      if (state.kind === RuleKinds.NAMED_TYPE && ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {\n        if (typeInfo.interfaceDef) {\n          const existingType = (_b = typeInfo.interfaceDef) === null || _b === void 0 ? void 0 : _b.getInterfaces().find(({ name }) => name === state.name);\n          if (existingType) {\n            return;\n          }\n          const type = schema.getType(state.name);\n          const interfaceConfig = (_c = typeInfo.interfaceDef) === null || _c === void 0 ? void 0 : _c.toConfig();\n          typeInfo.interfaceDef = new GraphQLInterfaceType(Object.assign(Object.assign({}, interfaceConfig), { interfaces: [\n            ...interfaceConfig.interfaces,\n            type || new GraphQLInterfaceType({ name: state.name, fields: {} })\n          ] }));\n        } else if (typeInfo.objectTypeDef) {\n          const existingType = (_d = typeInfo.objectTypeDef) === null || _d === void 0 ? void 0 : _d.getInterfaces().find(({ name }) => name === state.name);\n          if (existingType) {\n            return;\n          }\n          const type = schema.getType(state.name);\n          const objectTypeConfig = (_e = typeInfo.objectTypeDef) === null || _e === void 0 ? void 0 : _e.toConfig();\n          typeInfo.objectTypeDef = new GraphQLObjectType(Object.assign(Object.assign({}, objectTypeConfig), { interfaces: [\n            ...objectTypeConfig.interfaces,\n            type || new GraphQLInterfaceType({ name: state.name, fields: {} })\n          ] }));\n        }\n      }\n    }\n  });\n  const currentTypeToExtend = typeInfo.interfaceDef || typeInfo.objectTypeDef;\n  const siblingInterfaces = (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.getInterfaces()) || [];\n  const siblingInterfaceNames = siblingInterfaces.map(({ name }) => name);\n  const possibleInterfaces = schemaInterfaces.concat([...inlineInterfaces].map((name) => ({ name }))).filter(({ name }) => name !== (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.name) && !siblingInterfaceNames.includes(name));\n  return hintList(token, possibleInterfaces.map((type) => {\n    const result = {\n      label: type.name,\n      kind: CompletionItemKind.Interface,\n      type\n    };\n    if (type === null || type === void 0 ? void 0 : type.description) {\n      result.documentation = type.description;\n    }\n    return result;\n  }));\n}\n__name(getSuggestionsForImplements, \"getSuggestionsForImplements\");\nfunction getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind) {\n  let possibleTypes;\n  if (typeInfo.parentType) {\n    if (isAbstractType(typeInfo.parentType)) {\n      const abstractType = assertAbstractType(typeInfo.parentType);\n      const possibleObjTypes = schema.getPossibleTypes(abstractType);\n      const possibleIfaceMap = /* @__PURE__ */ Object.create(null);\n      possibleObjTypes.forEach((type) => {\n        type.getInterfaces().forEach((iface) => {\n          possibleIfaceMap[iface.name] = iface;\n        });\n      });\n      possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));\n    } else {\n      possibleTypes = [typeInfo.parentType];\n    }\n  } else {\n    const typeMap = schema.getTypeMap();\n    possibleTypes = objectValues(typeMap).filter(isCompositeType);\n  }\n  return hintList(token, possibleTypes.map((type) => {\n    const namedType = getNamedType(type);\n    return {\n      label: String(type),\n      documentation: (namedType === null || namedType === void 0 ? void 0 : namedType.description) || \"\",\n      kind: CompletionItemKind.Field\n    };\n  }));\n}\n__name(getSuggestionsForFragmentTypeConditions, \"getSuggestionsForFragmentTypeConditions\");\nfunction getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs) {\n  if (!queryText) {\n    return [];\n  }\n  const typeMap = schema.getTypeMap();\n  const defState = getDefinitionState(token.state);\n  const fragments = getFragmentDefinitions(queryText);\n  if (fragmentDefs && fragmentDefs.length > 0) {\n    fragments.push(...fragmentDefs);\n  }\n  const relevantFrags = fragments.filter((frag) => typeMap[frag.typeCondition.name.value] && !(defState && defState.kind === RuleKinds.FRAGMENT_DEFINITION && defState.name === frag.name.value) && isCompositeType(typeInfo.parentType) && isCompositeType(typeMap[frag.typeCondition.name.value]) && doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));\n  return hintList(token, relevantFrags.map((frag) => ({\n    label: frag.name.value,\n    detail: String(typeMap[frag.typeCondition.name.value]),\n    documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,\n    kind: CompletionItemKind.Field,\n    type: typeMap[frag.typeCondition.name.value]\n  })));\n}\n__name(getSuggestionsForFragmentSpread, \"getSuggestionsForFragmentSpread\");\nconst getParentDefinition = /* @__PURE__ */ __name((state, kind) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n  if (((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === kind) {\n    return state.prevState;\n  }\n  if (((_c = (_b = state.prevState) === null || _b === void 0 ? void 0 : _b.prevState) === null || _c === void 0 ? void 0 : _c.kind) === kind) {\n    return state.prevState.prevState;\n  }\n  if (((_f = (_e = (_d = state.prevState) === null || _d === void 0 ? void 0 : _d.prevState) === null || _e === void 0 ? void 0 : _e.prevState) === null || _f === void 0 ? void 0 : _f.kind) === kind) {\n    return state.prevState.prevState.prevState;\n  }\n  if (((_k = (_j = (_h = (_g = state.prevState) === null || _g === void 0 ? void 0 : _g.prevState) === null || _h === void 0 ? void 0 : _h.prevState) === null || _j === void 0 ? void 0 : _j.prevState) === null || _k === void 0 ? void 0 : _k.kind) === kind) {\n    return state.prevState.prevState.prevState.prevState;\n  }\n}, \"getParentDefinition\");\nfunction getVariableCompletions(queryText, schema, token) {\n  let variableName = null;\n  let variableType;\n  const definitions = /* @__PURE__ */ Object.create({});\n  runOnlineParser(queryText, (_, state) => {\n    if ((state === null || state === void 0 ? void 0 : state.kind) === RuleKinds.VARIABLE && state.name) {\n      variableName = state.name;\n    }\n    if ((state === null || state === void 0 ? void 0 : state.kind) === RuleKinds.NAMED_TYPE && variableName) {\n      const parentDefinition = getParentDefinition(state, RuleKinds.TYPE);\n      if (parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type) {\n        variableType = schema.getType(parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type);\n      }\n    }\n    if (variableName && variableType) {\n      if (!definitions[variableName]) {\n        definitions[variableName] = {\n          detail: variableType.toString(),\n          insertText: token.string === \"$\" ? variableName : \"$\" + variableName,\n          label: variableName,\n          type: variableType,\n          kind: CompletionItemKind.Variable\n        };\n        variableName = null;\n        variableType = null;\n      }\n    }\n  });\n  return objectValues(definitions);\n}\n__name(getVariableCompletions, \"getVariableCompletions\");\nfunction getFragmentDefinitions(queryText) {\n  const fragmentDefs = [];\n  runOnlineParser(queryText, (_, state) => {\n    if (state.kind === RuleKinds.FRAGMENT_DEFINITION && state.name && state.type) {\n      fragmentDefs.push({\n        kind: RuleKinds.FRAGMENT_DEFINITION,\n        name: {\n          kind: Kind.NAME,\n          value: state.name\n        },\n        selectionSet: {\n          kind: RuleKinds.SELECTION_SET,\n          selections: []\n        },\n        typeCondition: {\n          kind: RuleKinds.NAMED_TYPE,\n          name: {\n            kind: Kind.NAME,\n            value: state.type\n          }\n        }\n      });\n    }\n  });\n  return fragmentDefs;\n}\n__name(getFragmentDefinitions, \"getFragmentDefinitions\");\nfunction getSuggestionsForVariableDefinition(token, schema, _kind) {\n  const inputTypeMap = schema.getTypeMap();\n  const inputTypes = objectValues(inputTypeMap).filter(isInputType);\n  return hintList(token, inputTypes.map((type) => ({\n    label: type.name,\n    documentation: type.description,\n    kind: CompletionItemKind.Variable\n  })));\n}\n__name(getSuggestionsForVariableDefinition, \"getSuggestionsForVariableDefinition\");\nfunction getSuggestionsForDirective(token, state, schema, _kind) {\n  var _a;\n  if ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) {\n    const directives = schema.getDirectives().filter((directive) => canUseDirective(state.prevState, directive));\n    return hintList(token, directives.map((directive) => ({\n      label: directive.name,\n      documentation: directive.description || \"\",\n      kind: CompletionItemKind.Function\n    })));\n  }\n  return [];\n}\n__name(getSuggestionsForDirective, \"getSuggestionsForDirective\");\nfunction getTokenAtPosition(queryText, cursor) {\n  let styleAtCursor = null;\n  let stateAtCursor = null;\n  let stringAtCursor = null;\n  const token = runOnlineParser(queryText, (stream, state, style, index) => {\n    if (index === cursor.line) {\n      if (stream.getCurrentPosition() >= cursor.character) {\n        styleAtCursor = style;\n        stateAtCursor = Object.assign({}, state);\n        stringAtCursor = stream.current();\n        return \"BREAK\";\n      }\n    }\n  });\n  return {\n    start: token.start,\n    end: token.end,\n    string: stringAtCursor || token.string,\n    state: stateAtCursor || token.state,\n    style: styleAtCursor || token.style\n  };\n}\n__name(getTokenAtPosition, \"getTokenAtPosition\");\nfunction runOnlineParser(queryText, callback) {\n  const lines = queryText.split(\"\\n\");\n  const parser = onlineParser();\n  let state = parser.startState();\n  let style = \"\";\n  let stream = new CharacterStream(\"\");\n  for (let i = 0; i < lines.length; i++) {\n    stream = new CharacterStream(lines[i]);\n    while (!stream.eol()) {\n      style = parser.token(stream, state);\n      const code = callback(stream, state, style, i);\n      if (code === \"BREAK\") {\n        break;\n      }\n    }\n    callback(stream, state, style, i);\n    if (!state.kind) {\n      state = parser.startState();\n    }\n  }\n  return {\n    start: stream.getStartOfToken(),\n    end: stream.getCurrentPosition(),\n    string: stream.current(),\n    state,\n    style\n  };\n}\n__name(runOnlineParser, \"runOnlineParser\");\nfunction canUseDirective(state, directive) {\n  var _a;\n  if (!state || !state.kind) {\n    return false;\n  }\n  const kind = state.kind;\n  const locations = directive.locations;\n  switch (kind) {\n    case RuleKinds.QUERY:\n      return locations.indexOf(DirectiveLocation.QUERY) !== -1;\n    case RuleKinds.MUTATION:\n      return locations.indexOf(DirectiveLocation.MUTATION) !== -1;\n    case RuleKinds.SUBSCRIPTION:\n      return locations.indexOf(DirectiveLocation.SUBSCRIPTION) !== -1;\n    case RuleKinds.FIELD:\n    case RuleKinds.ALIASED_FIELD:\n      return locations.indexOf(DirectiveLocation.FIELD) !== -1;\n    case RuleKinds.FRAGMENT_DEFINITION:\n      return locations.indexOf(DirectiveLocation.FRAGMENT_DEFINITION) !== -1;\n    case RuleKinds.FRAGMENT_SPREAD:\n      return locations.indexOf(DirectiveLocation.FRAGMENT_SPREAD) !== -1;\n    case RuleKinds.INLINE_FRAGMENT:\n      return locations.indexOf(DirectiveLocation.INLINE_FRAGMENT) !== -1;\n    case RuleKinds.SCHEMA_DEF:\n      return locations.indexOf(DirectiveLocation.SCHEMA) !== -1;\n    case RuleKinds.SCALAR_DEF:\n      return locations.indexOf(DirectiveLocation.SCALAR) !== -1;\n    case RuleKinds.OBJECT_TYPE_DEF:\n      return locations.indexOf(DirectiveLocation.OBJECT) !== -1;\n    case RuleKinds.FIELD_DEF:\n      return locations.indexOf(DirectiveLocation.FIELD_DEFINITION) !== -1;\n    case RuleKinds.INTERFACE_DEF:\n      return locations.indexOf(DirectiveLocation.INTERFACE) !== -1;\n    case RuleKinds.UNION_DEF:\n      return locations.indexOf(DirectiveLocation.UNION) !== -1;\n    case RuleKinds.ENUM_DEF:\n      return locations.indexOf(DirectiveLocation.ENUM) !== -1;\n    case RuleKinds.ENUM_VALUE:\n      return locations.indexOf(DirectiveLocation.ENUM_VALUE) !== -1;\n    case RuleKinds.INPUT_DEF:\n      return locations.indexOf(DirectiveLocation.INPUT_OBJECT) !== -1;\n    case RuleKinds.INPUT_VALUE_DEF:\n      const prevStateKind = (_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind;\n      switch (prevStateKind) {\n        case RuleKinds.ARGUMENTS_DEF:\n          return locations.indexOf(DirectiveLocation.ARGUMENT_DEFINITION) !== -1;\n        case RuleKinds.INPUT_DEF:\n          return locations.indexOf(DirectiveLocation.INPUT_FIELD_DEFINITION) !== -1;\n      }\n  }\n  return false;\n}\n__name(canUseDirective, \"canUseDirective\");\nfunction getTypeInfo(schema, tokenState) {\n  let argDef;\n  let argDefs;\n  let directiveDef;\n  let enumValue;\n  let fieldDef;\n  let inputType;\n  let objectTypeDef;\n  let objectFieldDefs;\n  let parentType;\n  let type;\n  let interfaceDef;\n  forEachState(tokenState, (state) => {\n    var _a;\n    switch (state.kind) {\n      case RuleKinds.QUERY:\n      case \"ShortQuery\":\n        type = schema.getQueryType();\n        break;\n      case RuleKinds.MUTATION:\n        type = schema.getMutationType();\n        break;\n      case RuleKinds.SUBSCRIPTION:\n        type = schema.getSubscriptionType();\n        break;\n      case RuleKinds.INLINE_FRAGMENT:\n      case RuleKinds.FRAGMENT_DEFINITION:\n        if (state.type) {\n          type = schema.getType(state.type);\n        }\n        break;\n      case RuleKinds.FIELD:\n      case RuleKinds.ALIASED_FIELD: {\n        if (!type || !state.name) {\n          fieldDef = null;\n        } else {\n          fieldDef = parentType ? getFieldDef(schema, parentType, state.name) : null;\n          type = fieldDef ? fieldDef.type : null;\n        }\n        break;\n      }\n      case RuleKinds.SELECTION_SET:\n        parentType = getNamedType(type);\n        break;\n      case RuleKinds.DIRECTIVE:\n        directiveDef = state.name ? schema.getDirective(state.name) : null;\n        break;\n      case RuleKinds.INTERFACE_DEF:\n        if (state.name) {\n          objectTypeDef = null;\n          interfaceDef = new GraphQLInterfaceType({\n            name: state.name,\n            interfaces: [],\n            fields: {}\n          });\n        }\n        break;\n      case RuleKinds.OBJECT_TYPE_DEF:\n        if (state.name) {\n          interfaceDef = null;\n          objectTypeDef = new GraphQLObjectType({\n            name: state.name,\n            interfaces: [],\n            fields: {}\n          });\n        }\n        break;\n      case RuleKinds.ARGUMENTS: {\n        if (!state.prevState) {\n          argDefs = null;\n        } else {\n          switch (state.prevState.kind) {\n            case RuleKinds.FIELD:\n              argDefs = fieldDef && fieldDef.args;\n              break;\n            case RuleKinds.DIRECTIVE:\n              argDefs = directiveDef && directiveDef.args;\n              break;\n            case RuleKinds.ALIASED_FIELD: {\n              const name = (_a = state.prevState) === null || _a === void 0 ? void 0 : _a.name;\n              if (!name) {\n                argDefs = null;\n                break;\n              }\n              const field = parentType ? getFieldDef(schema, parentType, name) : null;\n              if (!field) {\n                argDefs = null;\n                break;\n              }\n              argDefs = field.args;\n              break;\n            }\n            default:\n              argDefs = null;\n              break;\n          }\n        }\n        break;\n      }\n      case RuleKinds.ARGUMENT:\n        if (argDefs) {\n          for (let i = 0; i < argDefs.length; i++) {\n            if (argDefs[i].name === state.name) {\n              argDef = argDefs[i];\n              break;\n            }\n          }\n        }\n        inputType = argDef === null || argDef === void 0 ? void 0 : argDef.type;\n        break;\n      case RuleKinds.ENUM_VALUE:\n        const enumType = getNamedType(inputType);\n        enumValue = enumType instanceof GraphQLEnumType ? enumType.getValues().find((val) => val.value === state.name) : null;\n        break;\n      case RuleKinds.LIST_VALUE:\n        const nullableType = getNullableType(inputType);\n        inputType = nullableType instanceof GraphQLList ? nullableType.ofType : null;\n        break;\n      case RuleKinds.OBJECT_VALUE:\n        const objectType = getNamedType(inputType);\n        objectFieldDefs = objectType instanceof GraphQLInputObjectType ? objectType.getFields() : null;\n        break;\n      case RuleKinds.OBJECT_FIELD:\n        const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;\n        inputType = objectField === null || objectField === void 0 ? void 0 : objectField.type;\n        break;\n      case RuleKinds.NAMED_TYPE:\n        if (state.name) {\n          type = schema.getType(state.name);\n        }\n        break;\n    }\n  });\n  return {\n    argDef,\n    argDefs,\n    directiveDef,\n    enumValue,\n    fieldDef,\n    inputType,\n    objectFieldDefs,\n    parentType,\n    type,\n    interfaceDef,\n    objectTypeDef\n  };\n}\n__name(getTypeInfo, \"getTypeInfo\");\nCodeMirror.registerHelper(\"hint\", \"graphql\", (editor, options) => {\n  const schema = options.schema;\n  if (!schema) {\n    return;\n  }\n  const cur = editor.getCursor();\n  const token = editor.getTokenAt(cur);\n  const tokenStart = token.type !== null && /\"|\\w/.test(token.string[0]) ? token.start : token.end;\n  const position = new Position(cur.line, tokenStart);\n  const rawResults = getAutocompleteSuggestions(schema, editor.getValue(), position, token, options.externalFragments);\n  const results = {\n    list: rawResults.map((item) => ({\n      text: item.label,\n      type: item.type,\n      description: item.documentation,\n      isDeprecated: item.isDeprecated,\n      deprecationReason: item.deprecationReason\n    })),\n    from: { line: cur.line, ch: tokenStart },\n    to: { line: cur.line, ch: token.end }\n  };\n  if ((results === null || results === void 0 ? void 0 : results.list) && results.list.length > 0) {\n    results.from = CodeMirror.Pos(results.from.line, results.from.ch);\n    results.to = CodeMirror.Pos(results.to.line, results.to.ch);\n    CodeMirror.signal(editor, \"hasCompletion\", editor, results, token);\n  }\n  return results;\n});\n"],"names":[],"sourceRoot":"","ignoreList":[0,1]}